From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: Revert upstreamed RISC-V changes

This allows the patch series to be maintained and modified on an ongoing
basis.
---
 cmake/config-ix.cmake                         |     4 -
 docs/CompilerWriterInfo.rst                   |     4 -
 include/llvm/ADT/Triple.h                     |     2 -
 include/llvm/BinaryFormat/COFF.h              |     3 -
 include/llvm/BinaryFormat/ELF.h               |    17 -
 include/llvm/BinaryFormat/ELFRelocs/RISCV.def |    59 -
 include/llvm/IR/Intrinsics.td                 |     1 -
 include/llvm/IR/IntrinsicsRISCV.td            |    44 -
 include/llvm/Object/ELFObjectFile.h           |    15 -
 include/llvm/module.modulemap                 |     1 -
 .../SelectionDAG/LegalizeIntegerTypes.cpp     |    23 -
 lib/CodeGen/SelectionDAG/LegalizeTypes.h      |     2 -
 lib/Object/ELF.cpp                            |     9 -
 lib/Object/ELFObjectFile.cpp                  |    13 -
 lib/ObjectYAML/ELFYAML.cpp                    |    12 -
 lib/Support/Triple.cpp                        |    21 -
 lib/Target/LLVMBuild.txt                      |     1 -
 lib/Target/RISCV/AsmParser/CMakeLists.txt     |     3 -
 lib/Target/RISCV/AsmParser/LLVMBuild.txt      |    23 -
 lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp |  1473 ---
 lib/Target/RISCV/CMakeLists.txt               |    37 -
 lib/Target/RISCV/Disassembler/CMakeLists.txt  |     3 -
 lib/Target/RISCV/Disassembler/LLVMBuild.txt   |    24 -
 .../RISCV/Disassembler/RISCVDisassembler.cpp  |   324 -
 lib/Target/RISCV/InstPrinter/CMakeLists.txt   |     3 -
 lib/Target/RISCV/InstPrinter/LLVMBuild.txt    |    23 -
 .../RISCV/InstPrinter/RISCVInstPrinter.cpp    |   115 -
 .../RISCV/InstPrinter/RISCVInstPrinter.h      |    55 -
 lib/Target/RISCV/LLVMBuild.txt                |    35 -
 lib/Target/RISCV/MCTargetDesc/CMakeLists.txt  |    10 -
 lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt   |    23 -
 .../RISCV/MCTargetDesc/RISCVAsmBackend.cpp    |   302 -
 .../RISCV/MCTargetDesc/RISCVAsmBackend.h      |   113 -
 .../MCTargetDesc/RISCVELFObjectWriter.cpp     |   105 -
 .../RISCV/MCTargetDesc/RISCVELFStreamer.cpp   |    46 -
 .../RISCV/MCTargetDesc/RISCVELFStreamer.h     |    31 -
 .../RISCV/MCTargetDesc/RISCVFixupKinds.h      |    64 -
 .../RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp     |    27 -
 .../RISCV/MCTargetDesc/RISCVMCAsmInfo.h       |    31 -
 .../RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp |   273 -
 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp |   202 -
 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h   |    88 -
 .../RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp  |   102 -
 .../RISCV/MCTargetDesc/RISCVMCTargetDesc.h    |    62 -
 .../MCTargetDesc/RISCVTargetStreamer.cpp      |    48 -
 .../RISCV/MCTargetDesc/RISCVTargetStreamer.h  |    45 -
 lib/Target/RISCV/RISCV.h                      |    45 -
 lib/Target/RISCV/RISCV.td                     |   106 -
 lib/Target/RISCV/RISCVAsmPrinter.cpp          |   138 -
 lib/Target/RISCV/RISCVCallingConv.td          |    57 -
 lib/Target/RISCV/RISCVExpandPseudoInsts.cpp   |   556 -
 lib/Target/RISCV/RISCVFrameLowering.cpp       |   298 -
 lib/Target/RISCV/RISCVFrameLowering.h         |    59 -
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp        |   282 -
 lib/Target/RISCV/RISCVISelLowering.cpp        |  1733 ---
 lib/Target/RISCV/RISCVISelLowering.h          |   140 -
 lib/Target/RISCV/RISCVInstrFormats.td         |   286 -
 lib/Target/RISCV/RISCVInstrFormatsC.td        |   160 -
 lib/Target/RISCV/RISCVInstrInfo.cpp           |   450 -
 lib/Target/RISCV/RISCVInstrInfo.h             |    84 -
 lib/Target/RISCV/RISCVInstrInfo.td            |   935 --
 lib/Target/RISCV/RISCVInstrInfoA.td           |   278 -
 lib/Target/RISCV/RISCVInstrInfoC.td           |   714 --
 lib/Target/RISCV/RISCVInstrInfoD.td           |   310 -
 lib/Target/RISCV/RISCVInstrInfoF.td           |   336 -
 lib/Target/RISCV/RISCVInstrInfoM.td           |    51 -
 lib/Target/RISCV/RISCVMCInstLower.cpp         |   108 -
 lib/Target/RISCV/RISCVMachineFunctionInfo.h   |    55 -
 lib/Target/RISCV/RISCVMergeBaseOffset.cpp     |   286 -
 lib/Target/RISCV/RISCVRegisterInfo.cpp        |   128 -
 lib/Target/RISCV/RISCVRegisterInfo.h          |    59 -
 lib/Target/RISCV/RISCVRegisterInfo.td         |   230 -
 lib/Target/RISCV/RISCVSubtarget.cpp           |    48 -
 lib/Target/RISCV/RISCVSubtarget.h             |    87 -
 lib/Target/RISCV/RISCVSystemOperands.td       |   352 -
 lib/Target/RISCV/RISCVTargetMachine.cpp       |   108 -
 lib/Target/RISCV/RISCVTargetMachine.h         |    46 -
 lib/Target/RISCV/RISCVTargetObjectFile.cpp    |    19 -
 lib/Target/RISCV/RISCVTargetObjectFile.h      |    25 -
 lib/Target/RISCV/TargetInfo/CMakeLists.txt    |     3 -
 lib/Target/RISCV/TargetInfo/LLVMBuild.txt     |    23 -
 .../RISCV/TargetInfo/RISCVTargetInfo.cpp      |    30 -
 lib/Target/RISCV/Utils/CMakeLists.txt         |     4 -
 lib/Target/RISCV/Utils/LLVMBuild.txt          |    24 -
 lib/Target/RISCV/Utils/RISCVBaseInfo.cpp      |     9 -
 lib/Target/RISCV/Utils/RISCVBaseInfo.h        |   158 -
 lib/Target/RISCV/Utils/RISCVMatInt.cpp        |    79 -
 lib/Target/RISCV/Utils/RISCVMatInt.h          |    36 -
 test/Assembler/empty-string.s                 |     3 -
 test/CodeGen/RISCV/addc-adde-sube-subc.ll     |    30 -
 test/CodeGen/RISCV/align.ll                   |    13 -
 test/CodeGen/RISCV/alloca.ll                  |   105 -
 test/CodeGen/RISCV/alu16.ll                   |   324 -
 test/CodeGen/RISCV/alu32.ll                   |   299 -
 test/CodeGen/RISCV/alu64.ll                   |   499 -
 test/CodeGen/RISCV/alu8.ll                    |   308 -
 test/CodeGen/RISCV/analyze-branch.ll          |    79 -
 test/CodeGen/RISCV/arith-with-overflow.ll     |    84 -
 test/CodeGen/RISCV/atomic-cmpxchg.ll          |  1489 ---
 test/CodeGen/RISCV/atomic-fence.ll            |    41 -
 test/CodeGen/RISCV/atomic-load-store.ll       |   668 -
 test/CodeGen/RISCV/atomic-rmw.ll              | 10415 ----------------
 test/CodeGen/RISCV/bare-select.ll             |    31 -
 test/CodeGen/RISCV/blockaddress.ll            |    29 -
 test/CodeGen/RISCV/branch-relaxation.ll       |    65 -
 test/CodeGen/RISCV/branch.ll                  |   109 -
 test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll   |   542 -
 test/CodeGen/RISCV/byval.ll                   |    43 -
 .../CodeGen/RISCV/calling-conv-rv32f-ilp32.ll |    81 -
 test/CodeGen/RISCV/calling-conv-sext-zext.ll  |   344 -
 test/CodeGen/RISCV/calling-conv.ll            |  1068 --
 test/CodeGen/RISCV/calls.ll                   |   146 -
 test/CodeGen/RISCV/compress-inline-asm.ll     |    15 -
 test/CodeGen/RISCV/compress.ll                |   165 -
 test/CodeGen/RISCV/disable-tail-calls.ll      |    56 -
 test/CodeGen/RISCV/div.ll                     |   217 -
 test/CodeGen/RISCV/double-arith.ll            |   398 -
 test/CodeGen/RISCV/double-br-fcmp.ll          |   500 -
 test/CodeGen/RISCV/double-calling-conv.ll     |   154 -
 test/CodeGen/RISCV/double-convert.ll          |    89 -
 test/CodeGen/RISCV/double-fcmp.ll             |   299 -
 test/CodeGen/RISCV/double-frem.ll             |    16 -
 test/CodeGen/RISCV/double-imm.ll              |    38 -
 test/CodeGen/RISCV/double-intrinsics.ll       |   442 -
 test/CodeGen/RISCV/double-mem.ll              |   185 -
 test/CodeGen/RISCV/double-previous-failure.ll |    65 -
 test/CodeGen/RISCV/double-select-fcmp.ll      |   423 -
 .../RISCV/double-stack-spill-restore.ll       |    45 -
 test/CodeGen/RISCV/fixups-diff.ll             |    46 -
 test/CodeGen/RISCV/fixups-relax-diff.ll       |    20 -
 test/CodeGen/RISCV/float-arith.ll             |   267 -
 test/CodeGen/RISCV/float-br-fcmp.ll           |   494 -
 test/CodeGen/RISCV/float-convert.ll           |    72 -
 test/CodeGen/RISCV/float-fcmp.ll              |   215 -
 test/CodeGen/RISCV/float-frem.ll              |    16 -
 test/CodeGen/RISCV/float-imm.ll               |    27 -
 test/CodeGen/RISCV/float-intrinsics.ll        |   375 -
 test/CodeGen/RISCV/float-mem.ll               |   133 -
 test/CodeGen/RISCV/float-select-fcmp.ll       |   304 -
 test/CodeGen/RISCV/flt-rounds.ll              |    21 -
 test/CodeGen/RISCV/fp128.ll                   |    97 -
 test/CodeGen/RISCV/frame.ll                   |    54 -
 test/CodeGen/RISCV/frameaddr-returnaddr.ll    |   152 -
 test/CodeGen/RISCV/get-setcc-result-type.ll   |    31 -
 test/CodeGen/RISCV/hoist-global-addr-base.ll  |   169 -
 test/CodeGen/RISCV/i32-icmp.ll                |   134 -
 test/CodeGen/RISCV/imm-cse.ll                 |    39 -
 test/CodeGen/RISCV/imm.ll                     |   260 -
 test/CodeGen/RISCV/indirectbr.ll              |    40 -
 test/CodeGen/RISCV/init-array.ll              |    30 -
 test/CodeGen/RISCV/inline-asm.ll              |    54 -
 .../RISCV/interrupt-attr-args-error.ll        |    11 -
 test/CodeGen/RISCV/interrupt-attr-invalid.ll  |    11 -
 test/CodeGen/RISCV/interrupt-attr-nocall.ll   |   217 -
 .../CodeGen/RISCV/interrupt-attr-ret-error.ll |    12 -
 test/CodeGen/RISCV/interrupt-attr.ll          |  1066 --
 test/CodeGen/RISCV/jumptable.ll               |    58 -
 test/CodeGen/RISCV/large-stack.ll             |   172 -
 test/CodeGen/RISCV/lit.local.cfg              |     2 -
 test/CodeGen/RISCV/lsr-legaladdimm.ll         |    48 -
 test/CodeGen/RISCV/mem.ll                     |   197 -
 test/CodeGen/RISCV/mem64.ll                   |   226 -
 test/CodeGen/RISCV/mul.ll                     |   175 -
 test/CodeGen/RISCV/musttail-call.ll           |    20 -
 test/CodeGen/RISCV/option-norelax.ll          |    16 -
 test/CodeGen/RISCV/option-norvc.ll            |    15 -
 test/CodeGen/RISCV/option-relax.ll            |    16 -
 test/CodeGen/RISCV/option-rvc.ll              |    15 -
 test/CodeGen/RISCV/prefetch.ll                |    19 -
 test/CodeGen/RISCV/rem.ll                     |    41 -
 test/CodeGen/RISCV/remat.ll                   |   200 -
 test/CodeGen/RISCV/rotl-rotr.ll               |    38 -
 .../CodeGen/RISCV/rv64i-exhaustive-w-insts.ll |  1769 ---
 test/CodeGen/RISCV/rv64i-tricky-shifts.ll     |    44 -
 test/CodeGen/RISCV/select-cc.ll               |   100 -
 test/CodeGen/RISCV/sext-zext-trunc.ll         |   438 -
 test/CodeGen/RISCV/shift-masked-shamt.ll      |    70 -
 test/CodeGen/RISCV/shifts.ll                  |    45 -
 test/CodeGen/RISCV/tail-calls.ll              |   148 -
 .../RISCV/umulo-128-legalisation-lowering.ll  |   138 -
 test/CodeGen/RISCV/vararg.ll                  |   819 --
 test/CodeGen/RISCV/wide-mem.ll                |    30 -
 test/CodeGen/RISCV/zext-with-load-is-free.ll  |    76 -
 test/DebugInfo/RISCV/lit.local.cfg            |     2 -
 test/DebugInfo/RISCV/relax-debug-line.ll      |    75 -
 test/MC/Disassembler/RISCV/fuzzer-invalid.txt |     8 -
 .../RISCV/invalid-fp-rounding-mode.txt        |     9 -
 .../RISCV/invalid-instruction.txt             |     9 -
 test/MC/Disassembler/RISCV/lit.local.cfg      |     3 -
 .../RISCV/unknown-fence-field.txt             |     9 -
 test/MC/RISCV/cnop.s                          |    27 -
 test/MC/RISCV/compress-cjal.s                 |    17 -
 test/MC/RISCV/compress-rv32d.s                |    44 -
 test/MC/RISCV/compress-rv32f.s                |    32 -
 test/MC/RISCV/compress-rv32i.s                |   219 -
 test/MC/RISCV/compress-rv64i.s                |    60 -
 test/MC/RISCV/compressed-relocations.s        |    22 -
 test/MC/RISCV/csr-aliases.s                   |   117 -
 test/MC/RISCV/data-directives-invalid.s       |    23 -
 test/MC/RISCV/data-directives-valid.s         |    32 -
 test/MC/RISCV/elf-flags.s                     |    13 -
 test/MC/RISCV/elf-header.s                    |    42 -
 test/MC/RISCV/fixups-compressed.s             |    25 -
 test/MC/RISCV/fixups-diagnostics.s            |    18 -
 test/MC/RISCV/fixups-expr.s                   |    47 -
 test/MC/RISCV/fixups.s                        |    83 -
 test/MC/RISCV/function-call-invalid.s         |    11 -
 test/MC/RISCV/function-call.s                 |    45 -
 test/MC/RISCV/hilo-constaddr-expr.s           |    31 -
 test/MC/RISCV/hilo-constaddr.s                |    17 -
 test/MC/RISCV/linker-relaxation.s             |    26 -
 test/MC/RISCV/lit.local.cfg                   |     3 -
 test/MC/RISCV/lla-invalid.s                   |     6 -
 test/MC/RISCV/machine-csr-names-invalid.s     |    40 -
 test/MC/RISCV/machine-csr-names.s             |  1229 --
 test/MC/RISCV/option-invalid.s                |    26 -
 test/MC/RISCV/option-pushpop.s                |    74 -
 test/MC/RISCV/option-relax.s                  |    66 -
 test/MC/RISCV/option-rvc.s                    |    90 -
 test/MC/RISCV/pcrel-lo12-invalid.s            |     5 -
 test/MC/RISCV/priv-invalid.s                  |     7 -
 test/MC/RISCV/priv-valid.s                    |    34 -
 test/MC/RISCV/relocations.s                   |    76 -
 test/MC/RISCV/rv32-machine-csr-names.s        |   474 -
 test/MC/RISCV/rv32-relaxation.s               |   127 -
 test/MC/RISCV/rv32-user-csr-names.s           |   457 -
 test/MC/RISCV/rv32a-invalid.s                 |    17 -
 test/MC/RISCV/rv32a-valid.s                   |   148 -
 test/MC/RISCV/rv32c-aliases-valid.s           |    65 -
 test/MC/RISCV/rv32c-fuzzed-invalid.s          |    17 -
 test/MC/RISCV/rv32c-invalid.s                 |    92 -
 test/MC/RISCV/rv32c-only-valid.s              |    19 -
 test/MC/RISCV/rv32c-valid.s                   |   108 -
 test/MC/RISCV/rv32d-invalid.s                 |    21 -
 test/MC/RISCV/rv32d-valid.s                   |   161 -
 test/MC/RISCV/rv32dc-invalid.s                |    12 -
 test/MC/RISCV/rv32dc-valid.s                  |    29 -
 test/MC/RISCV/rv32f-invalid.s                 |    34 -
 test/MC/RISCV/rv32f-valid.s                   |   166 -
 test/MC/RISCV/rv32fc-invalid.s                |    12 -
 test/MC/RISCV/rv32fc-valid.s                  |    35 -
 test/MC/RISCV/rv32i-aliases-invalid.s         |    23 -
 test/MC/RISCV/rv32i-aliases-valid.s           |    80 -
 test/MC/RISCV/rv32i-invalid.s                 |   176 -
 test/MC/RISCV/rv32i-valid.s                   |   275 -
 test/MC/RISCV/rv32m-invalid.s                 |     9 -
 test/MC/RISCV/rv32m-valid.s                   |    35 -
 test/MC/RISCV/rv64-machine-csr-names.s        |   246 -
 test/MC/RISCV/rv64-relaxation.s               |   104 -
 test/MC/RISCV/rv64-user-csr-names.s           |   236 -
 test/MC/RISCV/rv64a-invalid.s                 |    14 -
 test/MC/RISCV/rv64a-valid.s                   |   193 -
 test/MC/RISCV/rv64c-aliases-valid.s           |    96 -
 test/MC/RISCV/rv64c-invalid.s                 |    32 -
 test/MC/RISCV/rv64c-valid.s                   |    62 -
 test/MC/RISCV/rv64d-aliases-valid.s           |    27 -
 test/MC/RISCV/rv64d-invalid.s                 |    11 -
 test/MC/RISCV/rv64d-valid.s                   |    53 -
 test/MC/RISCV/rv64dc-valid.s                  |    29 -
 test/MC/RISCV/rv64f-aliases-valid.s           |    27 -
 test/MC/RISCV/rv64f-invalid.s                 |     9 -
 test/MC/RISCV/rv64f-valid.s                   |    41 -
 test/MC/RISCV/rv64i-aliases-invalid.s         |    28 -
 test/MC/RISCV/rv64i-aliases-valid.s           |   131 -
 test/MC/RISCV/rv64i-invalid.s                 |    20 -
 test/MC/RISCV/rv64i-valid.s                   |    99 -
 test/MC/RISCV/rv64m-valid.s                   |    21 -
 test/MC/RISCV/rvd-aliases-valid.s             |    85 -
 test/MC/RISCV/rvf-aliases-valid.s             |   139 -
 test/MC/RISCV/rvf-user-csr-names.s            |    71 -
 test/MC/RISCV/rvi-aliases-valid.s             |   247 -
 test/MC/RISCV/rvi-pseudos.s                   |    28 -
 test/MC/RISCV/supervisor-csr-names.s          |   193 -
 test/MC/RISCV/tail-call-invalid.s             |    12 -
 test/MC/RISCV/tail-call.s                     |    47 -
 test/MC/RISCV/user-csr-names-invalid.s        |    47 -
 test/MC/RISCV/user-csr-names.s                |   587 -
 test/Object/RISCV/elf-flags.yaml              |    24 -
 test/Object/RISCV/lit.local.cfg               |     2 -
 .../SimplifyCFG/RISCV/lit.local.cfg           |     5 -
 .../SimplifyCFG/RISCV/select-trunc-i64.ll     |    28 -
 tools/llvm-readobj/ELFDumper.cpp              |    13 -
 unittests/ADT/TripleTest.cpp                  |    36 -
 utils/TableGen/CMakeLists.txt                 |     1 -
 utils/TableGen/RISCVCompressInstEmitter.cpp   |   810 --
 utils/TableGen/TableGen.cpp                   |     6 -
 utils/TableGen/TableGenBackends.h             |     1 -
 utils/UpdateTestChecks/asm.py                 |    18 -
 utils/gn/secondary/clang/lib/Basic/BUILD.gn   |     1 -
 utils/gn/secondary/clang/lib/Driver/BUILD.gn  |     2 -
 utils/gn/secondary/lld/ELF/BUILD.gn           |     1 -
 .../gn/secondary/llvm/utils/TableGen/BUILD.gn |     1 -
 292 files changed, 51278 deletions(-)
 delete mode 100644 include/llvm/BinaryFormat/ELFRelocs/RISCV.def
 delete mode 100644 include/llvm/IR/IntrinsicsRISCV.td
 delete mode 100644 lib/Target/RISCV/AsmParser/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/AsmParser/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
 delete mode 100644 lib/Target/RISCV/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
 delete mode 100644 lib/Target/RISCV/InstPrinter/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/InstPrinter/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
 delete mode 100644 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
 delete mode 100644 lib/Target/RISCV/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
 delete mode 100644 lib/Target/RISCV/RISCV.h
 delete mode 100644 lib/Target/RISCV/RISCV.td
 delete mode 100644 lib/Target/RISCV/RISCVAsmPrinter.cpp
 delete mode 100644 lib/Target/RISCV/RISCVCallingConv.td
 delete mode 100644 lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
 delete mode 100644 lib/Target/RISCV/RISCVFrameLowering.cpp
 delete mode 100644 lib/Target/RISCV/RISCVFrameLowering.h
 delete mode 100644 lib/Target/RISCV/RISCVISelDAGToDAG.cpp
 delete mode 100644 lib/Target/RISCV/RISCVISelLowering.cpp
 delete mode 100644 lib/Target/RISCV/RISCVISelLowering.h
 delete mode 100644 lib/Target/RISCV/RISCVInstrFormats.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrFormatsC.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.cpp
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoA.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoC.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoD.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoF.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoM.td
 delete mode 100644 lib/Target/RISCV/RISCVMCInstLower.cpp
 delete mode 100644 lib/Target/RISCV/RISCVMachineFunctionInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVMergeBaseOffset.cpp
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.cpp
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.td
 delete mode 100644 lib/Target/RISCV/RISCVSubtarget.cpp
 delete mode 100644 lib/Target/RISCV/RISCVSubtarget.h
 delete mode 100644 lib/Target/RISCV/RISCVSystemOperands.td
 delete mode 100644 lib/Target/RISCV/RISCVTargetMachine.cpp
 delete mode 100644 lib/Target/RISCV/RISCVTargetMachine.h
 delete mode 100644 lib/Target/RISCV/RISCVTargetObjectFile.cpp
 delete mode 100644 lib/Target/RISCV/RISCVTargetObjectFile.h
 delete mode 100644 lib/Target/RISCV/TargetInfo/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/TargetInfo/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
 delete mode 100644 lib/Target/RISCV/Utils/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/Utils/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/Utils/RISCVBaseInfo.cpp
 delete mode 100644 lib/Target/RISCV/Utils/RISCVBaseInfo.h
 delete mode 100644 lib/Target/RISCV/Utils/RISCVMatInt.cpp
 delete mode 100644 lib/Target/RISCV/Utils/RISCVMatInt.h
 delete mode 100644 test/Assembler/empty-string.s
 delete mode 100644 test/CodeGen/RISCV/addc-adde-sube-subc.ll
 delete mode 100644 test/CodeGen/RISCV/align.ll
 delete mode 100644 test/CodeGen/RISCV/alloca.ll
 delete mode 100644 test/CodeGen/RISCV/alu16.ll
 delete mode 100644 test/CodeGen/RISCV/alu32.ll
 delete mode 100644 test/CodeGen/RISCV/alu64.ll
 delete mode 100644 test/CodeGen/RISCV/alu8.ll
 delete mode 100644 test/CodeGen/RISCV/analyze-branch.ll
 delete mode 100644 test/CodeGen/RISCV/arith-with-overflow.ll
 delete mode 100644 test/CodeGen/RISCV/atomic-cmpxchg.ll
 delete mode 100644 test/CodeGen/RISCV/atomic-fence.ll
 delete mode 100644 test/CodeGen/RISCV/atomic-load-store.ll
 delete mode 100644 test/CodeGen/RISCV/atomic-rmw.ll
 delete mode 100644 test/CodeGen/RISCV/bare-select.ll
 delete mode 100644 test/CodeGen/RISCV/blockaddress.ll
 delete mode 100644 test/CodeGen/RISCV/branch-relaxation.ll
 delete mode 100644 test/CodeGen/RISCV/branch.ll
 delete mode 100644 test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
 delete mode 100644 test/CodeGen/RISCV/byval.ll
 delete mode 100644 test/CodeGen/RISCV/calling-conv-rv32f-ilp32.ll
 delete mode 100644 test/CodeGen/RISCV/calling-conv-sext-zext.ll
 delete mode 100644 test/CodeGen/RISCV/calling-conv.ll
 delete mode 100644 test/CodeGen/RISCV/calls.ll
 delete mode 100644 test/CodeGen/RISCV/compress-inline-asm.ll
 delete mode 100644 test/CodeGen/RISCV/compress.ll
 delete mode 100644 test/CodeGen/RISCV/disable-tail-calls.ll
 delete mode 100644 test/CodeGen/RISCV/div.ll
 delete mode 100644 test/CodeGen/RISCV/double-arith.ll
 delete mode 100644 test/CodeGen/RISCV/double-br-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/double-calling-conv.ll
 delete mode 100644 test/CodeGen/RISCV/double-convert.ll
 delete mode 100644 test/CodeGen/RISCV/double-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/double-frem.ll
 delete mode 100644 test/CodeGen/RISCV/double-imm.ll
 delete mode 100644 test/CodeGen/RISCV/double-intrinsics.ll
 delete mode 100644 test/CodeGen/RISCV/double-mem.ll
 delete mode 100644 test/CodeGen/RISCV/double-previous-failure.ll
 delete mode 100644 test/CodeGen/RISCV/double-select-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/double-stack-spill-restore.ll
 delete mode 100644 test/CodeGen/RISCV/fixups-diff.ll
 delete mode 100644 test/CodeGen/RISCV/fixups-relax-diff.ll
 delete mode 100644 test/CodeGen/RISCV/float-arith.ll
 delete mode 100644 test/CodeGen/RISCV/float-br-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/float-convert.ll
 delete mode 100644 test/CodeGen/RISCV/float-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/float-frem.ll
 delete mode 100644 test/CodeGen/RISCV/float-imm.ll
 delete mode 100644 test/CodeGen/RISCV/float-intrinsics.ll
 delete mode 100644 test/CodeGen/RISCV/float-mem.ll
 delete mode 100644 test/CodeGen/RISCV/float-select-fcmp.ll
 delete mode 100644 test/CodeGen/RISCV/flt-rounds.ll
 delete mode 100644 test/CodeGen/RISCV/fp128.ll
 delete mode 100644 test/CodeGen/RISCV/frame.ll
 delete mode 100644 test/CodeGen/RISCV/frameaddr-returnaddr.ll
 delete mode 100644 test/CodeGen/RISCV/get-setcc-result-type.ll
 delete mode 100644 test/CodeGen/RISCV/hoist-global-addr-base.ll
 delete mode 100644 test/CodeGen/RISCV/i32-icmp.ll
 delete mode 100644 test/CodeGen/RISCV/imm-cse.ll
 delete mode 100644 test/CodeGen/RISCV/imm.ll
 delete mode 100644 test/CodeGen/RISCV/indirectbr.ll
 delete mode 100644 test/CodeGen/RISCV/init-array.ll
 delete mode 100644 test/CodeGen/RISCV/inline-asm.ll
 delete mode 100644 test/CodeGen/RISCV/interrupt-attr-args-error.ll
 delete mode 100644 test/CodeGen/RISCV/interrupt-attr-invalid.ll
 delete mode 100644 test/CodeGen/RISCV/interrupt-attr-nocall.ll
 delete mode 100644 test/CodeGen/RISCV/interrupt-attr-ret-error.ll
 delete mode 100644 test/CodeGen/RISCV/interrupt-attr.ll
 delete mode 100644 test/CodeGen/RISCV/jumptable.ll
 delete mode 100644 test/CodeGen/RISCV/large-stack.ll
 delete mode 100644 test/CodeGen/RISCV/lit.local.cfg
 delete mode 100644 test/CodeGen/RISCV/lsr-legaladdimm.ll
 delete mode 100644 test/CodeGen/RISCV/mem.ll
 delete mode 100644 test/CodeGen/RISCV/mem64.ll
 delete mode 100644 test/CodeGen/RISCV/mul.ll
 delete mode 100644 test/CodeGen/RISCV/musttail-call.ll
 delete mode 100644 test/CodeGen/RISCV/option-norelax.ll
 delete mode 100644 test/CodeGen/RISCV/option-norvc.ll
 delete mode 100644 test/CodeGen/RISCV/option-relax.ll
 delete mode 100644 test/CodeGen/RISCV/option-rvc.ll
 delete mode 100644 test/CodeGen/RISCV/prefetch.ll
 delete mode 100644 test/CodeGen/RISCV/rem.ll
 delete mode 100644 test/CodeGen/RISCV/remat.ll
 delete mode 100644 test/CodeGen/RISCV/rotl-rotr.ll
 delete mode 100644 test/CodeGen/RISCV/rv64i-exhaustive-w-insts.ll
 delete mode 100644 test/CodeGen/RISCV/rv64i-tricky-shifts.ll
 delete mode 100644 test/CodeGen/RISCV/select-cc.ll
 delete mode 100644 test/CodeGen/RISCV/sext-zext-trunc.ll
 delete mode 100644 test/CodeGen/RISCV/shift-masked-shamt.ll
 delete mode 100644 test/CodeGen/RISCV/shifts.ll
 delete mode 100644 test/CodeGen/RISCV/tail-calls.ll
 delete mode 100644 test/CodeGen/RISCV/umulo-128-legalisation-lowering.ll
 delete mode 100644 test/CodeGen/RISCV/vararg.ll
 delete mode 100644 test/CodeGen/RISCV/wide-mem.ll
 delete mode 100644 test/CodeGen/RISCV/zext-with-load-is-free.ll
 delete mode 100644 test/DebugInfo/RISCV/lit.local.cfg
 delete mode 100644 test/DebugInfo/RISCV/relax-debug-line.ll
 delete mode 100644 test/MC/Disassembler/RISCV/fuzzer-invalid.txt
 delete mode 100644 test/MC/Disassembler/RISCV/invalid-fp-rounding-mode.txt
 delete mode 100644 test/MC/Disassembler/RISCV/invalid-instruction.txt
 delete mode 100644 test/MC/Disassembler/RISCV/lit.local.cfg
 delete mode 100644 test/MC/Disassembler/RISCV/unknown-fence-field.txt
 delete mode 100644 test/MC/RISCV/cnop.s
 delete mode 100644 test/MC/RISCV/compress-cjal.s
 delete mode 100644 test/MC/RISCV/compress-rv32d.s
 delete mode 100644 test/MC/RISCV/compress-rv32f.s
 delete mode 100644 test/MC/RISCV/compress-rv32i.s
 delete mode 100644 test/MC/RISCV/compress-rv64i.s
 delete mode 100644 test/MC/RISCV/compressed-relocations.s
 delete mode 100644 test/MC/RISCV/csr-aliases.s
 delete mode 100644 test/MC/RISCV/data-directives-invalid.s
 delete mode 100644 test/MC/RISCV/data-directives-valid.s
 delete mode 100644 test/MC/RISCV/elf-flags.s
 delete mode 100644 test/MC/RISCV/elf-header.s
 delete mode 100644 test/MC/RISCV/fixups-compressed.s
 delete mode 100644 test/MC/RISCV/fixups-diagnostics.s
 delete mode 100644 test/MC/RISCV/fixups-expr.s
 delete mode 100644 test/MC/RISCV/fixups.s
 delete mode 100644 test/MC/RISCV/function-call-invalid.s
 delete mode 100644 test/MC/RISCV/function-call.s
 delete mode 100644 test/MC/RISCV/hilo-constaddr-expr.s
 delete mode 100644 test/MC/RISCV/hilo-constaddr.s
 delete mode 100644 test/MC/RISCV/linker-relaxation.s
 delete mode 100644 test/MC/RISCV/lit.local.cfg
 delete mode 100644 test/MC/RISCV/lla-invalid.s
 delete mode 100644 test/MC/RISCV/machine-csr-names-invalid.s
 delete mode 100644 test/MC/RISCV/machine-csr-names.s
 delete mode 100644 test/MC/RISCV/option-invalid.s
 delete mode 100644 test/MC/RISCV/option-pushpop.s
 delete mode 100644 test/MC/RISCV/option-relax.s
 delete mode 100644 test/MC/RISCV/option-rvc.s
 delete mode 100644 test/MC/RISCV/pcrel-lo12-invalid.s
 delete mode 100644 test/MC/RISCV/priv-invalid.s
 delete mode 100644 test/MC/RISCV/priv-valid.s
 delete mode 100644 test/MC/RISCV/relocations.s
 delete mode 100644 test/MC/RISCV/rv32-machine-csr-names.s
 delete mode 100644 test/MC/RISCV/rv32-relaxation.s
 delete mode 100644 test/MC/RISCV/rv32-user-csr-names.s
 delete mode 100644 test/MC/RISCV/rv32a-invalid.s
 delete mode 100644 test/MC/RISCV/rv32a-valid.s
 delete mode 100644 test/MC/RISCV/rv32c-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv32c-fuzzed-invalid.s
 delete mode 100644 test/MC/RISCV/rv32c-invalid.s
 delete mode 100644 test/MC/RISCV/rv32c-only-valid.s
 delete mode 100644 test/MC/RISCV/rv32c-valid.s
 delete mode 100644 test/MC/RISCV/rv32d-invalid.s
 delete mode 100644 test/MC/RISCV/rv32d-valid.s
 delete mode 100644 test/MC/RISCV/rv32dc-invalid.s
 delete mode 100644 test/MC/RISCV/rv32dc-valid.s
 delete mode 100644 test/MC/RISCV/rv32f-invalid.s
 delete mode 100644 test/MC/RISCV/rv32f-valid.s
 delete mode 100644 test/MC/RISCV/rv32fc-invalid.s
 delete mode 100644 test/MC/RISCV/rv32fc-valid.s
 delete mode 100644 test/MC/RISCV/rv32i-aliases-invalid.s
 delete mode 100644 test/MC/RISCV/rv32i-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv32i-invalid.s
 delete mode 100644 test/MC/RISCV/rv32i-valid.s
 delete mode 100644 test/MC/RISCV/rv32m-invalid.s
 delete mode 100644 test/MC/RISCV/rv32m-valid.s
 delete mode 100644 test/MC/RISCV/rv64-machine-csr-names.s
 delete mode 100644 test/MC/RISCV/rv64-relaxation.s
 delete mode 100644 test/MC/RISCV/rv64-user-csr-names.s
 delete mode 100644 test/MC/RISCV/rv64a-invalid.s
 delete mode 100644 test/MC/RISCV/rv64a-valid.s
 delete mode 100644 test/MC/RISCV/rv64c-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64c-invalid.s
 delete mode 100644 test/MC/RISCV/rv64c-valid.s
 delete mode 100644 test/MC/RISCV/rv64d-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64d-invalid.s
 delete mode 100644 test/MC/RISCV/rv64d-valid.s
 delete mode 100644 test/MC/RISCV/rv64dc-valid.s
 delete mode 100644 test/MC/RISCV/rv64f-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64f-invalid.s
 delete mode 100644 test/MC/RISCV/rv64f-valid.s
 delete mode 100644 test/MC/RISCV/rv64i-aliases-invalid.s
 delete mode 100644 test/MC/RISCV/rv64i-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64i-invalid.s
 delete mode 100644 test/MC/RISCV/rv64i-valid.s
 delete mode 100644 test/MC/RISCV/rv64m-valid.s
 delete mode 100644 test/MC/RISCV/rvd-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rvf-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rvf-user-csr-names.s
 delete mode 100644 test/MC/RISCV/rvi-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rvi-pseudos.s
 delete mode 100644 test/MC/RISCV/supervisor-csr-names.s
 delete mode 100644 test/MC/RISCV/tail-call-invalid.s
 delete mode 100644 test/MC/RISCV/tail-call.s
 delete mode 100644 test/MC/RISCV/user-csr-names-invalid.s
 delete mode 100644 test/MC/RISCV/user-csr-names.s
 delete mode 100644 test/Object/RISCV/elf-flags.yaml
 delete mode 100644 test/Object/RISCV/lit.local.cfg
 delete mode 100644 test/Transforms/SimplifyCFG/RISCV/lit.local.cfg
 delete mode 100644 test/Transforms/SimplifyCFG/RISCV/select-trunc-i64.ll
 delete mode 100644 utils/TableGen/RISCVCompressInstEmitter.cpp

diff --git a/cmake/config-ix.cmake b/cmake/config-ix.cmake
index 900c35ee4f0..48e28f976de 100644
--- a/cmake/config-ix.cmake
+++ b/cmake/config-ix.cmake
@@ -406,10 +406,6 @@ elseif (LLVM_NATIVE_ARCH MATCHES "wasm32")
   set(LLVM_NATIVE_ARCH WebAssembly)
 elseif (LLVM_NATIVE_ARCH MATCHES "wasm64")
   set(LLVM_NATIVE_ARCH WebAssembly)
-elseif (LLVM_NATIVE_ARCH MATCHES "riscv32")
-  set(LLVM_NATIVE_ARCH RISCV)
-elseif (LLVM_NATIVE_ARCH MATCHES "riscv64")
-  set(LLVM_NATIVE_ARCH RISCV)
 else ()
   message(FATAL_ERROR "Unknown architecture ${LLVM_NATIVE_ARCH}")
 endif ()
diff --git a/docs/CompilerWriterInfo.rst b/docs/CompilerWriterInfo.rst
index 838c36a4099..a1cbd40cdf2 100644
--- a/docs/CompilerWriterInfo.rst
+++ b/docs/CompilerWriterInfo.rst
@@ -74,10 +74,6 @@ AMDGPU
 
 Refer to :doc:`AMDGPUUsage` for additional documentation.
 
-RISC-V
-------
-* `RISC-V User-Level ISA Specification <https://riscv.org/specifications/>`_
-
 SPARC
 -----
 
diff --git a/include/llvm/ADT/Triple.h b/include/llvm/ADT/Triple.h
index 04b64e2fa60..e6c4a8866a3 100644
--- a/include/llvm/ADT/Triple.h
+++ b/include/llvm/ADT/Triple.h
@@ -66,8 +66,6 @@ public:
     ppc64le,        // PPC64LE: powerpc64le
     r600,           // R600: AMD GPUs HD2XXX - HD6XXX
     amdgcn,         // AMDGCN: AMD GCN GPUs
-    riscv32,        // RISC-V (32-bit): riscv32
-    riscv64,        // RISC-V (64-bit): riscv64
     sparc,          // Sparc: sparc
     sparcv9,        // Sparcv9: Sparcv9
     sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant
diff --git a/include/llvm/BinaryFormat/COFF.h b/include/llvm/BinaryFormat/COFF.h
index 7b973c03cc8..c89bf36b6b8 100644
--- a/include/llvm/BinaryFormat/COFF.h
+++ b/include/llvm/BinaryFormat/COFF.h
@@ -110,9 +110,6 @@ enum MachineTypes : unsigned {
   IMAGE_FILE_MACHINE_POWERPC = 0x1F0,
   IMAGE_FILE_MACHINE_POWERPCFP = 0x1F1,
   IMAGE_FILE_MACHINE_R4000 = 0x166,
-  IMAGE_FILE_MACHINE_RISCV32 = 0x5032,
-  IMAGE_FILE_MACHINE_RISCV64 = 0x5064,
-  IMAGE_FILE_MACHINE_RISCV128 = 0x5128,
   IMAGE_FILE_MACHINE_SH3 = 0x1A2,
   IMAGE_FILE_MACHINE_SH3DSP = 0x1A3,
   IMAGE_FILE_MACHINE_SH4 = 0x1A6,
diff --git a/include/llvm/BinaryFormat/ELF.h b/include/llvm/BinaryFormat/ELF.h
index ce35d127d43..c769209879a 100644
--- a/include/llvm/BinaryFormat/ELF.h
+++ b/include/llvm/BinaryFormat/ELF.h
@@ -309,7 +309,6 @@ enum {
   EM_NORC = 218,          // Nanoradio Optimized RISC
   EM_CSR_KALIMBA = 219,   // CSR Kalimba architecture family
   EM_AMDGPU = 224,        // AMD GPU architecture
-  EM_RISCV = 243,         // RISC-V
   EM_LANAI = 244,         // Lanai 32-bit processor
   EM_BPF = 247,           // Linux kernel bpf virtual machine
 };
@@ -617,22 +616,6 @@ enum {
 #include "ELFRelocs/Lanai.def"
 };
 
-// RISCV Specific e_flags
-enum : unsigned {
-  EF_RISCV_RVC = 0x0001,
-  EF_RISCV_FLOAT_ABI = 0x0006,
-  EF_RISCV_FLOAT_ABI_SOFT = 0x0000,
-  EF_RISCV_FLOAT_ABI_SINGLE = 0x0002,
-  EF_RISCV_FLOAT_ABI_DOUBLE = 0x0004,
-  EF_RISCV_FLOAT_ABI_QUAD = 0x0006,
-  EF_RISCV_RVE = 0x0008
-};
-
-// ELF Relocation types for RISC-V
-enum {
-#include "ELFRelocs/RISCV.def"
-};
-
 // ELF Relocation types for S390/zSeries
 enum {
 #include "ELFRelocs/SystemZ.def"
diff --git a/include/llvm/BinaryFormat/ELFRelocs/RISCV.def b/include/llvm/BinaryFormat/ELFRelocs/RISCV.def
deleted file mode 100644
index 5cc4c0ec302..00000000000
--- a/include/llvm/BinaryFormat/ELFRelocs/RISCV.def
+++ /dev/null
@@ -1,59 +0,0 @@
-
-#ifndef ELF_RELOC
-#error "ELF_RELOC must be defined"
-#endif
-
-ELF_RELOC(R_RISCV_NONE,               0)
-ELF_RELOC(R_RISCV_32,                 1)
-ELF_RELOC(R_RISCV_64,                 2)
-ELF_RELOC(R_RISCV_RELATIVE,           3)
-ELF_RELOC(R_RISCV_COPY,               4)
-ELF_RELOC(R_RISCV_JUMP_SLOT,          5)
-ELF_RELOC(R_RISCV_TLS_DTPMOD32,       6)
-ELF_RELOC(R_RISCV_TLS_DTPMOD64,       7)
-ELF_RELOC(R_RISCV_TLS_DTPREL32,       8)
-ELF_RELOC(R_RISCV_TLS_DTPREL64,       9)
-ELF_RELOC(R_RISCV_TLS_TPREL32,       10)
-ELF_RELOC(R_RISCV_TLS_TPREL64,       11)
-ELF_RELOC(R_RISCV_BRANCH,            16)
-ELF_RELOC(R_RISCV_JAL,               17)
-ELF_RELOC(R_RISCV_CALL,              18)
-ELF_RELOC(R_RISCV_CALL_PLT,          19)
-ELF_RELOC(R_RISCV_GOT_HI20,          20)
-ELF_RELOC(R_RISCV_TLS_GOT_HI20,      21)
-ELF_RELOC(R_RISCV_TLS_GD_HI20,       22)
-ELF_RELOC(R_RISCV_PCREL_HI20,        23)
-ELF_RELOC(R_RISCV_PCREL_LO12_I,      24)
-ELF_RELOC(R_RISCV_PCREL_LO12_S,      25)
-ELF_RELOC(R_RISCV_HI20,              26)
-ELF_RELOC(R_RISCV_LO12_I,            27)
-ELF_RELOC(R_RISCV_LO12_S,            28)
-ELF_RELOC(R_RISCV_TPREL_HI20,        29)
-ELF_RELOC(R_RISCV_TPREL_LO12_I,      30)
-ELF_RELOC(R_RISCV_TPREL_LO12_S,      31)
-ELF_RELOC(R_RISCV_TPREL_ADD,         32)
-ELF_RELOC(R_RISCV_ADD8,              33)
-ELF_RELOC(R_RISCV_ADD16,             34)
-ELF_RELOC(R_RISCV_ADD32,             35)
-ELF_RELOC(R_RISCV_ADD64,             36)
-ELF_RELOC(R_RISCV_SUB8,              37)
-ELF_RELOC(R_RISCV_SUB16,             38)
-ELF_RELOC(R_RISCV_SUB32,             39)
-ELF_RELOC(R_RISCV_SUB64,             40)
-ELF_RELOC(R_RISCV_GNU_VTINHERIT,     41)
-ELF_RELOC(R_RISCV_GNU_VTENTRY,       42)
-ELF_RELOC(R_RISCV_ALIGN,             43)
-ELF_RELOC(R_RISCV_RVC_BRANCH,        44)
-ELF_RELOC(R_RISCV_RVC_JUMP,          45)
-ELF_RELOC(R_RISCV_RVC_LUI,           46)
-ELF_RELOC(R_RISCV_GPREL_I,           47)
-ELF_RELOC(R_RISCV_GPREL_S,           48)
-ELF_RELOC(R_RISCV_TPREL_I,           49)
-ELF_RELOC(R_RISCV_TPREL_S,           50)
-ELF_RELOC(R_RISCV_RELAX,             51)
-ELF_RELOC(R_RISCV_SUB6,              52)
-ELF_RELOC(R_RISCV_SET6,              53)
-ELF_RELOC(R_RISCV_SET8,              54)
-ELF_RELOC(R_RISCV_SET16,             55)
-ELF_RELOC(R_RISCV_SET32,             56)
-ELF_RELOC(R_RISCV_32_PCREL,          57)
diff --git a/include/llvm/IR/Intrinsics.td b/include/llvm/IR/Intrinsics.td
index f503d3ebbdf..b83d728ffba 100644
--- a/include/llvm/IR/Intrinsics.td
+++ b/include/llvm/IR/Intrinsics.td
@@ -1148,4 +1148,3 @@ include "llvm/IR/IntrinsicsAMDGPU.td"
 include "llvm/IR/IntrinsicsBPF.td"
 include "llvm/IR/IntrinsicsSystemZ.td"
 include "llvm/IR/IntrinsicsWebAssembly.td"
-include "llvm/IR/IntrinsicsRISCV.td"
diff --git a/include/llvm/IR/IntrinsicsRISCV.td b/include/llvm/IR/IntrinsicsRISCV.td
deleted file mode 100644
index 0ac7348b56d..00000000000
--- a/include/llvm/IR/IntrinsicsRISCV.td
+++ /dev/null
@@ -1,44 +0,0 @@
-//===- IntrinsicsRISCV.td - Defines RISCV intrinsics -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines all of the RISCV-specific intrinsics.
-//
-//===----------------------------------------------------------------------===//
-
-let TargetPrefix = "riscv" in {
-
-//===----------------------------------------------------------------------===//
-// Atomics
-
-class MaskedAtomicRMW32Intrinsic
-    : Intrinsic<[llvm_i32_ty],
-                [llvm_anyptr_ty, llvm_i32_ty, llvm_i32_ty, llvm_i32_ty],
-                [IntrArgMemOnly, NoCapture<0>]>;
-
-class MaskedAtomicRMW32WithSextIntrinsic
-    : Intrinsic<[llvm_i32_ty],
-                [llvm_anyptr_ty, llvm_i32_ty, llvm_i32_ty, llvm_i32_ty,
-                 llvm_i32_ty],
-                [IntrArgMemOnly, NoCapture<0>]>;
-
-def int_riscv_masked_atomicrmw_xchg_i32 : MaskedAtomicRMW32Intrinsic;
-def int_riscv_masked_atomicrmw_add_i32  : MaskedAtomicRMW32Intrinsic;
-def int_riscv_masked_atomicrmw_sub_i32  : MaskedAtomicRMW32Intrinsic;
-def int_riscv_masked_atomicrmw_nand_i32 : MaskedAtomicRMW32Intrinsic;
-def int_riscv_masked_atomicrmw_max_i32  : MaskedAtomicRMW32WithSextIntrinsic;
-def int_riscv_masked_atomicrmw_min_i32  : MaskedAtomicRMW32WithSextIntrinsic;
-def int_riscv_masked_atomicrmw_umax_i32 : MaskedAtomicRMW32Intrinsic;
-def int_riscv_masked_atomicrmw_umin_i32 : MaskedAtomicRMW32Intrinsic;
-
-def int_riscv_masked_cmpxchg_i32
-    : Intrinsic<[llvm_i32_ty], [llvm_anyptr_ty, llvm_i32_ty, llvm_i32_ty,
-                                llvm_i32_ty, llvm_i32_ty],
-                [IntrArgMemOnly, NoCapture<0>]>;
-
-} // TargetPrefix = "riscv"
diff --git a/include/llvm/Object/ELFObjectFile.h b/include/llvm/Object/ELFObjectFile.h
index 0f620681cd9..07e41c5843b 100644
--- a/include/llvm/Object/ELFObjectFile.h
+++ b/include/llvm/Object/ELFObjectFile.h
@@ -81,8 +81,6 @@ public:
 
   SubtargetFeatures getARMFeatures() const;
 
-  SubtargetFeatures getRISCVFeatures() const;
-
   void setARMSubArch(Triple &TheTriple) const override;
 
   virtual uint16_t getEType() const = 0;
@@ -1042,8 +1040,6 @@ StringRef ELFObjectFile<ELFT>::getFileFormatName() const {
       return "ELF32-msp430";
     case ELF::EM_PPC:
       return "ELF32-ppc";
-    case ELF::EM_RISCV:
-      return "ELF32-riscv";
     case ELF::EM_SPARC:
     case ELF::EM_SPARC32PLUS:
       return "ELF32-sparc";
@@ -1062,8 +1058,6 @@ StringRef ELFObjectFile<ELFT>::getFileFormatName() const {
       return (IsLittleEndian ? "ELF64-aarch64-little" : "ELF64-aarch64-big");
     case ELF::EM_PPC64:
       return "ELF64-ppc64";
-    case ELF::EM_RISCV:
-      return "ELF64-riscv";
     case ELF::EM_S390:
       return "ELF64-s390";
     case ELF::EM_SPARCV9:
@@ -1116,15 +1110,6 @@ template <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {
     return Triple::ppc;
   case ELF::EM_PPC64:
     return IsLittleEndian ? Triple::ppc64le : Triple::ppc64;
-  case ELF::EM_RISCV:
-    switch (EF.getHeader()->e_ident[ELF::EI_CLASS]) {
-    case ELF::ELFCLASS32:
-      return Triple::riscv32;
-    case ELF::ELFCLASS64:
-      return Triple::riscv64;
-    default:
-      report_fatal_error("Invalid ELFCLASS!");
-    }
   case ELF::EM_S390:
     return Triple::systemz;
 
diff --git a/include/llvm/module.modulemap b/include/llvm/module.modulemap
index 3b6e2a8a0ba..5c3f4594f55 100644
--- a/include/llvm/module.modulemap
+++ b/include/llvm/module.modulemap
@@ -56,7 +56,6 @@ module LLVM_BinaryFormat {
     textual header "BinaryFormat/ELFRelocs/MSP430.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC64.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC.def"
-    textual header "BinaryFormat/ELFRelocs/RISCV.def"
     textual header "BinaryFormat/ELFRelocs/Sparc.def"
     textual header "BinaryFormat/ELFRelocs/SystemZ.def"
     textual header "BinaryFormat/ELFRelocs/x86_64.def"
diff --git a/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp b/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
index 096d2ab5d82..a8bb3f897ac 100644
--- a/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
+++ b/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
@@ -1063,11 +1063,6 @@ bool DAGTypeLegalizer::PromoteIntegerOperand(SDNode *N, unsigned OpNo) {
   case ISD::ADDCARRY:
   case ISD::SUBCARRY: Res = PromoteIntOp_ADDSUBCARRY(N, OpNo); break;
 
-  case ISD::FRAMEADDR:
-  case ISD::RETURNADDR: Res = PromoteIntOp_FRAMERETURNADDR(N); break;
-
-  case ISD::PREFETCH: Res = PromoteIntOp_PREFETCH(N, OpNo); break;
-
   case ISD::SMULFIX: Res = PromoteIntOp_SMULFIX(N); break;
   }
 
@@ -1434,24 +1429,6 @@ SDValue DAGTypeLegalizer::PromoteIntOp_SMULFIX(SDNode *N) {
       DAG.UpdateNodeOperands(N, N->getOperand(0), N->getOperand(1), Op2), 0);
 }
 
-SDValue DAGTypeLegalizer::PromoteIntOp_FRAMERETURNADDR(SDNode *N) {
-  // Promote the RETURNADDR/FRAMEADDR argument to a supported integer width.
-  SDValue Op = ZExtPromotedInteger(N->getOperand(0));
-  return SDValue(DAG.UpdateNodeOperands(N, Op), 0);
-}
-
-SDValue DAGTypeLegalizer::PromoteIntOp_PREFETCH(SDNode *N, unsigned OpNo) {
-  assert(OpNo > 1 && "Don't know how to promote this operand!");
-  // Promote the rw, locality, and cache type arguments to a supported integer
-  // width.
-  SDValue Op2 = ZExtPromotedInteger(N->getOperand(2));
-  SDValue Op3 = ZExtPromotedInteger(N->getOperand(3));
-  SDValue Op4 = ZExtPromotedInteger(N->getOperand(4));
-  return SDValue(DAG.UpdateNodeOperands(N, N->getOperand(0), N->getOperand(1),
-                                        Op2, Op3, Op4),
-                 0);
-}
-
 //===----------------------------------------------------------------------===//
 //  Integer Result Expansion
 //===----------------------------------------------------------------------===//
diff --git a/lib/CodeGen/SelectionDAG/LegalizeTypes.h b/lib/CodeGen/SelectionDAG/LegalizeTypes.h
index 032000f6cb7..85743460635 100644
--- a/lib/CodeGen/SelectionDAG/LegalizeTypes.h
+++ b/lib/CodeGen/SelectionDAG/LegalizeTypes.h
@@ -377,8 +377,6 @@ private:
   SDValue PromoteIntOp_MSCATTER(MaskedScatterSDNode *N, unsigned OpNo);
   SDValue PromoteIntOp_MGATHER(MaskedGatherSDNode *N, unsigned OpNo);
   SDValue PromoteIntOp_ADDSUBCARRY(SDNode *N, unsigned OpNo);
-  SDValue PromoteIntOp_FRAMERETURNADDR(SDNode *N);
-  SDValue PromoteIntOp_PREFETCH(SDNode *N, unsigned OpNo);
   SDValue PromoteIntOp_SMULFIX(SDNode *N);
 
   void PromoteSetCCOperands(SDValue &LHS,SDValue &RHS, ISD::CondCode Code);
diff --git a/lib/Object/ELF.cpp b/lib/Object/ELF.cpp
index cf8313f88f9..69f155d20a4 100644
--- a/lib/Object/ELF.cpp
+++ b/lib/Object/ELF.cpp
@@ -102,13 +102,6 @@ StringRef llvm::object::getELFRelocationTypeName(uint32_t Machine,
       break;
     }
     break;
-  case ELF::EM_RISCV:
-    switch (Type) {
-#include "llvm/BinaryFormat/ELFRelocs/RISCV.def"
-    default:
-      break;
-    }
-    break;
   case ELF::EM_S390:
     switch (Type) {
 #include "llvm/BinaryFormat/ELFRelocs/SystemZ.def"
@@ -180,8 +173,6 @@ uint32_t llvm::object::getELFRelativeRelocationType(uint32_t Machine) {
     break;
   case ELF::EM_PPC64:
     return ELF::R_PPC64_RELATIVE;
-  case ELF::EM_RISCV:
-    return ELF::R_RISCV_RELATIVE;
   case ELF::EM_S390:
     return ELF::R_390_RELATIVE;
   case ELF::EM_SPARC:
diff --git a/lib/Object/ELFObjectFile.cpp b/lib/Object/ELFObjectFile.cpp
index 9fb3a55ac7b..791914b62e8 100644
--- a/lib/Object/ELFObjectFile.cpp
+++ b/lib/Object/ELFObjectFile.cpp
@@ -240,25 +240,12 @@ SubtargetFeatures ELFObjectFileBase::getARMFeatures() const {
   return Features;
 }
 
-SubtargetFeatures ELFObjectFileBase::getRISCVFeatures() const {
-  SubtargetFeatures Features;
-  unsigned PlatformFlags = getPlatformFlags();
-
-  if (PlatformFlags & ELF::EF_RISCV_RVC) {
-    Features.AddFeature("c");
-  }
-
-  return Features;
-}
-
 SubtargetFeatures ELFObjectFileBase::getFeatures() const {
   switch (getEMachine()) {
   case ELF::EM_MIPS:
     return getMIPSFeatures();
   case ELF::EM_ARM:
     return getARMFeatures();
-  case ELF::EM_RISCV:
-    return getRISCVFeatures();
   default:
     return SubtargetFeatures();
   }
diff --git a/lib/ObjectYAML/ELFYAML.cpp b/lib/ObjectYAML/ELFYAML.cpp
index 215d6bdd091..c37a2e07232 100644
--- a/lib/ObjectYAML/ELFYAML.cpp
+++ b/lib/ObjectYAML/ELFYAML.cpp
@@ -214,7 +214,6 @@ void ScalarEnumerationTraits<ELFYAML::ELF_EM>::enumeration(
   ECase(EM_78KOR);
   ECase(EM_56800EX);
   ECase(EM_AMDGPU);
-  ECase(EM_RISCV);
   ECase(EM_LANAI);
   ECase(EM_BPF);
 #undef ECase
@@ -369,14 +368,6 @@ void ScalarBitSetTraits<ELFYAML::ELF_EF>::bitset(IO &IO,
     BCase(EF_AVR_ARCH_XMEGA6);
     BCase(EF_AVR_ARCH_XMEGA7);
     break;
-  case ELF::EM_RISCV:
-    BCase(EF_RISCV_RVC);
-    BCaseMask(EF_RISCV_FLOAT_ABI_SOFT, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_SINGLE, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_QUAD, EF_RISCV_FLOAT_ABI);
-    BCase(EF_RISCV_RVE);
-    break;
   case ELF::EM_AMDGPU:
     BCaseMask(EF_AMDGPU_MACH_NONE, EF_AMDGPU_MACH);
     BCaseMask(EF_AMDGPU_MACH_R600_R600, EF_AMDGPU_MACH);
@@ -642,9 +633,6 @@ void ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration(
   case ELF::EM_ARC:
 #include "llvm/BinaryFormat/ELFRelocs/ARC.def"
     break;
-  case ELF::EM_RISCV:
-#include "llvm/BinaryFormat/ELFRelocs/RISCV.def"
-    break;
   case ELF::EM_LANAI:
 #include "llvm/BinaryFormat/ELFRelocs/Lanai.def"
     break;
diff --git a/lib/Support/Triple.cpp b/lib/Support/Triple.cpp
index 4471fd05181..21eed315069 100644
--- a/lib/Support/Triple.cpp
+++ b/lib/Support/Triple.cpp
@@ -41,8 +41,6 @@ StringRef Triple::getArchTypeName(ArchType Kind) {
   case ppc:            return "powerpc";
   case r600:           return "r600";
   case amdgcn:         return "amdgcn";
-  case riscv32:        return "riscv32";
-  case riscv64:        return "riscv64";
   case sparc:          return "sparc";
   case sparcv9:        return "sparcv9";
   case sparcel:        return "sparcel";
@@ -143,9 +141,6 @@ StringRef Triple::getArchTypePrefix(ArchType Kind) {
   case shave:       return "shave";
   case wasm32:
   case wasm64:      return "wasm";
-
-  case riscv32:
-  case riscv64:     return "riscv";
   }
 }
 
@@ -280,8 +275,6 @@ Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {
     .Case("ppc64le", ppc64le)
     .Case("r600", r600)
     .Case("amdgcn", amdgcn)
-    .Case("riscv32", riscv32)
-    .Case("riscv64", riscv64)
     .Case("hexagon", hexagon)
     .Case("sparc", sparc)
     .Case("sparcel", sparcel)
@@ -411,8 +404,6 @@ static Triple::ArchType parseArch(StringRef ArchName) {
     .Case("nios2", Triple::nios2)
     .Case("r600", Triple::r600)
     .Case("amdgcn", Triple::amdgcn)
-    .Case("riscv32", Triple::riscv32)
-    .Case("riscv64", Triple::riscv64)
     .Case("hexagon", Triple::hexagon)
     .Cases("s390x", "systemz", Triple::systemz)
     .Case("sparc", Triple::sparc)
@@ -672,8 +663,6 @@ static Triple::ObjectFormatType getDefaultFormat(const Triple &T) {
   case Triple::r600:
   case Triple::renderscript32:
   case Triple::renderscript64:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::sparc:
   case Triple::sparcel:
@@ -1227,7 +1216,6 @@ static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
   case llvm::Triple::nvptx:
   case llvm::Triple::ppc:
   case llvm::Triple::r600:
-  case llvm::Triple::riscv32:
   case llvm::Triple::sparc:
   case llvm::Triple::sparcel:
   case llvm::Triple::tce:
@@ -1257,7 +1245,6 @@ static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
   case llvm::Triple::nvptx64:
   case llvm::Triple::ppc64:
   case llvm::Triple::ppc64le:
-  case llvm::Triple::riscv64:
   case llvm::Triple::sparcv9:
   case llvm::Triple::systemz:
   case llvm::Triple::x86_64:
@@ -1312,7 +1299,6 @@ Triple Triple::get32BitArchVariant() const {
   case Triple::nvptx:
   case Triple::ppc:
   case Triple::r600:
-  case Triple::riscv32:
   case Triple::sparc:
   case Triple::sparcel:
   case Triple::tce:
@@ -1336,7 +1322,6 @@ Triple Triple::get32BitArchVariant() const {
   case Triple::nvptx64:        T.setArch(Triple::nvptx);   break;
   case Triple::ppc64:          T.setArch(Triple::ppc);     break;
   case Triple::sparcv9:        T.setArch(Triple::sparc);   break;
-  case Triple::riscv64:        T.setArch(Triple::riscv32); break;
   case Triple::x86_64:         T.setArch(Triple::x86);     break;
   case Triple::amdil64:        T.setArch(Triple::amdil);   break;
   case Triple::hsail64:        T.setArch(Triple::hsail);   break;
@@ -1381,7 +1366,6 @@ Triple Triple::get64BitArchVariant() const {
   case Triple::nvptx64:
   case Triple::ppc64:
   case Triple::ppc64le:
-  case Triple::riscv64:
   case Triple::sparcv9:
   case Triple::systemz:
   case Triple::x86_64:
@@ -1398,7 +1382,6 @@ Triple Triple::get64BitArchVariant() const {
   case Triple::nvptx:           T.setArch(Triple::nvptx64);    break;
   case Triple::ppc:             T.setArch(Triple::ppc64);      break;
   case Triple::sparc:           T.setArch(Triple::sparcv9);    break;
-  case Triple::riscv32:         T.setArch(Triple::riscv64);    break;
   case Triple::x86:             T.setArch(Triple::x86_64);     break;
   case Triple::amdil:           T.setArch(Triple::amdil64);    break;
   case Triple::hsail:           T.setArch(Triple::hsail64);    break;
@@ -1433,8 +1416,6 @@ Triple Triple::getBigEndianArchVariant() const {
   case Triple::nvptx64:
   case Triple::nvptx:
   case Triple::r600:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::spir64:
   case Triple::spir:
@@ -1521,8 +1502,6 @@ bool Triple::isLittleEndian() const {
   case Triple::nvptx:
   case Triple::ppc64le:
   case Triple::r600:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::sparcel:
   case Triple::spir64:
diff --git a/lib/Target/LLVMBuild.txt b/lib/Target/LLVMBuild.txt
index 0d899a9c782..87d5ce11751 100644
--- a/lib/Target/LLVMBuild.txt
+++ b/lib/Target/LLVMBuild.txt
@@ -32,7 +32,6 @@ subdirectories =
  Mips
  Nios2
  PowerPC
- RISCV
  Sparc
  SystemZ
  WebAssembly
diff --git a/lib/Target/RISCV/AsmParser/CMakeLists.txt b/lib/Target/RISCV/AsmParser/CMakeLists.txt
deleted file mode 100644
index 10d0c89537c..00000000000
--- a/lib/Target/RISCV/AsmParser/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVAsmParser
-  RISCVAsmParser.cpp
-  )
diff --git a/lib/Target/RISCV/AsmParser/LLVMBuild.txt b/lib/Target/RISCV/AsmParser/LLVMBuild.txt
deleted file mode 100644
index 205d1248f92..00000000000
--- a/lib/Target/RISCV/AsmParser/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/AsmParser/LLVMBuild.txt ---------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVAsmParser
-parent = RISCV
-required_libraries = MC MCParser RISCVDesc RISCVInfo RISCVUtils Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp b/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
deleted file mode 100644
index 4e70ea402d8..00000000000
--- a/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
+++ /dev/null
@@ -1,1473 +0,0 @@
-//===-- RISCVAsmParser.cpp - Parse RISCV assembly to MCInst instructions --===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVAsmBackend.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "MCTargetDesc/RISCVTargetStreamer.h"
-#include "Utils/RISCVBaseInfo.h"
-#include "Utils/RISCVMatInt.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringSwitch.h"
-#include "llvm/MC/MCAssembler.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCInstBuilder.h"
-#include "llvm/MC/MCParser/MCAsmLexer.h"
-#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
-#include "llvm/MC/MCParser/MCTargetAsmParser.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/Casting.h"
-#include "llvm/Support/MathExtras.h"
-#include "llvm/Support/TargetRegistry.h"
-
-#include <limits>
-
-using namespace llvm;
-
-// Include the auto-generated portion of the compress emitter.
-#define GEN_COMPRESS_INSTR
-#include "RISCVGenCompressInstEmitter.inc"
-
-namespace {
-struct RISCVOperand;
-
-class RISCVAsmParser : public MCTargetAsmParser {
-  SmallVector<FeatureBitset, 4> FeatureBitStack;
-
-  SMLoc getLoc() const { return getParser().getTok().getLoc(); }
-  bool isRV64() const { return getSTI().hasFeature(RISCV::Feature64Bit); }
-
-  RISCVTargetStreamer &getTargetStreamer() {
-    MCTargetStreamer &TS = *getParser().getStreamer().getTargetStreamer();
-    return static_cast<RISCVTargetStreamer &>(TS);
-  }
-
-  unsigned validateTargetOperandClass(MCParsedAsmOperand &Op,
-                                      unsigned Kind) override;
-
-  bool generateImmOutOfRangeError(OperandVector &Operands, uint64_t ErrorInfo,
-                                  int64_t Lower, int64_t Upper, Twine Msg);
-
-  bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
-                               OperandVector &Operands, MCStreamer &Out,
-                               uint64_t &ErrorInfo,
-                               bool MatchingInlineAsm) override;
-
-  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
-
-  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
-                        SMLoc NameLoc, OperandVector &Operands) override;
-
-  bool ParseDirective(AsmToken DirectiveID) override;
-
-  // Helper to actually emit an instruction to the MCStreamer. Also, when
-  // possible, compression of the instruction is performed.
-  void emitToStreamer(MCStreamer &S, const MCInst &Inst);
-
-  // Helper to emit a combination of LUI, ADDI(W), and SLLI instructions that
-  // synthesize the desired immedate value into the destination register.
-  void emitLoadImm(unsigned DestReg, int64_t Value, MCStreamer &Out);
-
-  // Helper to emit pseudo instruction "lla" used in PC-rel addressing.
-  void emitLoadLocalAddress(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out);
-
-  /// Helper for processing MC instructions that have been successfully matched
-  /// by MatchAndEmitInstruction. Modifications to the emitted instructions,
-  /// like the expansion of pseudo instructions (e.g., "li"), can be performed
-  /// in this method.
-  bool processInstruction(MCInst &Inst, SMLoc IDLoc, MCStreamer &Out);
-
-// Auto-generated instruction matching functions
-#define GET_ASSEMBLER_HEADER
-#include "RISCVGenAsmMatcher.inc"
-
-  OperandMatchResultTy parseCSRSystemRegister(OperandVector &Operands);
-  OperandMatchResultTy parseImmediate(OperandVector &Operands);
-  OperandMatchResultTy parseRegister(OperandVector &Operands,
-                                     bool AllowParens = false);
-  OperandMatchResultTy parseMemOpBaseReg(OperandVector &Operands);
-  OperandMatchResultTy parseOperandWithModifier(OperandVector &Operands);
-  OperandMatchResultTy parseBareSymbol(OperandVector &Operands);
-  OperandMatchResultTy parseJALOffset(OperandVector &Operands);
-
-  bool parseOperand(OperandVector &Operands, StringRef Mnemonic);
-
-  bool parseDirectiveOption();
-
-  void setFeatureBits(uint64_t Feature, StringRef FeatureString) {
-    if (!(getSTI().getFeatureBits()[Feature])) {
-      MCSubtargetInfo &STI = copySTI();
-      setAvailableFeatures(
-          ComputeAvailableFeatures(STI.ToggleFeature(FeatureString)));
-    }
-  }
-
-  void clearFeatureBits(uint64_t Feature, StringRef FeatureString) {
-    if (getSTI().getFeatureBits()[Feature]) {
-      MCSubtargetInfo &STI = copySTI();
-      setAvailableFeatures(
-          ComputeAvailableFeatures(STI.ToggleFeature(FeatureString)));
-    }
-  }
-
-  void pushFeatureBits() {
-    FeatureBitStack.push_back(getSTI().getFeatureBits());
-  }
-
-  bool popFeatureBits() {
-    if (FeatureBitStack.empty())
-      return true;
-
-    FeatureBitset FeatureBits = FeatureBitStack.pop_back_val();
-    copySTI().setFeatureBits(FeatureBits);
-    setAvailableFeatures(ComputeAvailableFeatures(FeatureBits));
-
-    return false;
-  }
-public:
-  enum RISCVMatchResultTy {
-    Match_Dummy = FIRST_TARGET_MATCH_RESULT_TY,
-#define GET_OPERAND_DIAGNOSTIC_TYPES
-#include "RISCVGenAsmMatcher.inc"
-#undef GET_OPERAND_DIAGNOSTIC_TYPES
-  };
-
-  static bool classifySymbolRef(const MCExpr *Expr,
-                                RISCVMCExpr::VariantKind &Kind,
-                                int64_t &Addend);
-
-  RISCVAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
-                 const MCInstrInfo &MII, const MCTargetOptions &Options)
-      : MCTargetAsmParser(Options, STI, MII) {
-    Parser.addAliasForDirective(".half", ".2byte");
-    Parser.addAliasForDirective(".hword", ".2byte");
-    Parser.addAliasForDirective(".word", ".4byte");
-    Parser.addAliasForDirective(".dword", ".8byte");
-    setAvailableFeatures(ComputeAvailableFeatures(STI.getFeatureBits()));
-  }
-};
-
-/// RISCVOperand - Instances of this class represent a parsed machine
-/// instruction
-struct RISCVOperand : public MCParsedAsmOperand {
-
-  enum KindTy {
-    Token,
-    Register,
-    Immediate,
-    SystemRegister
-  } Kind;
-
-  bool IsRV64;
-
-  struct RegOp {
-    unsigned RegNum;
-  };
-
-  struct ImmOp {
-    const MCExpr *Val;
-  };
-
-  struct SysRegOp {
-    const char *Data;
-    unsigned Length;
-    unsigned Encoding;
-    // FIXME: Add the Encoding parsed fields as needed for checks,
-    // e.g.: read/write or user/supervisor/machine privileges.
-  };
-
-  SMLoc StartLoc, EndLoc;
-  union {
-    StringRef Tok;
-    RegOp Reg;
-    ImmOp Imm;
-    struct SysRegOp SysReg;
-  };
-
-  RISCVOperand(KindTy K) : MCParsedAsmOperand(), Kind(K) {}
-
-public:
-  RISCVOperand(const RISCVOperand &o) : MCParsedAsmOperand() {
-    Kind = o.Kind;
-    IsRV64 = o.IsRV64;
-    StartLoc = o.StartLoc;
-    EndLoc = o.EndLoc;
-    switch (Kind) {
-    case Register:
-      Reg = o.Reg;
-      break;
-    case Immediate:
-      Imm = o.Imm;
-      break;
-    case Token:
-      Tok = o.Tok;
-      break;
-    case SystemRegister:
-      SysReg = o.SysReg;
-      break;
-    }
-  }
-
-  bool isToken() const override { return Kind == Token; }
-  bool isReg() const override { return Kind == Register; }
-  bool isImm() const override { return Kind == Immediate; }
-  bool isMem() const override { return false; }
-  bool isSystemRegister() const { return Kind == SystemRegister; }
-
-  static bool evaluateConstantImm(const MCExpr *Expr, int64_t &Imm,
-                                  RISCVMCExpr::VariantKind &VK) {
-    if (auto *RE = dyn_cast<RISCVMCExpr>(Expr)) {
-      VK = RE->getKind();
-      return RE->evaluateAsConstant(Imm);
-    }
-
-    if (auto CE = dyn_cast<MCConstantExpr>(Expr)) {
-      VK = RISCVMCExpr::VK_RISCV_None;
-      Imm = CE->getValue();
-      return true;
-    }
-
-    return false;
-  }
-
-  // True if operand is a symbol with no modifiers, or a constant with no
-  // modifiers and isShiftedInt<N-1, 1>(Op).
-  template <int N> bool isBareSimmNLsb0() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    bool IsValid;
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isShiftedInt<N - 1, 1>(Imm);
-    return IsValid && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  // Predicate methods for AsmOperands defined in RISCVInstrInfo.td
-
-  bool isBareSymbol() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    // Must be of 'immediate' type but not a constant.
-    if (!isImm() || evaluateConstantImm(getImm(), Imm, VK))
-      return false;
-    return RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isCSRSystemRegister() const { return isSystemRegister(); }
-
-  /// Return true if the operand is a valid for the fence instruction e.g.
-  /// ('iorw').
-  bool isFenceArg() const {
-    if (!isImm())
-      return false;
-    const MCExpr *Val = getImm();
-    auto *SVal = dyn_cast<MCSymbolRefExpr>(Val);
-    if (!SVal || SVal->getKind() != MCSymbolRefExpr::VK_None)
-      return false;
-
-    StringRef Str = SVal->getSymbol().getName();
-    // Letters must be unique, taken from 'iorw', and in ascending order. This
-    // holds as long as each individual character is one of 'iorw' and is
-    // greater than the previous character.
-    char Prev = '\0';
-    for (char c : Str) {
-      if (c != 'i' && c != 'o' && c != 'r' && c != 'w')
-        return false;
-      if (c <= Prev)
-        return false;
-      Prev = c;
-    }
-    return true;
-  }
-
-  /// Return true if the operand is a valid floating point rounding mode.
-  bool isFRMArg() const {
-    if (!isImm())
-      return false;
-    const MCExpr *Val = getImm();
-    auto *SVal = dyn_cast<MCSymbolRefExpr>(Val);
-    if (!SVal || SVal->getKind() != MCSymbolRefExpr::VK_None)
-      return false;
-
-    StringRef Str = SVal->getSymbol().getName();
-
-    return RISCVFPRndMode::stringToRoundingMode(Str) != RISCVFPRndMode::Invalid;
-  }
-
-  bool isImmXLen() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    // Given only Imm, ensuring that the actually specified constant is either
-    // a signed or unsigned 64-bit number is unfortunately impossible.
-    bool IsInRange = isRV64() ? true : isInt<32>(Imm) || isUInt<32>(Imm);
-    return IsConstantImm && IsInRange && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImmLog2XLen() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    if (!evaluateConstantImm(getImm(), Imm, VK) ||
-        VK != RISCVMCExpr::VK_RISCV_None)
-      return false;
-    return (isRV64() && isUInt<6>(Imm)) || isUInt<5>(Imm);
-  }
-
-  bool isUImmLog2XLenNonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    if (!evaluateConstantImm(getImm(), Imm, VK) ||
-        VK != RISCVMCExpr::VK_RISCV_None)
-      return false;
-    if (Imm == 0)
-      return false;
-    return (isRV64() && isUInt<6>(Imm)) || isUInt<5>(Imm);
-  }
-
-  bool isUImm5() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isUInt<5>(Imm) && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm5NonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isUInt<5>(Imm) && (Imm != 0) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm6() const {
-    if (!isImm())
-      return false;
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isInt<6>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm6NonZero() const {
-    if (!isImm())
-      return false;
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isInt<6>(Imm) && (Imm != 0) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isCLUIImm() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && (Imm != 0) &&
-           (isUInt<5>(Imm) || (Imm >= 0xfffe0 && Imm <= 0xfffff)) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm7Lsb00() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isShiftedUInt<5, 2>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm8Lsb00() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isShiftedUInt<6, 2>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm8Lsb000() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isShiftedUInt<5, 3>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm9Lsb0() const { return isBareSimmNLsb0<9>(); }
-
-  bool isUImm9Lsb000() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isShiftedUInt<6, 3>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm10Lsb00NonZero() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && isShiftedUInt<8, 2>(Imm) && (Imm != 0) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm12() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isInt<12>(Imm);
-    return IsValid && ((IsConstantImm && VK == RISCVMCExpr::VK_RISCV_None) ||
-                       VK == RISCVMCExpr::VK_RISCV_LO ||
-                       VK == RISCVMCExpr::VK_RISCV_PCREL_LO);
-  }
-
-  bool isSImm12Lsb0() const { return isBareSimmNLsb0<12>(); }
-
-  bool isSImm13Lsb0() const { return isBareSimmNLsb0<13>(); }
-
-  bool isSImm10Lsb0000NonZero() const {
-    if (!isImm())
-      return false;
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    return IsConstantImm && (Imm != 0) && isShiftedInt<6, 4>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm20LUI() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    if (!IsConstantImm) {
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-      return IsValid && VK == RISCVMCExpr::VK_RISCV_HI;
-    } else {
-      return isUInt<20>(Imm) && (VK == RISCVMCExpr::VK_RISCV_None ||
-                                 VK == RISCVMCExpr::VK_RISCV_HI);
-    }
-  }
-
-  bool isUImm20AUIPC() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(getImm(), Imm, VK);
-    if (!IsConstantImm) {
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-      return IsValid && VK == RISCVMCExpr::VK_RISCV_PCREL_HI;
-    } else {
-      return isUInt<20>(Imm) && (VK == RISCVMCExpr::VK_RISCV_None ||
-                                 VK == RISCVMCExpr::VK_RISCV_PCREL_HI);
-    }
-  }
-
-  bool isSImm21Lsb0JAL() const { return isBareSimmNLsb0<21>(); }
-
-  /// getStartLoc - Gets location of the first token of this operand
-  SMLoc getStartLoc() const override { return StartLoc; }
-  /// getEndLoc - Gets location of the last token of this operand
-  SMLoc getEndLoc() const override { return EndLoc; }
-  /// True if this operand is for an RV64 instruction
-  bool isRV64() const { return IsRV64; }
-
-  unsigned getReg() const override {
-    assert(Kind == Register && "Invalid type access!");
-    return Reg.RegNum;
-  }
-
-  StringRef getSysReg() const {
-    assert(Kind == SystemRegister && "Invalid access!");
-    return StringRef(SysReg.Data, SysReg.Length);
-  }
-
-  const MCExpr *getImm() const {
-    assert(Kind == Immediate && "Invalid type access!");
-    return Imm.Val;
-  }
-
-  StringRef getToken() const {
-    assert(Kind == Token && "Invalid type access!");
-    return Tok;
-  }
-
-  void print(raw_ostream &OS) const override {
-    switch (Kind) {
-    case Immediate:
-      OS << *getImm();
-      break;
-    case Register:
-      OS << "<register x";
-      OS << getReg() << ">";
-      break;
-    case Token:
-      OS << "'" << getToken() << "'";
-      break;
-    case SystemRegister:
-      OS << "<sysreg: " << getSysReg() << '>';
-      break;
-    }
-  }
-
-  static std::unique_ptr<RISCVOperand> createToken(StringRef Str, SMLoc S,
-                                                   bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Token);
-    Op->Tok = Str;
-    Op->StartLoc = S;
-    Op->EndLoc = S;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  static std::unique_ptr<RISCVOperand> createReg(unsigned RegNo, SMLoc S,
-                                                 SMLoc E, bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Register);
-    Op->Reg.RegNum = RegNo;
-    Op->StartLoc = S;
-    Op->EndLoc = E;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  static std::unique_ptr<RISCVOperand> createImm(const MCExpr *Val, SMLoc S,
-                                                 SMLoc E, bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Immediate);
-    Op->Imm.Val = Val;
-    Op->StartLoc = S;
-    Op->EndLoc = E;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  static std::unique_ptr<RISCVOperand>
-  createSysReg(StringRef Str, SMLoc S, unsigned Encoding, bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(SystemRegister);
-    Op->SysReg.Data = Str.data();
-    Op->SysReg.Length = Str.size();
-    Op->SysReg.Encoding = Encoding;
-    Op->StartLoc = S;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
-    assert(Expr && "Expr shouldn't be null!");
-    int64_t Imm = 0;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstant = evaluateConstantImm(Expr, Imm, VK);
-
-    if (IsConstant)
-      Inst.addOperand(MCOperand::createImm(Imm));
-    else
-      Inst.addOperand(MCOperand::createExpr(Expr));
-  }
-
-  // Used by the TableGen Code
-  void addRegOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    Inst.addOperand(MCOperand::createReg(getReg()));
-  }
-
-  void addImmOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    addExpr(Inst, getImm());
-  }
-
-  void addFenceArgOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    // isFenceArg has validated the operand, meaning this cast is safe
-    auto SE = cast<MCSymbolRefExpr>(getImm());
-
-    unsigned Imm = 0;
-    for (char c : SE->getSymbol().getName()) {
-      switch (c) {
-      default:
-        llvm_unreachable("FenceArg must contain only [iorw]");
-      case 'i': Imm |= RISCVFenceField::I; break;
-      case 'o': Imm |= RISCVFenceField::O; break;
-      case 'r': Imm |= RISCVFenceField::R; break;
-      case 'w': Imm |= RISCVFenceField::W; break;
-      }
-    }
-    Inst.addOperand(MCOperand::createImm(Imm));
-  }
-
-  void addCSRSystemRegisterOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    Inst.addOperand(MCOperand::createImm(SysReg.Encoding));
-  }
-
-  // Returns the rounding mode represented by this RISCVOperand. Should only
-  // be called after checking isFRMArg.
-  RISCVFPRndMode::RoundingMode getRoundingMode() const {
-    // isFRMArg has validated the operand, meaning this cast is safe.
-    auto SE = cast<MCSymbolRefExpr>(getImm());
-    RISCVFPRndMode::RoundingMode FRM =
-        RISCVFPRndMode::stringToRoundingMode(SE->getSymbol().getName());
-    assert(FRM != RISCVFPRndMode::Invalid && "Invalid rounding mode");
-    return FRM;
-  }
-
-  void addFRMArgOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    Inst.addOperand(MCOperand::createImm(getRoundingMode()));
-  }
-};
-} // end anonymous namespace.
-
-#define GET_REGISTER_MATCHER
-#define GET_MATCHER_IMPLEMENTATION
-#include "RISCVGenAsmMatcher.inc"
-
-// Return the matching FPR64 register for the given FPR32.
-// FIXME: Ideally this function could be removed in favour of using
-// information from TableGen.
-unsigned convertFPR32ToFPR64(unsigned Reg) {
-  switch (Reg) {
-  default:
-    llvm_unreachable("Not a recognised FPR32 register");
-  case RISCV::F0_32: return RISCV::F0_64;
-  case RISCV::F1_32: return RISCV::F1_64;
-  case RISCV::F2_32: return RISCV::F2_64;
-  case RISCV::F3_32: return RISCV::F3_64;
-  case RISCV::F4_32: return RISCV::F4_64;
-  case RISCV::F5_32: return RISCV::F5_64;
-  case RISCV::F6_32: return RISCV::F6_64;
-  case RISCV::F7_32: return RISCV::F7_64;
-  case RISCV::F8_32: return RISCV::F8_64;
-  case RISCV::F9_32: return RISCV::F9_64;
-  case RISCV::F10_32: return RISCV::F10_64;
-  case RISCV::F11_32: return RISCV::F11_64;
-  case RISCV::F12_32: return RISCV::F12_64;
-  case RISCV::F13_32: return RISCV::F13_64;
-  case RISCV::F14_32: return RISCV::F14_64;
-  case RISCV::F15_32: return RISCV::F15_64;
-  case RISCV::F16_32: return RISCV::F16_64;
-  case RISCV::F17_32: return RISCV::F17_64;
-  case RISCV::F18_32: return RISCV::F18_64;
-  case RISCV::F19_32: return RISCV::F19_64;
-  case RISCV::F20_32: return RISCV::F20_64;
-  case RISCV::F21_32: return RISCV::F21_64;
-  case RISCV::F22_32: return RISCV::F22_64;
-  case RISCV::F23_32: return RISCV::F23_64;
-  case RISCV::F24_32: return RISCV::F24_64;
-  case RISCV::F25_32: return RISCV::F25_64;
-  case RISCV::F26_32: return RISCV::F26_64;
-  case RISCV::F27_32: return RISCV::F27_64;
-  case RISCV::F28_32: return RISCV::F28_64;
-  case RISCV::F29_32: return RISCV::F29_64;
-  case RISCV::F30_32: return RISCV::F30_64;
-  case RISCV::F31_32: return RISCV::F31_64;
-  }
-}
-
-unsigned RISCVAsmParser::validateTargetOperandClass(MCParsedAsmOperand &AsmOp,
-                                                    unsigned Kind) {
-  RISCVOperand &Op = static_cast<RISCVOperand &>(AsmOp);
-  if (!Op.isReg())
-    return Match_InvalidOperand;
-
-  unsigned Reg = Op.getReg();
-  bool IsRegFPR32 =
-      RISCVMCRegisterClasses[RISCV::FPR32RegClassID].contains(Reg);
-  bool IsRegFPR32C =
-      RISCVMCRegisterClasses[RISCV::FPR32CRegClassID].contains(Reg);
-
-  // As the parser couldn't differentiate an FPR32 from an FPR64, coerce the
-  // register from FPR32 to FPR64 or FPR32C to FPR64C if necessary.
-  if ((IsRegFPR32 && Kind == MCK_FPR64) ||
-      (IsRegFPR32C && Kind == MCK_FPR64C)) {
-    Op.Reg.RegNum = convertFPR32ToFPR64(Reg);
-    return Match_Success;
-  }
-  return Match_InvalidOperand;
-}
-
-bool RISCVAsmParser::generateImmOutOfRangeError(
-    OperandVector &Operands, uint64_t ErrorInfo, int64_t Lower, int64_t Upper,
-    Twine Msg = "immediate must be an integer in the range") {
-  SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-  return Error(ErrorLoc, Msg + " [" + Twine(Lower) + ", " + Twine(Upper) + "]");
-}
-
-bool RISCVAsmParser::MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
-                                             OperandVector &Operands,
-                                             MCStreamer &Out,
-                                             uint64_t &ErrorInfo,
-                                             bool MatchingInlineAsm) {
-  MCInst Inst;
-
-  auto Result =
-    MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm);
-  switch (Result) {
-  default:
-    break;
-  case Match_Success:
-    return processInstruction(Inst, IDLoc, Out);
-  case Match_MissingFeature:
-    return Error(IDLoc, "instruction use requires an option to be enabled");
-  case Match_MnemonicFail:
-    return Error(IDLoc, "unrecognized instruction mnemonic");
-  case Match_InvalidOperand: {
-    SMLoc ErrorLoc = IDLoc;
-    if (ErrorInfo != ~0U) {
-      if (ErrorInfo >= Operands.size())
-        return Error(ErrorLoc, "too few operands for instruction");
-
-      ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-      if (ErrorLoc == SMLoc())
-        ErrorLoc = IDLoc;
-    }
-    return Error(ErrorLoc, "invalid operand for instruction");
-  }
-  }
-
-  // Handle the case when the error message is of specific type
-  // other than the generic Match_InvalidOperand, and the
-  // corresponding operand is missing.
-  if (Result > FIRST_TARGET_MATCH_RESULT_TY) {
-    SMLoc ErrorLoc = IDLoc;
-    if (ErrorInfo != ~0U && ErrorInfo >= Operands.size())
-        return Error(ErrorLoc, "too few operands for instruction");
-  }
-
-  switch(Result) {
-  default:
-    break;
-  case Match_InvalidImmXLen:
-    if (isRV64()) {
-      SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-      return Error(ErrorLoc, "operand must be a constant 64-bit integer");
-    }
-    return generateImmOutOfRangeError(Operands, ErrorInfo,
-                                      std::numeric_limits<int32_t>::min(),
-                                      std::numeric_limits<uint32_t>::max());
-  case Match_InvalidUImmLog2XLen:
-    if (isRV64())
-      return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 6) - 1);
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 5) - 1);
-  case Match_InvalidUImmLog2XLenNonZero:
-    if (isRV64())
-      return generateImmOutOfRangeError(Operands, ErrorInfo, 1, (1 << 6) - 1);
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 1, (1 << 5) - 1);
-  case Match_InvalidUImm5:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 5) - 1);
-  case Match_InvalidSImm6:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, -(1 << 5),
-                                      (1 << 5) - 1);
-  case Match_InvalidSImm6NonZero:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 5), (1 << 5) - 1,
-        "immediate must be non-zero in the range");
-  case Match_InvalidCLUIImm:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 1, (1 << 5) - 1,
-        "immediate must be in [0xfffe0, 0xfffff] or");
-  case Match_InvalidUImm7Lsb00:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 7) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidUImm8Lsb00:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 8) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidUImm8Lsb000:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 8) - 8,
-        "immediate must be a multiple of 8 bytes in the range");
-  case Match_InvalidSImm9Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 8), (1 << 8) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidUImm9Lsb000:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 9) - 8,
-        "immediate must be a multiple of 8 bytes in the range");
-  case Match_InvalidUImm10Lsb00NonZero:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 4, (1 << 10) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidSImm10Lsb0000NonZero:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 9), (1 << 9) - 16,
-        "immediate must be a multiple of 16 bytes and non-zero in the range");
-  case Match_InvalidSImm12:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 11), (1 << 11) - 1,
-        "operand must be a symbol with %lo/%pcrel_lo modifier or an integer in "
-        "the range");
-  case Match_InvalidSImm12Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 11), (1 << 11) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidSImm13Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 12), (1 << 12) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidUImm20LUI:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 20) - 1,
-                                      "operand must be a symbol with %hi() "
-                                      "modifier or an integer in the range");
-  case Match_InvalidUImm20AUIPC:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 20) - 1,
-        "operand must be a symbol with %pcrel_hi() modifier or an integer in "
-        "the range");
-  case Match_InvalidSImm21Lsb0JAL:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 20), (1 << 20) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidCSRSystemRegister: {
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 12) - 1,
-                                      "operand must be a valid system register "
-                                      "name or an integer in the range");
-  }
-  case Match_InvalidFenceArg: {
-    SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-    return Error(
-        ErrorLoc,
-        "operand must be formed of letters selected in-order from 'iorw'");
-  }
-  case Match_InvalidFRMArg: {
-    SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-    return Error(
-        ErrorLoc,
-        "operand must be a valid floating point rounding mode mnemonic");
-  }
-  case Match_InvalidBareSymbol: {
-    SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-    return Error(ErrorLoc, "operand must be a bare symbol name");
-  }
-  }
-
-  llvm_unreachable("Unknown match type detected!");
-}
-
-bool RISCVAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
-                                   SMLoc &EndLoc) {
-  const AsmToken &Tok = getParser().getTok();
-  StartLoc = Tok.getLoc();
-  EndLoc = Tok.getEndLoc();
-  RegNo = 0;
-  StringRef Name = getLexer().getTok().getIdentifier();
-
-  if (!MatchRegisterName(Name) || !MatchRegisterAltName(Name)) {
-    getParser().Lex(); // Eat identifier token.
-    return false;
-  }
-
-  return Error(StartLoc, "invalid register name");
-}
-
-OperandMatchResultTy RISCVAsmParser::parseRegister(OperandVector &Operands,
-                                                   bool AllowParens) {
-  SMLoc FirstS = getLoc();
-  bool HadParens = false;
-  AsmToken Buf[2];
-
-  // If this a parenthesised register name is allowed, parse it atomically
-  if (AllowParens && getLexer().is(AsmToken::LParen)) {
-    size_t ReadCount = getLexer().peekTokens(Buf);
-    if (ReadCount == 2 && Buf[1].getKind() == AsmToken::RParen) {
-      HadParens = true;
-      getParser().Lex(); // Eat '('
-    }
-  }
-
-  switch (getLexer().getKind()) {
-  default:
-    return MatchOperand_NoMatch;
-  case AsmToken::Identifier:
-    StringRef Name = getLexer().getTok().getIdentifier();
-    unsigned RegNo = MatchRegisterName(Name);
-    if (RegNo == 0) {
-      RegNo = MatchRegisterAltName(Name);
-      if (RegNo == 0) {
-        if (HadParens)
-          getLexer().UnLex(Buf[0]);
-        return MatchOperand_NoMatch;
-      }
-    }
-    if (HadParens)
-      Operands.push_back(RISCVOperand::createToken("(", FirstS, isRV64()));
-    SMLoc S = getLoc();
-    SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-    getLexer().Lex();
-    Operands.push_back(RISCVOperand::createReg(RegNo, S, E, isRV64()));
-  }
-
-  if (HadParens) {
-    getParser().Lex(); // Eat ')'
-    Operands.push_back(RISCVOperand::createToken(")", getLoc(), isRV64()));
-  }
-
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy
-RISCVAsmParser::parseCSRSystemRegister(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  const MCExpr *Res;
-
-  switch (getLexer().getKind()) {
-  default:
-    return MatchOperand_NoMatch;
-  case AsmToken::LParen:
-  case AsmToken::Minus:
-  case AsmToken::Plus:
-  case AsmToken::Integer:
-  case AsmToken::String: {
-    if (getParser().parseExpression(Res))
-      return MatchOperand_ParseFail;
-
-    auto *CE = dyn_cast<MCConstantExpr>(Res);
-    if (CE) {
-      int64_t Imm = CE->getValue();
-      if (isUInt<12>(Imm)) {
-        auto SysReg = RISCVSysReg::lookupSysRegByEncoding(Imm);
-        // Accept an immediate representing a named or un-named Sys Reg
-        // if the range is valid, regardless of the required features.
-        Operands.push_back(RISCVOperand::createSysReg(
-            SysReg ? SysReg->Name : "", S, Imm, isRV64()));
-        return MatchOperand_Success;
-      }
-    }
-
-    Twine Msg = "immediate must be an integer in the range";
-    Error(S, Msg + " [" + Twine(0) + ", " + Twine((1 << 12) - 1) + "]");
-    return MatchOperand_ParseFail;
-  }
-  case AsmToken::Identifier: {
-    StringRef Identifier;
-    if (getParser().parseIdentifier(Identifier))
-      return MatchOperand_ParseFail;
-
-    auto SysReg = RISCVSysReg::lookupSysRegByName(Identifier);
-    // Accept a named Sys Reg if the required features are present.
-    if (SysReg) {
-      if (!SysReg->haveRequiredFeatures(getSTI().getFeatureBits())) {
-        Error(S, "system register use requires an option to be enabled");
-        return MatchOperand_ParseFail;
-      }
-      Operands.push_back(RISCVOperand::createSysReg(
-          Identifier, S, SysReg->Encoding, isRV64()));
-      return MatchOperand_Success;
-    }
-
-    Twine Msg = "operand must be a valid system register name "
-                "or an integer in the range";
-    Error(S, Msg + " [" + Twine(0) + ", " + Twine((1 << 12) - 1) + "]");
-    return MatchOperand_ParseFail;
-  }
-  case AsmToken::Percent: {
-    // Discard operand with modifier.
-    Twine Msg = "immediate must be an integer in the range";
-    Error(S, Msg + " [" + Twine(0) + ", " + Twine((1 << 12) - 1) + "]");
-    return MatchOperand_ParseFail;
-  }
-  }
-
-  return MatchOperand_NoMatch;
-}
-
-OperandMatchResultTy RISCVAsmParser::parseImmediate(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-  const MCExpr *Res;
-
-  switch (getLexer().getKind()) {
-  default:
-    return MatchOperand_NoMatch;
-  case AsmToken::LParen:
-  case AsmToken::Minus:
-  case AsmToken::Plus:
-  case AsmToken::Integer:
-  case AsmToken::String:
-    if (getParser().parseExpression(Res))
-      return MatchOperand_ParseFail;
-    break;
-  case AsmToken::Identifier: {
-    StringRef Identifier;
-    if (getParser().parseIdentifier(Identifier))
-      return MatchOperand_ParseFail;
-    MCSymbol *Sym = getContext().getOrCreateSymbol(Identifier);
-    Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
-    break;
-  }
-  case AsmToken::Percent:
-    return parseOperandWithModifier(Operands);
-  }
-
-  Operands.push_back(RISCVOperand::createImm(Res, S, E, isRV64()));
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy
-RISCVAsmParser::parseOperandWithModifier(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-
-  if (getLexer().getKind() != AsmToken::Percent) {
-    Error(getLoc(), "expected '%' for operand modifier");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat '%'
-
-  if (getLexer().getKind() != AsmToken::Identifier) {
-    Error(getLoc(), "expected valid identifier for operand modifier");
-    return MatchOperand_ParseFail;
-  }
-  StringRef Identifier = getParser().getTok().getIdentifier();
-  RISCVMCExpr::VariantKind VK = RISCVMCExpr::getVariantKindForName(Identifier);
-  if (VK == RISCVMCExpr::VK_RISCV_Invalid) {
-    Error(getLoc(), "unrecognized operand modifier");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat the identifier
-  if (getLexer().getKind() != AsmToken::LParen) {
-    Error(getLoc(), "expected '('");
-    return MatchOperand_ParseFail;
-  }
-  getParser().Lex(); // Eat '('
-
-  const MCExpr *SubExpr;
-  if (getParser().parseParenExpression(SubExpr, E)) {
-    return MatchOperand_ParseFail;
-  }
-
-  const MCExpr *ModExpr = RISCVMCExpr::create(SubExpr, VK, getContext());
-  Operands.push_back(RISCVOperand::createImm(ModExpr, S, E, isRV64()));
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy RISCVAsmParser::parseBareSymbol(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-  const MCExpr *Res;
-
-  if (getLexer().getKind() != AsmToken::Identifier)
-    return MatchOperand_NoMatch;
-
-  StringRef Identifier;
-  if (getParser().parseIdentifier(Identifier))
-    return MatchOperand_ParseFail;
-
-  MCSymbol *Sym = getContext().getOrCreateSymbol(Identifier);
-  Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
-  Operands.push_back(RISCVOperand::createImm(Res, S, E, isRV64()));
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy RISCVAsmParser::parseJALOffset(OperandVector &Operands) {
-  // Parsing jal operands is fiddly due to the `jal foo` and `jal ra, foo`
-  // both being acceptable forms. When parsing `jal ra, foo` this function
-  // will be called for the `ra` register operand in an attempt to match the
-  // single-operand alias. parseJALOffset must fail for this case. It would
-  // seem logical to try parse the operand using parseImmediate and return
-  // NoMatch if the next token is a comma (meaning we must be parsing a jal in
-  // the second form rather than the first). We can't do this as there's no
-  // way of rewinding the lexer state. Instead, return NoMatch if this operand
-  // is an identifier and is followed by a comma.
-  if (getLexer().is(AsmToken::Identifier) &&
-      getLexer().peekTok().is(AsmToken::Comma))
-    return MatchOperand_NoMatch;
-
-  return parseImmediate(Operands);
-}
-
-OperandMatchResultTy
-RISCVAsmParser::parseMemOpBaseReg(OperandVector &Operands) {
-  if (getLexer().isNot(AsmToken::LParen)) {
-    Error(getLoc(), "expected '('");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat '('
-  Operands.push_back(RISCVOperand::createToken("(", getLoc(), isRV64()));
-
-  if (parseRegister(Operands) != MatchOperand_Success) {
-    Error(getLoc(), "expected register");
-    return MatchOperand_ParseFail;
-  }
-
-  if (getLexer().isNot(AsmToken::RParen)) {
-    Error(getLoc(), "expected ')'");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat ')'
-  Operands.push_back(RISCVOperand::createToken(")", getLoc(), isRV64()));
-
-  return MatchOperand_Success;
-}
-
-/// Looks at a token type and creates the relevant operand from this
-/// information, adding to Operands. If operand was parsed, returns false, else
-/// true.
-bool RISCVAsmParser::parseOperand(OperandVector &Operands, StringRef Mnemonic) {
-  // Check if the current operand has a custom associated parser, if so, try to
-  // custom parse the operand, or fallback to the general approach.
-  OperandMatchResultTy Result =
-      MatchOperandParserImpl(Operands, Mnemonic, /*ParseForAllFeatures=*/true);
-  if (Result == MatchOperand_Success)
-    return false;
-  if (Result == MatchOperand_ParseFail)
-    return true;
-
-  // Attempt to parse token as a register.
-  if (parseRegister(Operands, true) == MatchOperand_Success)
-    return false;
-
-  // Attempt to parse token as an immediate
-  if (parseImmediate(Operands) == MatchOperand_Success) {
-    // Parse memory base register if present
-    if (getLexer().is(AsmToken::LParen))
-      return parseMemOpBaseReg(Operands) != MatchOperand_Success;
-    return false;
-  }
-
-  // Finally we have exhausted all options and must declare defeat.
-  Error(getLoc(), "unknown operand");
-  return true;
-}
-
-bool RISCVAsmParser::ParseInstruction(ParseInstructionInfo &Info,
-                                      StringRef Name, SMLoc NameLoc,
-                                      OperandVector &Operands) {
-  // Ensure that if the instruction occurs when relaxation is enabled,
-  // relocations are forced for the file. Ideally this would be done when there
-  // is enough information to reliably determine if the instruction itself may
-  // cause relaxations. Unfortunately instruction processing stage occurs in the
-  // same pass as relocation emission, so it's too late to set a 'sticky bit'
-  // for the entire file.
-  if (getSTI().getFeatureBits()[RISCV::FeatureRelax]) {
-    auto *Assembler = getTargetStreamer().getStreamer().getAssemblerPtr();
-    if (Assembler != nullptr) {
-      RISCVAsmBackend &MAB =
-          static_cast<RISCVAsmBackend &>(Assembler->getBackend());
-      MAB.setForceRelocs();
-    }
-  }
-
-  // First operand is token for instruction
-  Operands.push_back(RISCVOperand::createToken(Name, NameLoc, isRV64()));
-
-  // If there are no more operands, then finish
-  if (getLexer().is(AsmToken::EndOfStatement))
-    return false;
-
-  // Parse first operand
-  if (parseOperand(Operands, Name))
-    return true;
-
-  // Parse until end of statement, consuming commas between operands
-  unsigned OperandIdx = 1;
-  while (getLexer().is(AsmToken::Comma)) {
-    // Consume comma token
-    getLexer().Lex();
-
-    // Parse next operand
-    if (parseOperand(Operands, Name))
-      return true;
-
-    ++OperandIdx;
-  }
-
-  if (getLexer().isNot(AsmToken::EndOfStatement)) {
-    SMLoc Loc = getLexer().getLoc();
-    getParser().eatToEndOfStatement();
-    return Error(Loc, "unexpected token");
-  }
-
-  getParser().Lex(); // Consume the EndOfStatement.
-  return false;
-}
-
-bool RISCVAsmParser::classifySymbolRef(const MCExpr *Expr,
-                                       RISCVMCExpr::VariantKind &Kind,
-                                       int64_t &Addend) {
-  Kind = RISCVMCExpr::VK_RISCV_None;
-  Addend = 0;
-
-  if (const RISCVMCExpr *RE = dyn_cast<RISCVMCExpr>(Expr)) {
-    Kind = RE->getKind();
-    Expr = RE->getSubExpr();
-  }
-
-  // It's a simple symbol reference or constant with no addend.
-  if (isa<MCConstantExpr>(Expr) || isa<MCSymbolRefExpr>(Expr))
-    return true;
-
-  const MCBinaryExpr *BE = dyn_cast<MCBinaryExpr>(Expr);
-  if (!BE)
-    return false;
-
-  if (!isa<MCSymbolRefExpr>(BE->getLHS()))
-    return false;
-
-  if (BE->getOpcode() != MCBinaryExpr::Add &&
-      BE->getOpcode() != MCBinaryExpr::Sub)
-    return false;
-
-  // We are able to support the subtraction of two symbol references
-  if (BE->getOpcode() == MCBinaryExpr::Sub &&
-      isa<MCSymbolRefExpr>(BE->getRHS()))
-    return true;
-
-  // See if the addend is a constant, otherwise there's more going
-  // on here than we can deal with.
-  auto AddendExpr = dyn_cast<MCConstantExpr>(BE->getRHS());
-  if (!AddendExpr)
-    return false;
-
-  Addend = AddendExpr->getValue();
-  if (BE->getOpcode() == MCBinaryExpr::Sub)
-    Addend = -Addend;
-
-  // It's some symbol reference + a constant addend
-  return Kind != RISCVMCExpr::VK_RISCV_Invalid;
-}
-
-bool RISCVAsmParser::ParseDirective(AsmToken DirectiveID) {
-  // This returns false if this function recognizes the directive
-  // regardless of whether it is successfully handles or reports an
-  // error. Otherwise it returns true to give the generic parser a
-  // chance at recognizing it.
-  StringRef IDVal = DirectiveID.getString();
-
-  if (IDVal == ".option")
-    return parseDirectiveOption();
-
-  return true;
-}
-
-bool RISCVAsmParser::parseDirectiveOption() {
-  MCAsmParser &Parser = getParser();
-  // Get the option token.
-  AsmToken Tok = Parser.getTok();
-  // At the moment only identifiers are supported.
-  if (Tok.isNot(AsmToken::Identifier))
-    return Error(Parser.getTok().getLoc(),
-                 "unexpected token, expected identifier");
-
-  StringRef Option = Tok.getIdentifier();
-
-  if (Option == "push") {
-    getTargetStreamer().emitDirectiveOptionPush();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    pushFeatureBits();
-    return false;
-  }
-
-  if (Option == "pop") {
-    SMLoc StartLoc = Parser.getTok().getLoc();
-    getTargetStreamer().emitDirectiveOptionPop();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    if (popFeatureBits())
-      return Error(StartLoc, ".option pop with no .option push");
-
-    return false;
-  }
-
-  if (Option == "rvc") {
-    getTargetStreamer().emitDirectiveOptionRVC();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    setFeatureBits(RISCV::FeatureStdExtC, "c");
-    return false;
-  }
-
-  if (Option == "norvc") {
-    getTargetStreamer().emitDirectiveOptionNoRVC();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    clearFeatureBits(RISCV::FeatureStdExtC, "c");
-    return false;
-  }
-
-  if (Option == "relax") {
-    getTargetStreamer().emitDirectiveOptionRelax();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    setFeatureBits(RISCV::FeatureRelax, "relax");
-    return false;
-  }
-
-  if (Option == "norelax") {
-    getTargetStreamer().emitDirectiveOptionNoRelax();
-
-    Parser.Lex();
-    if (Parser.getTok().isNot(AsmToken::EndOfStatement))
-      return Error(Parser.getTok().getLoc(),
-                   "unexpected token, expected end of statement");
-
-    clearFeatureBits(RISCV::FeatureRelax, "relax");
-    return false;
-  }
-
-  // Unknown option.
-  Warning(Parser.getTok().getLoc(),
-          "unknown option, expected 'push', 'pop', 'rvc', 'norvc', 'relax' or "
-          "'norelax'");
-  Parser.eatToEndOfStatement();
-  return false;
-}
-
-void RISCVAsmParser::emitToStreamer(MCStreamer &S, const MCInst &Inst) {
-  MCInst CInst;
-  bool Res = compressInst(CInst, Inst, getSTI(), S.getContext());
-  CInst.setLoc(Inst.getLoc());
-  S.EmitInstruction((Res ? CInst : Inst), getSTI());
-}
-
-void RISCVAsmParser::emitLoadImm(unsigned DestReg, int64_t Value,
-                                 MCStreamer &Out) {
-  RISCVMatInt::InstSeq Seq;
-  RISCVMatInt::generateInstSeq(Value, isRV64(), Seq);
-
-  unsigned SrcReg = RISCV::X0;
-  for (RISCVMatInt::Inst &Inst : Seq) {
-    if (Inst.Opc == RISCV::LUI) {
-      emitToStreamer(
-          Out, MCInstBuilder(RISCV::LUI).addReg(DestReg).addImm(Inst.Imm));
-    } else {
-      emitToStreamer(
-          Out, MCInstBuilder(Inst.Opc).addReg(DestReg).addReg(SrcReg).addImm(
-                   Inst.Imm));
-    }
-
-    // Only the first instruction has X0 as its source.
-    SrcReg = DestReg;
-  }
-}
-
-void RISCVAsmParser::emitLoadLocalAddress(MCInst &Inst, SMLoc IDLoc,
-                                          MCStreamer &Out) {
-  // The local load address pseudo-instruction "lla" is used in PC-relative
-  // addressing of symbols:
-  //   lla rdest, symbol
-  // expands to
-  //   TmpLabel: AUIPC rdest, %pcrel_hi(symbol)
-  //             ADDI rdest, %pcrel_lo(TmpLabel)
-  MCContext &Ctx = getContext();
-
-  MCSymbol *TmpLabel = Ctx.createTempSymbol(
-      "pcrel_hi", /* AlwaysAddSuffix */ true, /* CanBeUnnamed */ false);
-  Out.EmitLabel(TmpLabel);
-
-  MCOperand DestReg = Inst.getOperand(0);
-  const RISCVMCExpr *Symbol = RISCVMCExpr::create(
-      Inst.getOperand(1).getExpr(), RISCVMCExpr::VK_RISCV_PCREL_HI, Ctx);
-
-  emitToStreamer(
-      Out, MCInstBuilder(RISCV::AUIPC).addOperand(DestReg).addExpr(Symbol));
-
-  const MCExpr *RefToLinkTmpLabel =
-      RISCVMCExpr::create(MCSymbolRefExpr::create(TmpLabel, Ctx),
-                          RISCVMCExpr::VK_RISCV_PCREL_LO, Ctx);
-
-  emitToStreamer(Out, MCInstBuilder(RISCV::ADDI)
-                          .addOperand(DestReg)
-                          .addOperand(DestReg)
-                          .addExpr(RefToLinkTmpLabel));
-}
-
-bool RISCVAsmParser::processInstruction(MCInst &Inst, SMLoc IDLoc,
-                                        MCStreamer &Out) {
-  Inst.setLoc(IDLoc);
-
-  if (Inst.getOpcode() == RISCV::PseudoLI) {
-    auto Reg = Inst.getOperand(0).getReg();
-    int64_t Imm = Inst.getOperand(1).getImm();
-    // On RV32 the immediate here can either be a signed or an unsigned
-    // 32-bit number. Sign extension has to be performed to ensure that Imm
-    // represents the expected signed 64-bit number.
-    if (!isRV64())
-      Imm = SignExtend64<32>(Imm);
-    emitLoadImm(Reg, Imm, Out);
-    return false;
-  } else if (Inst.getOpcode() == RISCV::PseudoLLA) {
-    emitLoadLocalAddress(Inst, IDLoc, Out);
-    return false;
-  }
-
-  emitToStreamer(Out, Inst);
-  return false;
-}
-
-extern "C" void LLVMInitializeRISCVAsmParser() {
-  RegisterMCAsmParser<RISCVAsmParser> X(getTheRISCV32Target());
-  RegisterMCAsmParser<RISCVAsmParser> Y(getTheRISCV64Target());
-}
diff --git a/lib/Target/RISCV/CMakeLists.txt b/lib/Target/RISCV/CMakeLists.txt
deleted file mode 100644
index 07c32cb315d..00000000000
--- a/lib/Target/RISCV/CMakeLists.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-set(LLVM_TARGET_DEFINITIONS RISCV.td)
-
-tablegen(LLVM RISCVGenAsmMatcher.inc -gen-asm-matcher)
-tablegen(LLVM RISCVGenAsmWriter.inc -gen-asm-writer)
-tablegen(LLVM RISCVGenCompressInstEmitter.inc -gen-compress-inst-emitter)
-tablegen(LLVM RISCVGenDAGISel.inc -gen-dag-isel)
-tablegen(LLVM RISCVGenDisassemblerTables.inc -gen-disassembler)
-tablegen(LLVM RISCVGenInstrInfo.inc -gen-instr-info)
-tablegen(LLVM RISCVGenMCCodeEmitter.inc -gen-emitter)
-tablegen(LLVM RISCVGenMCPseudoLowering.inc -gen-pseudo-lowering)
-tablegen(LLVM RISCVGenRegisterInfo.inc -gen-register-info)
-tablegen(LLVM RISCVGenSubtargetInfo.inc -gen-subtarget)
-tablegen(LLVM RISCVGenSystemOperands.inc -gen-searchable-tables)
-
-add_public_tablegen_target(RISCVCommonTableGen)
-
-add_llvm_target(RISCVCodeGen
-  RISCVAsmPrinter.cpp
-  RISCVExpandPseudoInsts.cpp
-  RISCVFrameLowering.cpp
-  RISCVInstrInfo.cpp
-  RISCVISelDAGToDAG.cpp
-  RISCVISelLowering.cpp
-  RISCVMCInstLower.cpp
-  RISCVMergeBaseOffset.cpp
-  RISCVRegisterInfo.cpp
-  RISCVSubtarget.cpp
-  RISCVTargetMachine.cpp
-  RISCVTargetObjectFile.cpp
-  )
-
-add_subdirectory(AsmParser)
-add_subdirectory(Disassembler)
-add_subdirectory(InstPrinter)
-add_subdirectory(MCTargetDesc)
-add_subdirectory(TargetInfo)
-add_subdirectory(Utils)
diff --git a/lib/Target/RISCV/Disassembler/CMakeLists.txt b/lib/Target/RISCV/Disassembler/CMakeLists.txt
deleted file mode 100644
index 39bd2b7669f..00000000000
--- a/lib/Target/RISCV/Disassembler/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVDisassembler
-  RISCVDisassembler.cpp
-  )
diff --git a/lib/Target/RISCV/Disassembler/LLVMBuild.txt b/lib/Target/RISCV/Disassembler/LLVMBuild.txt
deleted file mode 100644
index 340e89d4cf3..00000000000
--- a/lib/Target/RISCV/Disassembler/LLVMBuild.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-;===- ./lib/Target/RISCV/Disassembler/LLVMBuild.txt ------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVDisassembler
-parent = RISCV
-required_libraries = MCDisassembler RISCVInfo Support
-add_to_library_groups = RISCV
-
diff --git a/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp b/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
deleted file mode 100644
index eafa09d5631..00000000000
--- a/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
+++ /dev/null
@@ -1,324 +0,0 @@
-//===-- RISCVDisassembler.cpp - Disassembler for RISCV --------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCVDisassembler class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "Utils/RISCVBaseInfo.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCDisassembler/MCDisassembler.h"
-#include "llvm/MC/MCFixedLenDisassembler.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/Endian.h"
-#include "llvm/Support/TargetRegistry.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-disassembler"
-
-typedef MCDisassembler::DecodeStatus DecodeStatus;
-
-namespace {
-class RISCVDisassembler : public MCDisassembler {
-
-public:
-  RISCVDisassembler(const MCSubtargetInfo &STI, MCContext &Ctx)
-      : MCDisassembler(STI, Ctx) {}
-
-  DecodeStatus getInstruction(MCInst &Instr, uint64_t &Size,
-                              ArrayRef<uint8_t> Bytes, uint64_t Address,
-                              raw_ostream &VStream,
-                              raw_ostream &CStream) const override;
-};
-} // end anonymous namespace
-
-static MCDisassembler *createRISCVDisassembler(const Target &T,
-                                               const MCSubtargetInfo &STI,
-                                               MCContext &Ctx) {
-  return new RISCVDisassembler(STI, Ctx);
-}
-
-extern "C" void LLVMInitializeRISCVDisassembler() {
-  // Register the disassembler for each target.
-  TargetRegistry::RegisterMCDisassembler(getTheRISCV32Target(),
-                                         createRISCVDisassembler);
-  TargetRegistry::RegisterMCDisassembler(getTheRISCV64Target(),
-                                         createRISCVDisassembler);
-}
-
-static const unsigned GPRDecoderTable[] = {
-  RISCV::X0,  RISCV::X1,  RISCV::X2,  RISCV::X3,
-  RISCV::X4,  RISCV::X5,  RISCV::X6,  RISCV::X7,
-  RISCV::X8,  RISCV::X9,  RISCV::X10, RISCV::X11,
-  RISCV::X12, RISCV::X13, RISCV::X14, RISCV::X15,
-  RISCV::X16, RISCV::X17, RISCV::X18, RISCV::X19,
-  RISCV::X20, RISCV::X21, RISCV::X22, RISCV::X23,
-  RISCV::X24, RISCV::X25, RISCV::X26, RISCV::X27,
-  RISCV::X28, RISCV::X29, RISCV::X30, RISCV::X31
-};
-
-static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                           uint64_t Address,
-                                           const void *Decoder) {
-  if (RegNo > sizeof(GPRDecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = GPRDecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static const unsigned FPR32DecoderTable[] = {
-  RISCV::F0_32,  RISCV::F1_32,  RISCV::F2_32,  RISCV::F3_32,
-  RISCV::F4_32,  RISCV::F5_32,  RISCV::F6_32,  RISCV::F7_32,
-  RISCV::F8_32,  RISCV::F9_32,  RISCV::F10_32, RISCV::F11_32,
-  RISCV::F12_32, RISCV::F13_32, RISCV::F14_32, RISCV::F15_32,
-  RISCV::F16_32, RISCV::F17_32, RISCV::F18_32, RISCV::F19_32,
-  RISCV::F20_32, RISCV::F21_32, RISCV::F22_32, RISCV::F23_32,
-  RISCV::F24_32, RISCV::F25_32, RISCV::F26_32, RISCV::F27_32,
-  RISCV::F28_32, RISCV::F29_32, RISCV::F30_32, RISCV::F31_32
-};
-
-static DecodeStatus DecodeFPR32RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                             uint64_t Address,
-                                             const void *Decoder) {
-  if (RegNo > sizeof(FPR32DecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = FPR32DecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeFPR32CRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                              uint64_t Address,
-                                              const void *Decoder) {
-  if (RegNo > 8) {
-    return MCDisassembler::Fail;
-  }
-  unsigned Reg = FPR32DecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static const unsigned FPR64DecoderTable[] = {
-  RISCV::F0_64,  RISCV::F1_64,  RISCV::F2_64,  RISCV::F3_64,
-  RISCV::F4_64,  RISCV::F5_64,  RISCV::F6_64,  RISCV::F7_64,
-  RISCV::F8_64,  RISCV::F9_64,  RISCV::F10_64, RISCV::F11_64,
-  RISCV::F12_64, RISCV::F13_64, RISCV::F14_64, RISCV::F15_64,
-  RISCV::F16_64, RISCV::F17_64, RISCV::F18_64, RISCV::F19_64,
-  RISCV::F20_64, RISCV::F21_64, RISCV::F22_64, RISCV::F23_64,
-  RISCV::F24_64, RISCV::F25_64, RISCV::F26_64, RISCV::F27_64,
-  RISCV::F28_64, RISCV::F29_64, RISCV::F30_64, RISCV::F31_64
-};
-
-static DecodeStatus DecodeFPR64RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                             uint64_t Address,
-                                             const void *Decoder) {
-  if (RegNo > sizeof(FPR64DecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = FPR64DecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeFPR64CRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                              uint64_t Address,
-                                              const void *Decoder) {
-  if (RegNo > 8) {
-    return MCDisassembler::Fail;
-  }
-  unsigned Reg = FPR64DecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeGPRNoX0RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                               uint64_t Address,
-                                               const void *Decoder) {
-  if (RegNo == 0) {
-    return MCDisassembler::Fail;
-  }
-
-  return DecodeGPRRegisterClass(Inst, RegNo, Address, Decoder);
-}
-
-static DecodeStatus DecodeGPRNoX0X2RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                                 uint64_t Address,
-                                                 const void *Decoder) {
-  if (RegNo == 2) {
-    return MCDisassembler::Fail;
-  }
-
-  return DecodeGPRNoX0RegisterClass(Inst, RegNo, Address, Decoder);
-}
-
-static DecodeStatus DecodeGPRCRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                            uint64_t Address,
-                                            const void *Decoder) {
-  if (RegNo > 8)
-    return MCDisassembler::Fail;
-
-  unsigned Reg = GPRDecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-// Add implied SP operand for instructions *SP compressed instructions. The SP
-// operand isn't explicitly encoded in the instruction.
-static void addImplySP(MCInst &Inst, int64_t Address, const void *Decoder) {
-  if (Inst.getOpcode() == RISCV::C_LWSP || Inst.getOpcode() == RISCV::C_SWSP ||
-      Inst.getOpcode() == RISCV::C_LDSP || Inst.getOpcode() == RISCV::C_SDSP ||
-      Inst.getOpcode() == RISCV::C_FLWSP ||
-      Inst.getOpcode() == RISCV::C_FSWSP ||
-      Inst.getOpcode() == RISCV::C_FLDSP ||
-      Inst.getOpcode() == RISCV::C_FSDSP ||
-      Inst.getOpcode() == RISCV::C_ADDI4SPN) {
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-  }
-  if (Inst.getOpcode() == RISCV::C_ADDI16SP) {
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-  }
-}
-
-template <unsigned N>
-static DecodeStatus decodeUImmOperand(MCInst &Inst, uint64_t Imm,
-                                      int64_t Address, const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  addImplySP(Inst, Address, Decoder);
-  Inst.addOperand(MCOperand::createImm(Imm));
-  return MCDisassembler::Success;
-}
-
-template <unsigned N>
-static DecodeStatus decodeUImmNonZeroOperand(MCInst &Inst, uint64_t Imm,
-                                             int64_t Address,
-                                             const void *Decoder) {
-  if (Imm == 0)
-    return MCDisassembler::Fail;
-  return decodeUImmOperand<N>(Inst, Imm, Address, Decoder);
-}
-
-template <unsigned N>
-static DecodeStatus decodeSImmOperand(MCInst &Inst, uint64_t Imm,
-                                      int64_t Address, const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  addImplySP(Inst, Address, Decoder);
-  // Sign-extend the number in the bottom N bits of Imm
-  Inst.addOperand(MCOperand::createImm(SignExtend64<N>(Imm)));
-  return MCDisassembler::Success;
-}
-
-template <unsigned N>
-static DecodeStatus decodeSImmNonZeroOperand(MCInst &Inst, uint64_t Imm,
-                                             int64_t Address,
-                                             const void *Decoder) {
-  if (Imm == 0)
-    return MCDisassembler::Fail;
-  return decodeSImmOperand<N>(Inst, Imm, Address, Decoder);
-}
-
-template <unsigned N>
-static DecodeStatus decodeSImmOperandAndLsl1(MCInst &Inst, uint64_t Imm,
-                                             int64_t Address,
-                                             const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  // Sign-extend the number in the bottom N bits of Imm after accounting for
-  // the fact that the N bit immediate is stored in N-1 bits (the LSB is
-  // always zero)
-  Inst.addOperand(MCOperand::createImm(SignExtend64<N>(Imm << 1)));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus decodeCLUIImmOperand(MCInst &Inst, uint64_t Imm,
-                                         int64_t Address,
-                                         const void *Decoder) {
-  assert(isUInt<6>(Imm) && "Invalid immediate");
-  if (Imm > 31) {
-    Imm = (SignExtend64<6>(Imm) & 0xfffff);
-  }
-  Inst.addOperand(MCOperand::createImm(Imm));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus decodeFRMArg(MCInst &Inst, uint64_t Imm,
-                                 int64_t Address,
-                                 const void *Decoder) {
-  assert(isUInt<3>(Imm) && "Invalid immediate");
-  if (!llvm::RISCVFPRndMode::isValidRoundingMode(Imm))
-    return MCDisassembler::Fail;
-
-  Inst.addOperand(MCOperand::createImm(Imm));
-  return MCDisassembler::Success;
-}
-
-#include "RISCVGenDisassemblerTables.inc"
-
-DecodeStatus RISCVDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
-                                               ArrayRef<uint8_t> Bytes,
-                                               uint64_t Address,
-                                               raw_ostream &OS,
-                                               raw_ostream &CS) const {
-  // TODO: This will need modification when supporting instruction set
-  // extensions with instructions > 32-bits (up to 176 bits wide).
-  uint32_t Insn;
-  DecodeStatus Result;
-
-  // It's a 32 bit instruction if bit 0 and 1 are 1.
-  if ((Bytes[0] & 0x3) == 0x3) {
-    if (Bytes.size() < 4) {
-      Size = 0;
-      return MCDisassembler::Fail;
-    }
-    Insn = support::endian::read32le(Bytes.data());
-    LLVM_DEBUG(dbgs() << "Trying RISCV32 table :\n");
-    Result = decodeInstruction(DecoderTable32, MI, Insn, Address, this, STI);
-    Size = 4;
-  } else {
-    if (Bytes.size() < 2) {
-      Size = 0;
-      return MCDisassembler::Fail;
-    }
-    Insn = support::endian::read16le(Bytes.data());
-
-    if (!STI.getFeatureBits()[RISCV::Feature64Bit]) {
-      LLVM_DEBUG(
-          dbgs() << "Trying RISCV32Only_16 table (16-bit Instruction):\n");
-      // Calling the auto-generated decoder function.
-      Result = decodeInstruction(DecoderTableRISCV32Only_16, MI, Insn, Address,
-                                 this, STI);
-      if (Result != MCDisassembler::Fail) {
-        Size = 2;
-        return Result;
-      }
-    }
-
-    LLVM_DEBUG(dbgs() << "Trying RISCV_C table (16-bit Instruction):\n");
-    // Calling the auto-generated decoder function.
-    Result = decodeInstruction(DecoderTable16, MI, Insn, Address, this, STI);
-    Size = 2;
-  }
-
-  return Result;
-}
diff --git a/lib/Target/RISCV/InstPrinter/CMakeLists.txt b/lib/Target/RISCV/InstPrinter/CMakeLists.txt
deleted file mode 100644
index 7f91743fb93..00000000000
--- a/lib/Target/RISCV/InstPrinter/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVAsmPrinter
-  RISCVInstPrinter.cpp
-  )
diff --git a/lib/Target/RISCV/InstPrinter/LLVMBuild.txt b/lib/Target/RISCV/InstPrinter/LLVMBuild.txt
deleted file mode 100644
index 5a28372a302..00000000000
--- a/lib/Target/RISCV/InstPrinter/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/InstPrinter/LLVMBuild.txt -------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVAsmPrinter
-parent = RISCV
-required_libraries = MC RISCVUtils Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp b/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
deleted file mode 100644
index 979c8f4e2fa..00000000000
--- a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-//===-- RISCVInstPrinter.cpp - Convert RISCV MCInst to asm syntax ---------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class prints an RISCV MCInst to a .s file.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVInstPrinter.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "Utils/RISCVBaseInfo.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/FormattedStream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "asm-printer"
-
-// Include the auto-generated portion of the assembly writer.
-#define PRINT_ALIAS_INSTR
-#include "RISCVGenAsmWriter.inc"
-
-// Include the auto-generated portion of the compress emitter.
-#define GEN_UNCOMPRESS_INSTR
-#include "RISCVGenCompressInstEmitter.inc"
-
-static cl::opt<bool>
-    NoAliases("riscv-no-aliases",
-              cl::desc("Disable the emission of assembler pseudo instructions"),
-              cl::init(false), cl::Hidden);
-
-void RISCVInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
-                                 StringRef Annot, const MCSubtargetInfo &STI) {
-  bool Res = false;
-  const MCInst *NewMI = MI;
-  MCInst UncompressedMI;
-  if (!NoAliases)
-    Res = uncompressInst(UncompressedMI, *MI, MRI, STI);
-  if (Res)
-    NewMI = const_cast<MCInst *>(&UncompressedMI);
-  if (NoAliases || !printAliasInstr(NewMI, STI, O))
-    printInstruction(NewMI, STI, O);
-  printAnnotation(O, Annot);
-}
-
-void RISCVInstPrinter::printRegName(raw_ostream &O, unsigned RegNo) const {
-  O << getRegisterName(RegNo);
-}
-
-void RISCVInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
-                                    const MCSubtargetInfo &STI, raw_ostream &O,
-                                    const char *Modifier) {
-  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");
-  const MCOperand &MO = MI->getOperand(OpNo);
-
-  if (MO.isReg()) {
-    printRegName(O, MO.getReg());
-    return;
-  }
-
-  if (MO.isImm()) {
-    O << MO.getImm();
-    return;
-  }
-
-  assert(MO.isExpr() && "Unknown operand kind in printOperand");
-  MO.getExpr()->print(O, &MAI);
-}
-
-void RISCVInstPrinter::printCSRSystemRegister(const MCInst *MI, unsigned OpNo,
-                                              const MCSubtargetInfo &STI,
-                                              raw_ostream &O) {
-  unsigned Imm = MI->getOperand(OpNo).getImm();
-  auto SysReg = RISCVSysReg::lookupSysRegByEncoding(Imm);
-  if (SysReg && SysReg->haveRequiredFeatures(STI.getFeatureBits()))
-    O << SysReg->Name;
-  else
-    O << Imm;
-}
-
-void RISCVInstPrinter::printFenceArg(const MCInst *MI, unsigned OpNo,
-                                     const MCSubtargetInfo &STI,
-                                     raw_ostream &O) {
-  unsigned FenceArg = MI->getOperand(OpNo).getImm();
-  assert (((FenceArg >> 4) == 0) && "Invalid immediate in printFenceArg");
-
-  if ((FenceArg & RISCVFenceField::I) != 0)
-    O << 'i';
-  if ((FenceArg & RISCVFenceField::O) != 0)
-    O << 'o';
-  if ((FenceArg & RISCVFenceField::R) != 0)
-    O << 'r';
-  if ((FenceArg & RISCVFenceField::W) != 0)
-    O << 'w';
-  if (FenceArg == 0)
-    O << "unknown";
-}
-
-void RISCVInstPrinter::printFRMArg(const MCInst *MI, unsigned OpNo,
-                                   const MCSubtargetInfo &STI, raw_ostream &O) {
-  auto FRMArg =
-      static_cast<RISCVFPRndMode::RoundingMode>(MI->getOperand(OpNo).getImm());
-  O << RISCVFPRndMode::roundingModeToString(FRMArg);
-}
diff --git a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h b/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
deleted file mode 100644
index 0f9bed18499..00000000000
--- a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
+++ /dev/null
@@ -1,55 +0,0 @@
-//===-- RISCVInstPrinter.h - Convert RISCV MCInst to asm syntax ---*- C++ -*--//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class prints a RISCV MCInst to a .s file.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_INSTPRINTER_RISCVINSTPRINTER_H
-#define LLVM_LIB_TARGET_RISCV_INSTPRINTER_RISCVINSTPRINTER_H
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCInstPrinter.h"
-
-namespace llvm {
-class MCOperand;
-
-class RISCVInstPrinter : public MCInstPrinter {
-public:
-  RISCVInstPrinter(const MCAsmInfo &MAI, const MCInstrInfo &MII,
-                   const MCRegisterInfo &MRI)
-      : MCInstPrinter(MAI, MII, MRI) {}
-
-  void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot,
-                 const MCSubtargetInfo &STI) override;
-  void printRegName(raw_ostream &O, unsigned RegNo) const override;
-
-  void printOperand(const MCInst *MI, unsigned OpNo, const MCSubtargetInfo &STI,
-                    raw_ostream &O, const char *Modifier = nullptr);
-  void printCSRSystemRegister(const MCInst *MI, unsigned OpNo,
-                              const MCSubtargetInfo &STI, raw_ostream &O);
-  void printFenceArg(const MCInst *MI, unsigned OpNo,
-                     const MCSubtargetInfo &STI, raw_ostream &O);
-  void printFRMArg(const MCInst *MI, unsigned OpNo, const MCSubtargetInfo &STI,
-                   raw_ostream &O);
-
-  // Autogenerated by tblgen.
-  void printInstruction(const MCInst *MI, const MCSubtargetInfo &STI,
-                        raw_ostream &O);
-  bool printAliasInstr(const MCInst *MI, const MCSubtargetInfo &STI,
-                       raw_ostream &O);
-  void printCustomAliasOperand(const MCInst *MI, unsigned OpIdx,
-                               unsigned PrintMethodIdx,
-                               const MCSubtargetInfo &STI, raw_ostream &O);
-  static const char *getRegisterName(unsigned RegNo,
-                                     unsigned AltIdx = RISCV::ABIRegAltName);
-};
-} // namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/LLVMBuild.txt b/lib/Target/RISCV/LLVMBuild.txt
deleted file mode 100644
index 7af605e6954..00000000000
--- a/lib/Target/RISCV/LLVMBuild.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-;===- ./lib/Target/RISCV/LLVMBuild.txt -------------------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[common]
-subdirectories = AsmParser Disassembler InstPrinter TargetInfo MCTargetDesc Utils
-
-[component_0]
-type = TargetGroup
-name = RISCV
-parent = Target
-has_asmparser = 1
-has_asmprinter = 1
-has_disassembler = 1
-
-[component_1]
-type = Library
-name = RISCVCodeGen
-parent = RISCV
-required_libraries = AsmPrinter Core CodeGen MC RISCVAsmPrinter RISCVDesc
-  RISCVInfo RISCVUtils SelectionDAG Support Target
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt b/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
deleted file mode 100644
index d9f4188aa75..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-add_llvm_library(LLVMRISCVDesc
-  RISCVAsmBackend.cpp
-  RISCVELFObjectWriter.cpp
-  RISCVMCAsmInfo.cpp
-  RISCVMCCodeEmitter.cpp
-  RISCVMCExpr.cpp
-  RISCVMCTargetDesc.cpp
-  RISCVTargetStreamer.cpp
-  RISCVELFStreamer.cpp
-)
diff --git a/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt b/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
deleted file mode 100644
index 92daae30e3f..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt ------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVDesc
-parent = RISCV
-required_libraries = MC RISCVAsmPrinter RISCVInfo Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
deleted file mode 100644
index 7672fea5d95..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
+++ /dev/null
@@ -1,302 +0,0 @@
-//===-- RISCVAsmBackend.cpp - RISCV Assembler Backend ---------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVAsmBackend.h"
-#include "RISCVMCExpr.h"
-#include "llvm/ADT/APInt.h"
-#include "llvm/MC/MCAssembler.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCDirectives.h"
-#include "llvm/MC/MCELFObjectWriter.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCObjectWriter.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-// If linker relaxation is enabled, or the relax option had previously been
-// enabled, always emit relocations even if the fixup can be resolved. This is
-// necessary for correctness as offsets may change during relaxation.
-bool RISCVAsmBackend::shouldForceRelocation(const MCAssembler &Asm,
-                                            const MCFixup &Fixup,
-                                            const MCValue &Target) {
-  bool ShouldForce = false;
-
-  switch ((unsigned)Fixup.getKind()) {
-  default:
-    break;
-  case RISCV::fixup_riscv_pcrel_lo12_i:
-  case RISCV::fixup_riscv_pcrel_lo12_s:
-    // For pcrel_lo12, force a relocation if the target of the corresponding
-    // pcrel_hi20 is not in the same fragment.
-    const MCFixup *T = cast<RISCVMCExpr>(Fixup.getValue())->getPCRelHiFixup();
-    if (!T) {
-      Asm.getContext().reportError(Fixup.getLoc(),
-                                   "could not find corresponding %pcrel_hi");
-      return false;
-    }
-
-    switch ((unsigned)T->getKind()) {
-    default:
-      llvm_unreachable("Unexpected fixup kind for pcrel_lo12");
-      break;
-    case RISCV::fixup_riscv_pcrel_hi20:
-      ShouldForce = T->getValue()->findAssociatedFragment() !=
-                    Fixup.getValue()->findAssociatedFragment();
-      break;
-    }
-    break;
-  }
-
-  return ShouldForce || STI.getFeatureBits()[RISCV::FeatureRelax] ||
-         ForceRelocs;
-}
-
-bool RISCVAsmBackend::fixupNeedsRelaxationAdvanced(const MCFixup &Fixup,
-                                                   bool Resolved,
-                                                   uint64_t Value,
-                                                   const MCRelaxableFragment *DF,
-                                                   const MCAsmLayout &Layout,
-                                                   const bool WasForced) const {
-  // Return true if the symbol is actually unresolved.
-  // Resolved could be always false when shouldForceRelocation return true.
-  // We use !WasForced to indicate that the symbol is unresolved and not forced
-  // by shouldForceRelocation.
-  if (!Resolved && !WasForced)
-    return true;
-
-  int64_t Offset = int64_t(Value);
-  switch ((unsigned)Fixup.getKind()) {
-  default:
-    return false;
-  case RISCV::fixup_riscv_rvc_branch:
-    // For compressed branch instructions the immediate must be
-    // in the range [-256, 254].
-    return Offset > 254 || Offset < -256;
-  case RISCV::fixup_riscv_rvc_jump:
-    // For compressed jump instructions the immediate must be
-    // in the range [-2048, 2046].
-    return Offset > 2046 || Offset < -2048;
-  }
-}
-
-void RISCVAsmBackend::relaxInstruction(const MCInst &Inst,
-                                       const MCSubtargetInfo &STI,
-                                       MCInst &Res) const {
-  // TODO: replace this with call to auto generated uncompressinstr() function.
-  switch (Inst.getOpcode()) {
-  default:
-    llvm_unreachable("Opcode not expected!");
-  case RISCV::C_BEQZ:
-    // c.beqz $rs1, $imm -> beq $rs1, X0, $imm.
-    Res.setOpcode(RISCV::BEQ);
-    Res.addOperand(Inst.getOperand(0));
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(1));
-    break;
-  case RISCV::C_BNEZ:
-    // c.bnez $rs1, $imm -> bne $rs1, X0, $imm.
-    Res.setOpcode(RISCV::BNE);
-    Res.addOperand(Inst.getOperand(0));
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(1));
-    break;
-  case RISCV::C_J:
-    // c.j $imm -> jal X0, $imm.
-    Res.setOpcode(RISCV::JAL);
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(0));
-    break;
-  case RISCV::C_JAL:
-    // c.jal $imm -> jal X1, $imm.
-    Res.setOpcode(RISCV::JAL);
-    Res.addOperand(MCOperand::createReg(RISCV::X1));
-    Res.addOperand(Inst.getOperand(0));
-    break;
-  }
-}
-
-// Given a compressed control flow instruction this function returns
-// the expanded instruction.
-unsigned RISCVAsmBackend::getRelaxedOpcode(unsigned Op) const {
-  switch (Op) {
-  default:
-    return Op;
-  case RISCV::C_BEQZ:
-    return RISCV::BEQ;
-  case RISCV::C_BNEZ:
-    return RISCV::BNE;
-  case RISCV::C_J:
-  case RISCV::C_JAL: // fall through.
-    return RISCV::JAL;
-  }
-}
-
-bool RISCVAsmBackend::mayNeedRelaxation(const MCInst &Inst,
-                                        const MCSubtargetInfo &STI) const {
-  return getRelaxedOpcode(Inst.getOpcode()) != Inst.getOpcode();
-}
-
-bool RISCVAsmBackend::writeNopData(raw_ostream &OS, uint64_t Count) const {
-  bool HasStdExtC = STI.getFeatureBits()[RISCV::FeatureStdExtC];
-  unsigned MinNopLen = HasStdExtC ? 2 : 4;
-
-  if ((Count % MinNopLen) != 0)
-    return false;
-
-  // The canonical nop on RISC-V is addi x0, x0, 0.
-  uint64_t Nop32Count = Count / 4;
-  for (uint64_t i = Nop32Count; i != 0; --i)
-    OS.write("\x13\0\0\0", 4);
-
-  // The canonical nop on RVC is c.nop.
-  if (HasStdExtC) {
-    uint64_t Nop16Count = (Count - Nop32Count * 4) / 2;
-    for (uint64_t i = Nop16Count; i != 0; --i)
-      OS.write("\x01\0", 2);
-  }
-
-  return true;
-}
-
-static uint64_t adjustFixupValue(const MCFixup &Fixup, uint64_t Value,
-                                 MCContext &Ctx) {
-  unsigned Kind = Fixup.getKind();
-  switch (Kind) {
-  default:
-    llvm_unreachable("Unknown fixup kind!");
-  case FK_Data_1:
-  case FK_Data_2:
-  case FK_Data_4:
-  case FK_Data_8:
-    return Value;
-  case RISCV::fixup_riscv_lo12_i:
-  case RISCV::fixup_riscv_pcrel_lo12_i:
-    return Value & 0xfff;
-  case RISCV::fixup_riscv_lo12_s:
-  case RISCV::fixup_riscv_pcrel_lo12_s:
-    return (((Value >> 5) & 0x7f) << 25) | ((Value & 0x1f) << 7);
-  case RISCV::fixup_riscv_hi20:
-  case RISCV::fixup_riscv_pcrel_hi20:
-    // Add 1 if bit 11 is 1, to compensate for low 12 bits being negative.
-    return ((Value + 0x800) >> 12) & 0xfffff;
-  case RISCV::fixup_riscv_jal: {
-    if (!isInt<21>(Value))
-      Ctx.reportError(Fixup.getLoc(), "fixup value out of range");
-    if (Value & 0x1)
-      Ctx.reportError(Fixup.getLoc(), "fixup value must be 2-byte aligned");
-    // Need to produce imm[19|10:1|11|19:12] from the 21-bit Value.
-    unsigned Sbit = (Value >> 20) & 0x1;
-    unsigned Hi8 = (Value >> 12) & 0xff;
-    unsigned Mid1 = (Value >> 11) & 0x1;
-    unsigned Lo10 = (Value >> 1) & 0x3ff;
-    // Inst{31} = Sbit;
-    // Inst{30-21} = Lo10;
-    // Inst{20} = Mid1;
-    // Inst{19-12} = Hi8;
-    Value = (Sbit << 19) | (Lo10 << 9) | (Mid1 << 8) | Hi8;
-    return Value;
-  }
-  case RISCV::fixup_riscv_branch: {
-    if (!isInt<13>(Value))
-      Ctx.reportError(Fixup.getLoc(), "fixup value out of range");
-    if (Value & 0x1)
-      Ctx.reportError(Fixup.getLoc(), "fixup value must be 2-byte aligned");
-    // Need to extract imm[12], imm[10:5], imm[4:1], imm[11] from the 13-bit
-    // Value.
-    unsigned Sbit = (Value >> 12) & 0x1;
-    unsigned Hi1 = (Value >> 11) & 0x1;
-    unsigned Mid6 = (Value >> 5) & 0x3f;
-    unsigned Lo4 = (Value >> 1) & 0xf;
-    // Inst{31} = Sbit;
-    // Inst{30-25} = Mid6;
-    // Inst{11-8} = Lo4;
-    // Inst{7} = Hi1;
-    Value = (Sbit << 31) | (Mid6 << 25) | (Lo4 << 8) | (Hi1 << 7);
-    return Value;
-  }
-  case RISCV::fixup_riscv_call: {
-    // Jalr will add UpperImm with the sign-extended 12-bit LowerImm,
-    // we need to add 0x800ULL before extract upper bits to reflect the
-    // effect of the sign extension.
-    uint64_t UpperImm = (Value + 0x800ULL) & 0xfffff000ULL;
-    uint64_t LowerImm = Value & 0xfffULL;
-    return UpperImm | ((LowerImm << 20) << 32);
-  }
-  case RISCV::fixup_riscv_rvc_jump: {
-    // Need to produce offset[11|4|9:8|10|6|7|3:1|5] from the 11-bit Value.
-    unsigned Bit11  = (Value >> 11) & 0x1;
-    unsigned Bit4   = (Value >> 4) & 0x1;
-    unsigned Bit9_8 = (Value >> 8) & 0x3;
-    unsigned Bit10  = (Value >> 10) & 0x1;
-    unsigned Bit6   = (Value >> 6) & 0x1;
-    unsigned Bit7   = (Value >> 7) & 0x1;
-    unsigned Bit3_1 = (Value >> 1) & 0x7;
-    unsigned Bit5   = (Value >> 5) & 0x1;
-    Value = (Bit11 << 10) | (Bit4 << 9) | (Bit9_8 << 7) | (Bit10 << 6) |
-            (Bit6 << 5) | (Bit7 << 4) | (Bit3_1 << 1) | Bit5;
-    return Value;
-  }
-  case RISCV::fixup_riscv_rvc_branch: {
-    // Need to produce offset[8|4:3], [reg 3 bit], offset[7:6|2:1|5]
-    unsigned Bit8   = (Value >> 8) & 0x1;
-    unsigned Bit7_6 = (Value >> 6) & 0x3;
-    unsigned Bit5   = (Value >> 5) & 0x1;
-    unsigned Bit4_3 = (Value >> 3) & 0x3;
-    unsigned Bit2_1 = (Value >> 1) & 0x3;
-    Value = (Bit8 << 12) | (Bit4_3 << 10) | (Bit7_6 << 5) | (Bit2_1 << 3) |
-            (Bit5 << 2);
-    return Value;
-  }
-
-  }
-}
-
-void RISCVAsmBackend::applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
-                                 const MCValue &Target,
-                                 MutableArrayRef<char> Data, uint64_t Value,
-                                 bool IsResolved,
-                                 const MCSubtargetInfo *STI) const {
-  MCContext &Ctx = Asm.getContext();
-  MCFixupKindInfo Info = getFixupKindInfo(Fixup.getKind());
-  if (!Value)
-    return; // Doesn't change encoding.
-  // Apply any target-specific value adjustments.
-  Value = adjustFixupValue(Fixup, Value, Ctx);
-
-  // Shift the value into position.
-  Value <<= Info.TargetOffset;
-
-  unsigned Offset = Fixup.getOffset();
-  unsigned NumBytes = alignTo(Info.TargetSize + Info.TargetOffset, 8) / 8;
-
-  assert(Offset + NumBytes <= Data.size() && "Invalid fixup offset!");
-
-  // For each byte of the fragment that the fixup touches, mask in the
-  // bits from the fixup value.
-  for (unsigned i = 0; i != NumBytes; ++i) {
-    Data[Offset + i] |= uint8_t((Value >> (i * 8)) & 0xff);
-  }
-}
-
-std::unique_ptr<MCObjectTargetWriter>
-RISCVAsmBackend::createObjectTargetWriter() const {
-  return createRISCVELFObjectWriter(OSABI, Is64Bit);
-}
-
-MCAsmBackend *llvm::createRISCVAsmBackend(const Target &T,
-                                          const MCSubtargetInfo &STI,
-                                          const MCRegisterInfo &MRI,
-                                          const MCTargetOptions &Options) {
-  const Triple &TT = STI.getTargetTriple();
-  uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TT.getOS());
-  return new RISCVAsmBackend(STI, OSABI, TT.isArch64Bit());
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.h b/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.h
deleted file mode 100644
index b98e45f4053..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.h
+++ /dev/null
@@ -1,113 +0,0 @@
-//===-- RISCVAsmBackend.h - RISCV Assembler Backend -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVASMBACKEND_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVASMBACKEND_H
-
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCAsmBackend.h"
-#include "llvm/MC/MCFixupKindInfo.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-
-namespace llvm {
-class MCAssembler;
-class MCObjectTargetWriter;
-class raw_ostream;
-
-class RISCVAsmBackend : public MCAsmBackend {
-  const MCSubtargetInfo &STI;
-  uint8_t OSABI;
-  bool Is64Bit;
-  bool ForceRelocs = false;
-
-public:
-  RISCVAsmBackend(const MCSubtargetInfo &STI, uint8_t OSABI, bool Is64Bit)
-      : MCAsmBackend(support::little), STI(STI), OSABI(OSABI),
-        Is64Bit(Is64Bit) {}
-  ~RISCVAsmBackend() override {}
-
-  void setForceRelocs() { ForceRelocs = true; }
-
-  // Generate diff expression relocations if the relax feature is enabled or had
-  // previously been enabled, otherwise it is safe for the assembler to
-  // calculate these internally.
-  bool requiresDiffExpressionRelocations() const override {
-    return STI.getFeatureBits()[RISCV::FeatureRelax] || ForceRelocs;
-  }
-  void applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
-                  const MCValue &Target, MutableArrayRef<char> Data,
-                  uint64_t Value, bool IsResolved,
-                  const MCSubtargetInfo *STI) const override;
-
-  std::unique_ptr<MCObjectTargetWriter>
-  createObjectTargetWriter() const override;
-
-  bool shouldForceRelocation(const MCAssembler &Asm, const MCFixup &Fixup,
-                             const MCValue &Target) override;
-
-  bool fixupNeedsRelaxation(const MCFixup &Fixup, uint64_t Value,
-                            const MCRelaxableFragment *DF,
-                            const MCAsmLayout &Layout) const override {
-    llvm_unreachable("Handled by fixupNeedsRelaxationAdvanced");
-  }
-
-  bool fixupNeedsRelaxationAdvanced(const MCFixup &Fixup, bool Resolved,
-                                    uint64_t Value,
-                                    const MCRelaxableFragment *DF,
-                                    const MCAsmLayout &Layout,
-                                    const bool WasForced) const override;
-
-  unsigned getNumFixupKinds() const override {
-    return RISCV::NumTargetFixupKinds;
-  }
-
-  const MCFixupKindInfo &getFixupKindInfo(MCFixupKind Kind) const override {
-    const static MCFixupKindInfo Infos[] = {
-      // This table *must* be in the order that the fixup_* kinds are defined in
-      // RISCVFixupKinds.h.
-      //
-      // name                      offset bits  flags
-      { "fixup_riscv_hi20",         12,     20,  0 },
-      { "fixup_riscv_lo12_i",       20,     12,  0 },
-      { "fixup_riscv_lo12_s",        0,     32,  0 },
-      { "fixup_riscv_pcrel_hi20",   12,     20,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_pcrel_lo12_i", 20,     12,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_pcrel_lo12_s",  0,     32,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_jal",          12,     20,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_branch",        0,     32,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_rvc_jump",      2,     11,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_rvc_branch",    0,     16,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_call",          0,     64,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_relax",         0,      0,  0 }
-    };
-    static_assert((array_lengthof(Infos)) == RISCV::NumTargetFixupKinds,
-                  "Not all fixup kinds added to Infos array");
-
-    if (Kind < FirstTargetFixupKind)
-      return MCAsmBackend::getFixupKindInfo(Kind);
-
-    assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
-           "Invalid kind!");
-    return Infos[Kind - FirstTargetFixupKind];
-  }
-
-  bool mayNeedRelaxation(const MCInst &Inst,
-                         const MCSubtargetInfo &STI) const override;
-  unsigned getRelaxedOpcode(unsigned Op) const;
-
-  void relaxInstruction(const MCInst &Inst, const MCSubtargetInfo &STI,
-                        MCInst &Res) const override;
-
-
-  bool writeNopData(raw_ostream &OS, uint64_t Count) const override;
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
deleted file mode 100644
index 9b88614aa69..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//===-- RISCVELFObjectWriter.cpp - RISCV ELF Writer -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCELFObjectWriter.h"
-#include "llvm/MC/MCFixup.h"
-#include "llvm/MC/MCObjectWriter.h"
-#include "llvm/Support/ErrorHandling.h"
-
-using namespace llvm;
-
-namespace {
-class RISCVELFObjectWriter : public MCELFObjectTargetWriter {
-public:
-  RISCVELFObjectWriter(uint8_t OSABI, bool Is64Bit);
-
-  ~RISCVELFObjectWriter() override;
-
-  // Return true if the given relocation must be with a symbol rather than
-  // section plus offset.
-  bool needsRelocateWithSymbol(const MCSymbol &Sym,
-                               unsigned Type) const override {
-    // TODO: this is very conservative, update once RISC-V psABI requirements
-    //       are clarified.
-    return true;
-  }
-
-protected:
-  unsigned getRelocType(MCContext &Ctx, const MCValue &Target,
-                        const MCFixup &Fixup, bool IsPCRel) const override;
-};
-}
-
-RISCVELFObjectWriter::RISCVELFObjectWriter(uint8_t OSABI, bool Is64Bit)
-    : MCELFObjectTargetWriter(Is64Bit, OSABI, ELF::EM_RISCV,
-                              /*HasRelocationAddend*/ true) {}
-
-RISCVELFObjectWriter::~RISCVELFObjectWriter() {}
-
-unsigned RISCVELFObjectWriter::getRelocType(MCContext &Ctx,
-                                            const MCValue &Target,
-                                            const MCFixup &Fixup,
-                                            bool IsPCRel) const {
-  // Determine the type of the relocation
-  switch ((unsigned)Fixup.getKind()) {
-  default:
-    llvm_unreachable("invalid fixup kind!");
-  case FK_Data_4:
-    return ELF::R_RISCV_32;
-  case FK_Data_8:
-    return ELF::R_RISCV_64;
-  case FK_Data_Add_1:
-    return ELF::R_RISCV_ADD8;
-  case FK_Data_Add_2:
-    return ELF::R_RISCV_ADD16;
-  case FK_Data_Add_4:
-    return ELF::R_RISCV_ADD32;
-  case FK_Data_Add_8:
-    return ELF::R_RISCV_ADD64;
-  case FK_Data_Sub_1:
-    return ELF::R_RISCV_SUB8;
-  case FK_Data_Sub_2:
-    return ELF::R_RISCV_SUB16;
-  case FK_Data_Sub_4:
-    return ELF::R_RISCV_SUB32;
-  case FK_Data_Sub_8:
-    return ELF::R_RISCV_SUB64;
-  case RISCV::fixup_riscv_hi20:
-    return ELF::R_RISCV_HI20;
-  case RISCV::fixup_riscv_lo12_i:
-    return ELF::R_RISCV_LO12_I;
-  case RISCV::fixup_riscv_lo12_s:
-    return ELF::R_RISCV_LO12_S;
-  case RISCV::fixup_riscv_pcrel_hi20:
-    return ELF::R_RISCV_PCREL_HI20;
-  case RISCV::fixup_riscv_pcrel_lo12_i:
-    return ELF::R_RISCV_PCREL_LO12_I;
-  case RISCV::fixup_riscv_pcrel_lo12_s:
-    return ELF::R_RISCV_PCREL_LO12_S;
-  case RISCV::fixup_riscv_jal:
-    return ELF::R_RISCV_JAL;
-  case RISCV::fixup_riscv_branch:
-    return ELF::R_RISCV_BRANCH;
-  case RISCV::fixup_riscv_rvc_jump:
-    return ELF::R_RISCV_RVC_JUMP;
-  case RISCV::fixup_riscv_rvc_branch:
-    return ELF::R_RISCV_RVC_BRANCH;
-  case RISCV::fixup_riscv_call:
-    return ELF::R_RISCV_CALL;
-  case RISCV::fixup_riscv_relax:
-    return ELF::R_RISCV_RELAX;
-  }
-}
-
-std::unique_ptr<MCObjectTargetWriter>
-llvm::createRISCVELFObjectWriter(uint8_t OSABI, bool Is64Bit) {
-  return llvm::make_unique<RISCVELFObjectWriter>(OSABI, Is64Bit);
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
deleted file mode 100644
index a6ba1e41e96..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//===-- RISCVELFStreamer.cpp - RISCV ELF Target Streamer Methods ----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target streamer methods.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVELFStreamer.h"
-#include "RISCVMCTargetDesc.h"
-#include "llvm/BinaryFormat/ELF.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-
-using namespace llvm;
-
-// This part is for ELF object output.
-RISCVTargetELFStreamer::RISCVTargetELFStreamer(MCStreamer &S,
-                                               const MCSubtargetInfo &STI)
-    : RISCVTargetStreamer(S) {
-  MCAssembler &MCA = getStreamer().getAssembler();
-
-  const FeatureBitset &Features = STI.getFeatureBits();
-
-  unsigned EFlags = MCA.getELFHeaderEFlags();
-
-  if (Features[RISCV::FeatureStdExtC])
-    EFlags |= ELF::EF_RISCV_RVC;
-
-  MCA.setELFHeaderEFlags(EFlags);
-}
-
-MCELFStreamer &RISCVTargetELFStreamer::getStreamer() {
-  return static_cast<MCELFStreamer &>(Streamer);
-}
-
-void RISCVTargetELFStreamer::emitDirectiveOptionPush() {}
-void RISCVTargetELFStreamer::emitDirectiveOptionPop() {}
-void RISCVTargetELFStreamer::emitDirectiveOptionRVC() {}
-void RISCVTargetELFStreamer::emitDirectiveOptionNoRVC() {}
-void RISCVTargetELFStreamer::emitDirectiveOptionRelax() {}
-void RISCVTargetELFStreamer::emitDirectiveOptionNoRelax() {}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h b/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
deleted file mode 100644
index 1f36bbc4388..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
+++ /dev/null
@@ -1,31 +0,0 @@
-//===-- RISCVELFStreamer.h - RISCV ELF Target Streamer ---------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVELFSTREAMER_H
-#define LLVM_LIB_TARGET_RISCV_RISCVELFSTREAMER_H
-
-#include "RISCVTargetStreamer.h"
-#include "llvm/MC/MCELFStreamer.h"
-
-namespace llvm {
-
-class RISCVTargetELFStreamer : public RISCVTargetStreamer {
-public:
-  MCELFStreamer &getStreamer();
-  RISCVTargetELFStreamer(MCStreamer &S, const MCSubtargetInfo &STI);
-
-  virtual void emitDirectiveOptionPush();
-  virtual void emitDirectiveOptionPop();
-  virtual void emitDirectiveOptionRVC();
-  virtual void emitDirectiveOptionNoRVC();
-  virtual void emitDirectiveOptionRelax();
-  virtual void emitDirectiveOptionNoRelax();
-};
-}
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h b/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
deleted file mode 100644
index 6a1224be774..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
+++ /dev/null
@@ -1,64 +0,0 @@
-//===-- RISCVFixupKinds.h - RISCV Specific Fixup Entries --------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVFIXUPKINDS_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVFIXUPKINDS_H
-
-#include "llvm/MC/MCFixup.h"
-
-#undef RISCV
-
-namespace llvm {
-namespace RISCV {
-enum Fixups {
-  // fixup_riscv_hi20 - 20-bit fixup corresponding to hi(foo) for
-  // instructions like lui
-  fixup_riscv_hi20 = FirstTargetFixupKind,
-  // fixup_riscv_lo12_i - 12-bit fixup corresponding to lo(foo) for
-  // instructions like addi
-  fixup_riscv_lo12_i,
-  // fixup_riscv_lo12_s - 12-bit fixup corresponding to lo(foo) for
-  // the S-type store instructions
-  fixup_riscv_lo12_s,
-  // fixup_riscv_pcrel_hi20 - 20-bit fixup corresponding to pcrel_hi(foo) for
-  // instructions like auipc
-  fixup_riscv_pcrel_hi20,
-  // fixup_riscv_pcrel_lo12_i - 12-bit fixup corresponding to pcrel_lo(foo) for
-  // instructions like addi
-  fixup_riscv_pcrel_lo12_i,
-  // fixup_riscv_pcrel_lo12_s - 12-bit fixup corresponding to pcrel_lo(foo) for
-  // the S-type store instructions
-  fixup_riscv_pcrel_lo12_s,
-  // fixup_riscv_jal - 20-bit fixup for symbol references in the jal
-  // instruction
-  fixup_riscv_jal,
-  // fixup_riscv_branch - 12-bit fixup for symbol references in the branch
-  // instructions
-  fixup_riscv_branch,
-  // fixup_riscv_rvc_jump - 11-bit fixup for symbol references in the
-  // compressed jump instruction
-  fixup_riscv_rvc_jump,
-  // fixup_riscv_rvc_branch - 8-bit fixup for symbol references in the
-  // compressed branch instruction
-  fixup_riscv_rvc_branch,
-  // fixup_riscv_call - A fixup representing a call attached to the auipc
-  // instruction in a pair composed of adjacent auipc+jalr instructions.
-  fixup_riscv_call,
-  // fixup_riscv_relax - Used to generate an R_RISCV_RELAX relocation type,
-  // which indicates the linker may relax the instruction pair.
-  fixup_riscv_relax,
-
-  // fixup_riscv_invalid - used as a sentinel and a marker, must be last fixup
-  fixup_riscv_invalid,
-  NumTargetFixupKinds = fixup_riscv_invalid - FirstTargetFixupKind
-};
-} // end namespace RISCV
-} // end namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
deleted file mode 100644
index 780dae410cd..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-//===-- RISCVMCAsmInfo.cpp - RISCV Asm properties -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the declarations of the RISCVMCAsmInfo properties.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMCAsmInfo.h"
-#include "llvm/ADT/Triple.h"
-using namespace llvm;
-
-void RISCVMCAsmInfo::anchor() {}
-
-RISCVMCAsmInfo::RISCVMCAsmInfo(const Triple &TT) {
-  CodePointerSize = CalleeSaveStackSlotSize = TT.isArch64Bit() ? 8 : 4;
-  CommentString = "#";
-  AlignmentIsInBytes = false;
-  SupportsDebugInformation = true;
-  Data16bitsDirective = "\t.half\t";
-  Data32bitsDirective = "\t.word\t";
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
deleted file mode 100644
index 901a1eba8af..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
+++ /dev/null
@@ -1,31 +0,0 @@
-//===-- RISCVMCAsmInfo.h - RISCV Asm Info ----------------------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the declaration of the RISCVMCAsmInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCASMINFO_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCASMINFO_H
-
-#include "llvm/MC/MCAsmInfoELF.h"
-
-namespace llvm {
-class Triple;
-
-class RISCVMCAsmInfo : public MCAsmInfoELF {
-  void anchor() override;
-
-public:
-  explicit RISCVMCAsmInfo(const Triple &TargetTriple);
-};
-
-} // namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
deleted file mode 100644
index c5a4ffc0e36..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
+++ /dev/null
@@ -1,273 +0,0 @@
-//===-- RISCVMCCodeEmitter.cpp - Convert RISCV code to machine code -------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCVMCCodeEmitter class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "Utils/RISCVBaseInfo.h"
-#include "llvm/ADT/Statistic.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCCodeEmitter.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCInstBuilder.h"
-#include "llvm/MC/MCInstrInfo.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/Casting.h"
-#include "llvm/Support/EndianStream.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "mccodeemitter"
-
-STATISTIC(MCNumEmitted, "Number of MC instructions emitted");
-STATISTIC(MCNumFixups, "Number of MC fixups created");
-
-namespace {
-class RISCVMCCodeEmitter : public MCCodeEmitter {
-  RISCVMCCodeEmitter(const RISCVMCCodeEmitter &) = delete;
-  void operator=(const RISCVMCCodeEmitter &) = delete;
-  MCContext &Ctx;
-  MCInstrInfo const &MCII;
-
-public:
-  RISCVMCCodeEmitter(MCContext &ctx, MCInstrInfo const &MCII)
-      : Ctx(ctx), MCII(MCII) {}
-
-  ~RISCVMCCodeEmitter() override {}
-
-  void encodeInstruction(const MCInst &MI, raw_ostream &OS,
-                         SmallVectorImpl<MCFixup> &Fixups,
-                         const MCSubtargetInfo &STI) const override;
-
-  void expandFunctionCall(const MCInst &MI, raw_ostream &OS,
-                          SmallVectorImpl<MCFixup> &Fixups,
-                          const MCSubtargetInfo &STI) const;
-
-  /// TableGen'erated function for getting the binary encoding for an
-  /// instruction.
-  uint64_t getBinaryCodeForInstr(const MCInst &MI,
-                                 SmallVectorImpl<MCFixup> &Fixups,
-                                 const MCSubtargetInfo &STI) const;
-
-  /// Return binary encoding of operand. If the machine operand requires
-  /// relocation, record the relocation and return zero.
-  unsigned getMachineOpValue(const MCInst &MI, const MCOperand &MO,
-                             SmallVectorImpl<MCFixup> &Fixups,
-                             const MCSubtargetInfo &STI) const;
-
-  unsigned getImmOpValueAsr1(const MCInst &MI, unsigned OpNo,
-                             SmallVectorImpl<MCFixup> &Fixups,
-                             const MCSubtargetInfo &STI) const;
-
-  unsigned getImmOpValue(const MCInst &MI, unsigned OpNo,
-                         SmallVectorImpl<MCFixup> &Fixups,
-                         const MCSubtargetInfo &STI) const;
-};
-} // end anonymous namespace
-
-MCCodeEmitter *llvm::createRISCVMCCodeEmitter(const MCInstrInfo &MCII,
-                                              const MCRegisterInfo &MRI,
-                                              MCContext &Ctx) {
-  return new RISCVMCCodeEmitter(Ctx, MCII);
-}
-
-// Expand PseudoCALL and PseudoTAIL to AUIPC and JALR with relocation types.
-// We expand PseudoCALL and PseudoTAIL while encoding, meaning AUIPC and JALR
-// won't go through RISCV MC to MC compressed instruction transformation. This
-// is acceptable because AUIPC has no 16-bit form and C_JALR have no immediate
-// operand field.  We let linker relaxation deal with it. When linker
-// relaxation enabled, AUIPC and JALR have chance relax to JAL. If C extension
-// is enabled, JAL has chance relax to C_JAL.
-void RISCVMCCodeEmitter::expandFunctionCall(const MCInst &MI, raw_ostream &OS,
-                                            SmallVectorImpl<MCFixup> &Fixups,
-                                            const MCSubtargetInfo &STI) const {
-  MCInst TmpInst;
-  MCOperand Func = MI.getOperand(0);
-  unsigned Ra = (MI.getOpcode() == RISCV::PseudoTAIL) ? RISCV::X6 : RISCV::X1;
-  uint32_t Binary;
-
-  assert(Func.isExpr() && "Expected expression");
-
-  const MCExpr *Expr = Func.getExpr();
-
-  // Create function call expression CallExpr for AUIPC.
-  const MCExpr *CallExpr =
-      RISCVMCExpr::create(Expr, RISCVMCExpr::VK_RISCV_CALL, Ctx);
-
-  // Emit AUIPC Ra, Func with R_RISCV_CALL relocation type.
-  TmpInst = MCInstBuilder(RISCV::AUIPC)
-                .addReg(Ra)
-                .addOperand(MCOperand::createExpr(CallExpr));
-  Binary = getBinaryCodeForInstr(TmpInst, Fixups, STI);
-  support::endian::write(OS, Binary, support::little);
-
-  if (MI.getOpcode() == RISCV::PseudoTAIL)
-    // Emit JALR X0, X6, 0
-    TmpInst = MCInstBuilder(RISCV::JALR).addReg(RISCV::X0).addReg(Ra).addImm(0);
-  else
-    // Emit JALR X1, X1, 0
-    TmpInst = MCInstBuilder(RISCV::JALR).addReg(Ra).addReg(Ra).addImm(0);
-  Binary = getBinaryCodeForInstr(TmpInst, Fixups, STI);
-  support::endian::write(OS, Binary, support::little);
-}
-
-void RISCVMCCodeEmitter::encodeInstruction(const MCInst &MI, raw_ostream &OS,
-                                           SmallVectorImpl<MCFixup> &Fixups,
-                                           const MCSubtargetInfo &STI) const {
-  const MCInstrDesc &Desc = MCII.get(MI.getOpcode());
-  // Get byte count of instruction.
-  unsigned Size = Desc.getSize();
-
-  if (MI.getOpcode() == RISCV::PseudoCALL ||
-      MI.getOpcode() == RISCV::PseudoTAIL) {
-    expandFunctionCall(MI, OS, Fixups, STI);
-    MCNumEmitted += 2;
-    return;
-  }
-
-  switch (Size) {
-  default:
-    llvm_unreachable("Unhandled encodeInstruction length!");
-  case 2: {
-    uint16_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
-    support::endian::write<uint16_t>(OS, Bits, support::little);
-    break;
-  }
-  case 4: {
-    uint32_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
-    support::endian::write(OS, Bits, support::little);
-    break;
-  }
-  }
-
-  ++MCNumEmitted; // Keep track of the # of mi's emitted.
-}
-
-unsigned
-RISCVMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
-                                      SmallVectorImpl<MCFixup> &Fixups,
-                                      const MCSubtargetInfo &STI) const {
-
-  if (MO.isReg())
-    return Ctx.getRegisterInfo()->getEncodingValue(MO.getReg());
-
-  if (MO.isImm())
-    return static_cast<unsigned>(MO.getImm());
-
-  llvm_unreachable("Unhandled expression!");
-  return 0;
-}
-
-unsigned
-RISCVMCCodeEmitter::getImmOpValueAsr1(const MCInst &MI, unsigned OpNo,
-                                      SmallVectorImpl<MCFixup> &Fixups,
-                                      const MCSubtargetInfo &STI) const {
-  const MCOperand &MO = MI.getOperand(OpNo);
-
-  if (MO.isImm()) {
-    unsigned Res = MO.getImm();
-    assert((Res & 1) == 0 && "LSB is non-zero");
-    return Res >> 1;
-  }
-
-  return getImmOpValue(MI, OpNo, Fixups, STI);
-}
-
-unsigned RISCVMCCodeEmitter::getImmOpValue(const MCInst &MI, unsigned OpNo,
-                                           SmallVectorImpl<MCFixup> &Fixups,
-                                           const MCSubtargetInfo &STI) const {
-  bool EnableRelax = STI.getFeatureBits()[RISCV::FeatureRelax];
-  const MCOperand &MO = MI.getOperand(OpNo);
-
-  MCInstrDesc const &Desc = MCII.get(MI.getOpcode());
-  unsigned MIFrm = Desc.TSFlags & RISCVII::InstFormatMask;
-
-  // If the destination is an immediate, there is nothing to do.
-  if (MO.isImm())
-    return MO.getImm();
-
-  assert(MO.isExpr() &&
-         "getImmOpValue expects only expressions or immediates");
-  const MCExpr *Expr = MO.getExpr();
-  MCExpr::ExprKind Kind = Expr->getKind();
-  RISCV::Fixups FixupKind = RISCV::fixup_riscv_invalid;
-  if (Kind == MCExpr::Target) {
-    const RISCVMCExpr *RVExpr = cast<RISCVMCExpr>(Expr);
-
-    switch (RVExpr->getKind()) {
-    case RISCVMCExpr::VK_RISCV_None:
-    case RISCVMCExpr::VK_RISCV_Invalid:
-      llvm_unreachable("Unhandled fixup kind!");
-    case RISCVMCExpr::VK_RISCV_LO:
-      if (MIFrm == RISCVII::InstFormatI)
-        FixupKind = RISCV::fixup_riscv_lo12_i;
-      else if (MIFrm == RISCVII::InstFormatS)
-        FixupKind = RISCV::fixup_riscv_lo12_s;
-      else
-        llvm_unreachable("VK_RISCV_LO used with unexpected instruction format");
-      break;
-    case RISCVMCExpr::VK_RISCV_HI:
-      FixupKind = RISCV::fixup_riscv_hi20;
-      break;
-    case RISCVMCExpr::VK_RISCV_PCREL_LO:
-      if (MIFrm == RISCVII::InstFormatI)
-        FixupKind = RISCV::fixup_riscv_pcrel_lo12_i;
-      else if (MIFrm == RISCVII::InstFormatS)
-        FixupKind = RISCV::fixup_riscv_pcrel_lo12_s;
-      else
-        llvm_unreachable(
-            "VK_RISCV_PCREL_LO used with unexpected instruction format");
-      break;
-    case RISCVMCExpr::VK_RISCV_PCREL_HI:
-      FixupKind = RISCV::fixup_riscv_pcrel_hi20;
-      break;
-    case RISCVMCExpr::VK_RISCV_CALL:
-      FixupKind = RISCV::fixup_riscv_call;
-      break;
-    }
-  } else if (Kind == MCExpr::SymbolRef &&
-             cast<MCSymbolRefExpr>(Expr)->getKind() == MCSymbolRefExpr::VK_None) {
-    if (Desc.getOpcode() == RISCV::JAL) {
-      FixupKind = RISCV::fixup_riscv_jal;
-    } else if (MIFrm == RISCVII::InstFormatB) {
-      FixupKind = RISCV::fixup_riscv_branch;
-    } else if (MIFrm == RISCVII::InstFormatCJ) {
-      FixupKind = RISCV::fixup_riscv_rvc_jump;
-    } else if (MIFrm == RISCVII::InstFormatCB) {
-      FixupKind = RISCV::fixup_riscv_rvc_branch;
-    }
-  }
-
-  assert(FixupKind != RISCV::fixup_riscv_invalid && "Unhandled expression!");
-
-  Fixups.push_back(
-      MCFixup::create(0, Expr, MCFixupKind(FixupKind), MI.getLoc()));
-  ++MCNumFixups;
-
-  if (EnableRelax) {
-    if (FixupKind == RISCV::fixup_riscv_call) {
-      Fixups.push_back(
-      MCFixup::create(0, Expr, MCFixupKind(RISCV::fixup_riscv_relax),
-                      MI.getLoc()));
-      ++MCNumFixups;
-    }
-  }
-
-  return 0;
-}
-
-#include "RISCVGenMCCodeEmitter.inc"
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
deleted file mode 100644
index 53648a5922c..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
+++ /dev/null
@@ -1,202 +0,0 @@
-//===-- RISCVMCExpr.cpp - RISCV specific MC expression classes ------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the implementation of the assembly expression modifiers
-// accepted by the RISCV architecture (e.g. ":lo12:", ":gottprel_g1:", ...).
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "RISCVMCExpr.h"
-#include "RISCVFixupKinds.h"
-#include "llvm/MC/MCAssembler.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSymbolELF.h"
-#include "llvm/MC/MCValue.h"
-#include "llvm/Support/ErrorHandling.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscvmcexpr"
-
-const RISCVMCExpr *RISCVMCExpr::create(const MCExpr *Expr, VariantKind Kind,
-                                       MCContext &Ctx) {
-  return new (Ctx) RISCVMCExpr(Expr, Kind);
-}
-
-void RISCVMCExpr::printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const {
-  bool HasVariant =
-      ((getKind() != VK_RISCV_None) && (getKind() != VK_RISCV_CALL));
-  if (HasVariant)
-    OS << '%' << getVariantKindName(getKind()) << '(';
-  Expr->print(OS, MAI);
-  if (HasVariant)
-    OS << ')';
-}
-
-const MCFixup *RISCVMCExpr::getPCRelHiFixup() const {
-  MCValue AUIPCLoc;
-  if (!getSubExpr()->evaluateAsRelocatable(AUIPCLoc, nullptr, nullptr))
-    return nullptr;
-
-  const MCSymbolRefExpr *AUIPCSRE = AUIPCLoc.getSymA();
-  if (!AUIPCSRE)
-    return nullptr;
-
-  const auto *DF =
-      dyn_cast_or_null<MCDataFragment>(AUIPCSRE->findAssociatedFragment());
-  if (!DF)
-    return nullptr;
-
-  const MCSymbol *AUIPCSymbol = &AUIPCSRE->getSymbol();
-  for (const MCFixup &F : DF->getFixups()) {
-    if (F.getOffset() != AUIPCSymbol->getOffset())
-      continue;
-
-    switch ((unsigned)F.getKind()) {
-    default:
-      continue;
-    case RISCV::fixup_riscv_pcrel_hi20:
-      return &F;
-    }
-  }
-
-  return nullptr;
-}
-
-bool RISCVMCExpr::evaluatePCRelLo(MCValue &Res, const MCAsmLayout *Layout,
-                                  const MCFixup *Fixup) const {
-  // VK_RISCV_PCREL_LO has to be handled specially.  The MCExpr inside is
-  // actually the location of a auipc instruction with a VK_RISCV_PCREL_HI fixup
-  // pointing to the real target.  We need to generate an MCValue in the form of
-  // (<real target> + <offset from this fixup to the auipc fixup>).  The Fixup
-  // is pcrel relative to the VK_RISCV_PCREL_LO fixup, so we need to add the
-  // offset to the VK_RISCV_PCREL_HI Fixup from VK_RISCV_PCREL_LO to correct.
-  MCValue AUIPCLoc;
-  if (!getSubExpr()->evaluateAsValue(AUIPCLoc, *Layout))
-    return false;
-
-  const MCSymbolRefExpr *AUIPCSRE = AUIPCLoc.getSymA();
-  // Don't try to evaluate %pcrel_hi/%pcrel_lo pairs that cross fragment
-  // boundries.
-  if (!AUIPCSRE ||
-      findAssociatedFragment() != AUIPCSRE->findAssociatedFragment())
-    return false;
-
-  const MCSymbol *AUIPCSymbol = &AUIPCSRE->getSymbol();
-  if (!AUIPCSymbol)
-    return false;
-
-  const MCFixup *TargetFixup = getPCRelHiFixup();
-  if (!TargetFixup)
-    return false;
-
-  if ((unsigned)TargetFixup->getKind() != RISCV::fixup_riscv_pcrel_hi20)
-    return false;
-
-  MCValue Target;
-  if (!TargetFixup->getValue()->evaluateAsValue(Target, *Layout))
-    return false;
-
-  if (!Target.getSymA() || !Target.getSymA()->getSymbol().isInSection())
-    return false;
-
-  if (&Target.getSymA()->getSymbol().getSection() !=
-      findAssociatedFragment()->getParent())
-    return false;
-
-  uint64_t AUIPCOffset = AUIPCSymbol->getOffset();
-
-  Res = MCValue::get(Target.getSymA(), nullptr,
-                     Target.getConstant() + (Fixup->getOffset() - AUIPCOffset));
-  return true;
-}
-
-bool RISCVMCExpr::evaluateAsRelocatableImpl(MCValue &Res,
-                                            const MCAsmLayout *Layout,
-                                            const MCFixup *Fixup) const {
-  if (Kind == VK_RISCV_PCREL_LO && evaluatePCRelLo(Res, Layout, Fixup))
-    return true;
-
-  if (!getSubExpr()->evaluateAsRelocatable(Res, Layout, Fixup))
-    return false;
-
-  // Some custom fixup types are not valid with symbol difference expressions
-  if (Res.getSymA() && Res.getSymB()) {
-    switch (getKind()) {
-    default:
-      return true;
-    case VK_RISCV_LO:
-    case VK_RISCV_HI:
-    case VK_RISCV_PCREL_LO:
-    case VK_RISCV_PCREL_HI:
-      return false;
-    }
-  }
-
-  return true;
-}
-
-void RISCVMCExpr::visitUsedExpr(MCStreamer &Streamer) const {
-  Streamer.visitUsedExpr(*getSubExpr());
-}
-
-RISCVMCExpr::VariantKind RISCVMCExpr::getVariantKindForName(StringRef name) {
-  return StringSwitch<RISCVMCExpr::VariantKind>(name)
-      .Case("lo", VK_RISCV_LO)
-      .Case("hi", VK_RISCV_HI)
-      .Case("pcrel_lo", VK_RISCV_PCREL_LO)
-      .Case("pcrel_hi", VK_RISCV_PCREL_HI)
-      .Default(VK_RISCV_Invalid);
-}
-
-StringRef RISCVMCExpr::getVariantKindName(VariantKind Kind) {
-  switch (Kind) {
-  default:
-    llvm_unreachable("Invalid ELF symbol kind");
-  case VK_RISCV_LO:
-    return "lo";
-  case VK_RISCV_HI:
-    return "hi";
-  case VK_RISCV_PCREL_LO:
-    return "pcrel_lo";
-  case VK_RISCV_PCREL_HI:
-    return "pcrel_hi";
-  }
-}
-
-bool RISCVMCExpr::evaluateAsConstant(int64_t &Res) const {
-  MCValue Value;
-
-  if (Kind == VK_RISCV_PCREL_HI || Kind == VK_RISCV_PCREL_LO ||
-      Kind == VK_RISCV_CALL)
-    return false;
-
-  if (!getSubExpr()->evaluateAsRelocatable(Value, nullptr, nullptr))
-    return false;
-
-  if (!Value.isAbsolute())
-    return false;
-
-  Res = evaluateAsInt64(Value.getConstant());
-  return true;
-}
-
-int64_t RISCVMCExpr::evaluateAsInt64(int64_t Value) const {
-  switch (Kind) {
-  default:
-    llvm_unreachable("Invalid kind");
-  case VK_RISCV_LO:
-    return SignExtend64<12>(Value);
-  case VK_RISCV_HI:
-    // Add 1 if bit 11 is 1, to compensate for low 12 bits being negative.
-    return ((Value + 0x800) >> 12) & 0xfffff;
-  }
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
deleted file mode 100644
index 4eafcc08b51..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
+++ /dev/null
@@ -1,88 +0,0 @@
-//===-- RISCVMCExpr.h - RISCV specific MC expression classes ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes RISCV-specific MCExprs, used for modifiers like
-// "%hi" or "%lo" etc.,
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCEXPR_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCEXPR_H
-
-#include "llvm/MC/MCExpr.h"
-
-namespace llvm {
-
-class StringRef;
-class MCOperand;
-class RISCVMCExpr : public MCTargetExpr {
-public:
-  enum VariantKind {
-    VK_RISCV_None,
-    VK_RISCV_LO,
-    VK_RISCV_HI,
-    VK_RISCV_PCREL_LO,
-    VK_RISCV_PCREL_HI,
-    VK_RISCV_CALL,
-    VK_RISCV_Invalid
-  };
-
-private:
-  const MCExpr *Expr;
-  const VariantKind Kind;
-
-  int64_t evaluateAsInt64(int64_t Value) const;
-
-  bool evaluatePCRelLo(MCValue &Res, const MCAsmLayout *Layout,
-                       const MCFixup *Fixup) const;
-
-  explicit RISCVMCExpr(const MCExpr *Expr, VariantKind Kind)
-      : Expr(Expr), Kind(Kind) {}
-
-public:
-  static const RISCVMCExpr *create(const MCExpr *Expr, VariantKind Kind,
-                                   MCContext &Ctx);
-
-  VariantKind getKind() const { return Kind; }
-
-  const MCExpr *getSubExpr() const { return Expr; }
-
-  /// Get the MCExpr of the VK_RISCV_PCREL_HI Fixup that the
-  /// VK_RISCV_PCREL_LO points to.
-  ///
-  /// \returns nullptr if this isn't a VK_RISCV_PCREL_LO pointing to a
-  /// VK_RISCV_PCREL_HI.
-  const MCFixup *getPCRelHiFixup() const;
-
-  void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const override;
-  bool evaluateAsRelocatableImpl(MCValue &Res, const MCAsmLayout *Layout,
-                                 const MCFixup *Fixup) const override;
-  void visitUsedExpr(MCStreamer &Streamer) const override;
-  MCFragment *findAssociatedFragment() const override {
-    return getSubExpr()->findAssociatedFragment();
-  }
-
-  // There are no TLS RISCVMCExprs at the moment.
-  void fixELFSymbolsInTLSFixups(MCAssembler &Asm) const override {}
-
-  bool evaluateAsConstant(int64_t &Res) const;
-
-  static bool classof(const MCExpr *E) {
-    return E->getKind() == MCExpr::Target;
-  }
-
-  static bool classof(const RISCVMCExpr *) { return true; }
-
-  static VariantKind getVariantKindForName(StringRef name);
-  static StringRef getVariantKindName(VariantKind Kind);
-};
-
-} // end namespace llvm.
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
deleted file mode 100644
index 133f3cd3d39..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-//===-- RISCVMCTargetDesc.cpp - RISCV Target Descriptions -----------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-///
-/// This file provides RISCV-specific target descriptions.
-///
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMCTargetDesc.h"
-#include "InstPrinter/RISCVInstPrinter.h"
-#include "RISCVELFStreamer.h"
-#include "RISCVMCAsmInfo.h"
-#include "RISCVTargetStreamer.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCInstrInfo.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/TargetRegistry.h"
-
-#define GET_INSTRINFO_MC_DESC
-#include "RISCVGenInstrInfo.inc"
-
-#define GET_REGINFO_MC_DESC
-#include "RISCVGenRegisterInfo.inc"
-
-#define GET_SUBTARGETINFO_MC_DESC
-#include "RISCVGenSubtargetInfo.inc"
-
-using namespace llvm;
-
-static MCInstrInfo *createRISCVMCInstrInfo() {
-  MCInstrInfo *X = new MCInstrInfo();
-  InitRISCVMCInstrInfo(X);
-  return X;
-}
-
-static MCRegisterInfo *createRISCVMCRegisterInfo(const Triple &TT) {
-  MCRegisterInfo *X = new MCRegisterInfo();
-  InitRISCVMCRegisterInfo(X, RISCV::X1);
-  return X;
-}
-
-static MCAsmInfo *createRISCVMCAsmInfo(const MCRegisterInfo &MRI,
-                                       const Triple &TT) {
-  return new RISCVMCAsmInfo(TT);
-}
-
-static MCSubtargetInfo *createRISCVMCSubtargetInfo(const Triple &TT,
-                                                   StringRef CPU, StringRef FS) {
-  std::string CPUName = CPU;
-  if (CPUName.empty())
-    CPUName = TT.isArch64Bit() ? "generic-rv64" : "generic-rv32";
-  return createRISCVMCSubtargetInfoImpl(TT, CPUName, FS);
-}
-
-static MCInstPrinter *createRISCVMCInstPrinter(const Triple &T,
-                                               unsigned SyntaxVariant,
-                                               const MCAsmInfo &MAI,
-                                               const MCInstrInfo &MII,
-                                               const MCRegisterInfo &MRI) {
-  return new RISCVInstPrinter(MAI, MII, MRI);
-}
-
-static MCTargetStreamer *
-createRISCVObjectTargetStreamer(MCStreamer &S, const MCSubtargetInfo &STI) {
-  const Triple &TT = STI.getTargetTriple();
-  if (TT.isOSBinFormatELF())
-    return new RISCVTargetELFStreamer(S, STI);
-  return nullptr;
-}
-
-static MCTargetStreamer *createRISCVAsmTargetStreamer(MCStreamer &S,
-                                                      formatted_raw_ostream &OS,
-                                                      MCInstPrinter *InstPrint,
-                                                      bool isVerboseAsm) {
-  return new RISCVTargetAsmStreamer(S, OS);
-}
-
-extern "C" void LLVMInitializeRISCVTargetMC() {
-  for (Target *T : {&getTheRISCV32Target(), &getTheRISCV64Target()}) {
-    TargetRegistry::RegisterMCAsmInfo(*T, createRISCVMCAsmInfo);
-    TargetRegistry::RegisterMCInstrInfo(*T, createRISCVMCInstrInfo);
-    TargetRegistry::RegisterMCRegInfo(*T, createRISCVMCRegisterInfo);
-    TargetRegistry::RegisterMCAsmBackend(*T, createRISCVAsmBackend);
-    TargetRegistry::RegisterMCCodeEmitter(*T, createRISCVMCCodeEmitter);
-    TargetRegistry::RegisterMCInstPrinter(*T, createRISCVMCInstPrinter);
-    TargetRegistry::RegisterMCSubtargetInfo(*T, createRISCVMCSubtargetInfo);
-    TargetRegistry::RegisterObjectTargetStreamer(
-        *T, createRISCVObjectTargetStreamer);
-
-    // Register the asm target streamer.
-    TargetRegistry::RegisterAsmTargetStreamer(*T, createRISCVAsmTargetStreamer);
-  }
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
deleted file mode 100644
index 0228253c08c..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
+++ /dev/null
@@ -1,62 +0,0 @@
-//===-- RISCVMCTargetDesc.h - RISCV Target Descriptions ---------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target descriptions.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCTARGETDESC_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCTARGETDESC_H
-
-#include "llvm/Config/config.h"
-#include "llvm/MC/MCTargetOptions.h"
-#include "llvm/Support/DataTypes.h"
-#include <memory>
-
-namespace llvm {
-class MCAsmBackend;
-class MCCodeEmitter;
-class MCContext;
-class MCInstrInfo;
-class MCObjectTargetWriter;
-class MCRegisterInfo;
-class MCSubtargetInfo;
-class StringRef;
-class Target;
-class Triple;
-class raw_ostream;
-class raw_pwrite_stream;
-
-Target &getTheRISCV32Target();
-Target &getTheRISCV64Target();
-
-MCCodeEmitter *createRISCVMCCodeEmitter(const MCInstrInfo &MCII,
-                                        const MCRegisterInfo &MRI,
-                                        MCContext &Ctx);
-
-MCAsmBackend *createRISCVAsmBackend(const Target &T, const MCSubtargetInfo &STI,
-                                    const MCRegisterInfo &MRI,
-                                    const MCTargetOptions &Options);
-
-std::unique_ptr<MCObjectTargetWriter> createRISCVELFObjectWriter(uint8_t OSABI,
-                                                                 bool Is64Bit);
-}
-
-// Defines symbolic names for RISC-V registers.
-#define GET_REGINFO_ENUM
-#include "RISCVGenRegisterInfo.inc"
-
-// Defines symbolic names for RISC-V instructions.
-#define GET_INSTRINFO_ENUM
-#include "RISCVGenInstrInfo.inc"
-
-#define GET_SUBTARGETINFO_ENUM
-#include "RISCVGenSubtargetInfo.inc"
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
deleted file mode 100644
index 8d5ef3dbd17..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//===-- RISCVTargetStreamer.cpp - RISCV Target Streamer Methods -----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target streamer methods.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVTargetStreamer.h"
-#include "llvm/Support/FormattedStream.h"
-
-using namespace llvm;
-
-RISCVTargetStreamer::RISCVTargetStreamer(MCStreamer &S) : MCTargetStreamer(S) {}
-
-// This part is for ascii assembly output
-RISCVTargetAsmStreamer::RISCVTargetAsmStreamer(MCStreamer &S,
-                                               formatted_raw_ostream &OS)
-    : RISCVTargetStreamer(S), OS(OS) {}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionPush() {
-  OS << "\t.option\tpush\n";
-}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionPop() {
-  OS << "\t.option\tpop\n";
-}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionRVC() {
-  OS << "\t.option\trvc\n";
-}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionNoRVC() {
-  OS << "\t.option\tnorvc\n";
-}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionRelax() {
-  OS << "\t.option\trelax\n";
-}
-
-void RISCVTargetAsmStreamer::emitDirectiveOptionNoRelax() {
-  OS << "\t.option\tnorelax\n";
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h b/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
deleted file mode 100644
index 74ec9e30393..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
+++ /dev/null
@@ -1,45 +0,0 @@
-//===-- RISCVTargetStreamer.h - RISCV Target Streamer ----------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVTARGETSTREAMER_H
-#define LLVM_LIB_TARGET_RISCV_RISCVTARGETSTREAMER_H
-
-#include "llvm/MC/MCStreamer.h"
-
-namespace llvm {
-
-class RISCVTargetStreamer : public MCTargetStreamer {
-public:
-  RISCVTargetStreamer(MCStreamer &S);
-
-  virtual void emitDirectiveOptionPush() = 0;
-  virtual void emitDirectiveOptionPop() = 0;
-  virtual void emitDirectiveOptionRVC() = 0;
-  virtual void emitDirectiveOptionNoRVC() = 0;
-  virtual void emitDirectiveOptionRelax() = 0;
-  virtual void emitDirectiveOptionNoRelax() = 0;
-};
-
-// This part is for ascii assembly output
-class RISCVTargetAsmStreamer : public RISCVTargetStreamer {
-  formatted_raw_ostream &OS;
-
-public:
-  RISCVTargetAsmStreamer(MCStreamer &S, formatted_raw_ostream &OS);
-
-  void emitDirectiveOptionPush() override;
-  void emitDirectiveOptionPop() override;
-  void emitDirectiveOptionRVC() override;
-  void emitDirectiveOptionNoRVC() override;
-  void emitDirectiveOptionRelax() override;
-  void emitDirectiveOptionNoRelax() override;
-};
-
-}
-#endif
diff --git a/lib/Target/RISCV/RISCV.h b/lib/Target/RISCV/RISCV.h
deleted file mode 100644
index b25aee46200..00000000000
--- a/lib/Target/RISCV/RISCV.h
+++ /dev/null
@@ -1,45 +0,0 @@
-//===-- RISCV.h - Top-level interface for RISCV -----------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the entry points for global functions defined in the LLVM
-// RISC-V back-end.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCV_H
-#define LLVM_LIB_TARGET_RISCV_RISCV_H
-
-#include "Utils/RISCVBaseInfo.h"
-#include "llvm/Target/TargetMachine.h"
-
-namespace llvm {
-class RISCVTargetMachine;
-class AsmPrinter;
-class FunctionPass;
-class MCInst;
-class MCOperand;
-class MachineInstr;
-class MachineOperand;
-class PassRegistry;
-
-void LowerRISCVMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
-                                    const AsmPrinter &AP);
-bool LowerRISCVMachineOperandToMCOperand(const MachineOperand &MO,
-                                         MCOperand &MCOp, const AsmPrinter &AP);
-
-FunctionPass *createRISCVISelDag(RISCVTargetMachine &TM);
-
-FunctionPass *createRISCVMergeBaseOffsetOptPass();
-void initializeRISCVMergeBaseOffsetOptPass(PassRegistry &);
-
-FunctionPass *createRISCVExpandPseudoPass();
-void initializeRISCVExpandPseudoPass(PassRegistry &);
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCV.td b/lib/Target/RISCV/RISCV.td
deleted file mode 100644
index 0e86e2bc5e9..00000000000
--- a/lib/Target/RISCV/RISCV.td
+++ /dev/null
@@ -1,106 +0,0 @@
-//===-- RISCV.td - Describe the RISCV Target Machine -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-include "llvm/Target/Target.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V subtarget features and instruction predicates.
-//===----------------------------------------------------------------------===//
-
-def FeatureStdExtM
-    : SubtargetFeature<"m", "HasStdExtM", "true",
-                       "'M' (Integer Multiplication and Division)">;
-def HasStdExtM : Predicate<"Subtarget->hasStdExtM()">,
-                           AssemblerPredicate<"FeatureStdExtM">;
-
-def FeatureStdExtA
-    : SubtargetFeature<"a", "HasStdExtA", "true",
-                       "'A' (Atomic Instructions)">;
-def HasStdExtA : Predicate<"Subtarget->hasStdExtA()">,
-                           AssemblerPredicate<"FeatureStdExtA">;
-
-def FeatureStdExtF
-    : SubtargetFeature<"f", "HasStdExtF", "true",
-                       "'F' (Single-Precision Floating-Point)">;
-def HasStdExtF : Predicate<"Subtarget->hasStdExtF()">,
-                           AssemblerPredicate<"FeatureStdExtF">;
-
-def FeatureStdExtD
-    : SubtargetFeature<"d", "HasStdExtD", "true",
-                       "'D' (Double-Precision Floating-Point)",
-                       [FeatureStdExtF]>;
-def HasStdExtD : Predicate<"Subtarget->hasStdExtD()">,
-                           AssemblerPredicate<"FeatureStdExtD">;
-
-def FeatureStdExtC
-    : SubtargetFeature<"c", "HasStdExtC", "true",
-                       "'C' (Compressed Instructions)">;
-def HasStdExtC : Predicate<"Subtarget->hasStdExtC()">,
-                           AssemblerPredicate<"FeatureStdExtC">;
-
-
-def Feature64Bit
-    : SubtargetFeature<"64bit", "HasRV64", "true", "Implements RV64">;
-def IsRV64 : Predicate<"Subtarget->is64Bit()">,
-                       AssemblerPredicate<"Feature64Bit">;
-def IsRV32 : Predicate<"!Subtarget->is64Bit()">,
-                       AssemblerPredicate<"!Feature64Bit">;
-
-def RV64           : HwMode<"+64bit">;
-def RV32           : HwMode<"-64bit">;
-
-def FeatureRelax
-    : SubtargetFeature<"relax", "EnableLinkerRelax", "true",
-                       "Enable Linker relaxation.">;
-
-//===----------------------------------------------------------------------===//
-// Registers, calling conventions, instruction descriptions.
-//===----------------------------------------------------------------------===//
-
-include "RISCVRegisterInfo.td"
-include "RISCVCallingConv.td"
-include "RISCVInstrInfo.td"
-
-//===----------------------------------------------------------------------===//
-// Named operands for CSR instructions.
-//===----------------------------------------------------------------------===//
-
-include "RISCVSystemOperands.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V processors supported.
-//===----------------------------------------------------------------------===//
-
-def : ProcessorModel<"generic-rv32", NoSchedModel, []>;
-
-def : ProcessorModel<"generic-rv64", NoSchedModel, [Feature64Bit]>;
-
-//===----------------------------------------------------------------------===//
-// Define the RISC-V target.
-//===----------------------------------------------------------------------===//
-
-def RISCVInstrInfo : InstrInfo {
-  let guessInstructionProperties = 0;
-}
-
-def RISCVAsmParser : AsmParser {
-  let ShouldEmitMatchRegisterAltName = 1;
-  let AllowDuplicateRegisterNames = 1;
-}
-
-def RISCVAsmWriter : AsmWriter {
-  int PassSubtarget = 1;
-}
-
-def RISCV : Target {
-  let InstructionSet = RISCVInstrInfo;
-  let AssemblyParsers = [RISCVAsmParser];
-  let AssemblyWriters = [RISCVAsmWriter];
-  let AllowRegisterRenaming = 1;
-}
diff --git a/lib/Target/RISCV/RISCVAsmPrinter.cpp b/lib/Target/RISCV/RISCVAsmPrinter.cpp
deleted file mode 100644
index bdf8e5d840b..00000000000
--- a/lib/Target/RISCV/RISCVAsmPrinter.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-//===-- RISCVAsmPrinter.cpp - RISCV LLVM assembly writer ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains a printer that converts from our internal representation
-// of machine-dependent LLVM code to the RISCV assembly language.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "InstPrinter/RISCVInstPrinter.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/CodeGen/AsmPrinter.h"
-#include "llvm/CodeGen/MachineConstantPool.h"
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstr.h"
-#include "llvm/CodeGen/MachineModuleInfo.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/TargetRegistry.h"
-#include "llvm/Support/raw_ostream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "asm-printer"
-
-namespace {
-class RISCVAsmPrinter : public AsmPrinter {
-public:
-  explicit RISCVAsmPrinter(TargetMachine &TM,
-                           std::unique_ptr<MCStreamer> Streamer)
-      : AsmPrinter(TM, std::move(Streamer)) {}
-
-  StringRef getPassName() const override { return "RISCV Assembly Printer"; }
-
-  void EmitInstruction(const MachineInstr *MI) override;
-
-  bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
-                       unsigned AsmVariant, const char *ExtraCode,
-                       raw_ostream &OS) override;
-  bool PrintAsmMemoryOperand(const MachineInstr *MI, unsigned OpNo,
-                             unsigned AsmVariant, const char *ExtraCode,
-                             raw_ostream &OS) override;
-
-  void EmitToStreamer(MCStreamer &S, const MCInst &Inst);
-  bool emitPseudoExpansionLowering(MCStreamer &OutStreamer,
-                                   const MachineInstr *MI);
-
-  // Wrapper needed for tblgenned pseudo lowering.
-  bool lowerOperand(const MachineOperand &MO, MCOperand &MCOp) const {
-    return LowerRISCVMachineOperandToMCOperand(MO, MCOp, *this);
-  }
-};
-}
-
-#define GEN_COMPRESS_INSTR
-#include "RISCVGenCompressInstEmitter.inc"
-void RISCVAsmPrinter::EmitToStreamer(MCStreamer &S, const MCInst &Inst) {
-  MCInst CInst;
-  bool Res = compressInst(CInst, Inst, *TM.getMCSubtargetInfo(),
-                          OutStreamer->getContext());
-  AsmPrinter::EmitToStreamer(*OutStreamer, Res ? CInst : Inst);
-}
-
-// Simple pseudo-instructions have their lowering (with expansion to real
-// instructions) auto-generated.
-#include "RISCVGenMCPseudoLowering.inc"
-
-void RISCVAsmPrinter::EmitInstruction(const MachineInstr *MI) {
-  // Do any auto-generated pseudo lowerings.
-  if (emitPseudoExpansionLowering(*OutStreamer, MI))
-    return;
-
-  MCInst TmpInst;
-  LowerRISCVMachineInstrToMCInst(MI, TmpInst, *this);
-  EmitToStreamer(*OutStreamer, TmpInst);
-}
-
-bool RISCVAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
-                                      unsigned AsmVariant,
-                                      const char *ExtraCode, raw_ostream &OS) {
-  if (AsmVariant != 0)
-    report_fatal_error("There are no defined alternate asm variants");
-
-  // First try the generic code, which knows about modifiers like 'c' and 'n'.
-  if (!AsmPrinter::PrintAsmOperand(MI, OpNo, AsmVariant, ExtraCode, OS))
-    return false;
-
-  if (!ExtraCode) {
-    const MachineOperand &MO = MI->getOperand(OpNo);
-    switch (MO.getType()) {
-    case MachineOperand::MO_Immediate:
-      OS << MO.getImm();
-      return false;
-    case MachineOperand::MO_Register:
-      OS << RISCVInstPrinter::getRegisterName(MO.getReg());
-      return false;
-    default:
-      break;
-    }
-  }
-
-  return true;
-}
-
-bool RISCVAsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
-                                            unsigned OpNo, unsigned AsmVariant,
-                                            const char *ExtraCode,
-                                            raw_ostream &OS) {
-  if (AsmVariant != 0)
-    report_fatal_error("There are no defined alternate asm variants");
-
-  if (!ExtraCode) {
-    const MachineOperand &MO = MI->getOperand(OpNo);
-    // For now, we only support register memory operands in registers and
-    // assume there is no addend
-    if (!MO.isReg())
-      return true;
-
-    OS << "0(" << RISCVInstPrinter::getRegisterName(MO.getReg()) << ")";
-    return false;
-  }
-
-  return AsmPrinter::PrintAsmMemoryOperand(MI, OpNo, AsmVariant, ExtraCode, OS);
-}
-
-// Force static initialization.
-extern "C" void LLVMInitializeRISCVAsmPrinter() {
-  RegisterAsmPrinter<RISCVAsmPrinter> X(getTheRISCV32Target());
-  RegisterAsmPrinter<RISCVAsmPrinter> Y(getTheRISCV64Target());
-}
diff --git a/lib/Target/RISCV/RISCVCallingConv.td b/lib/Target/RISCV/RISCVCallingConv.td
deleted file mode 100644
index ef146258c38..00000000000
--- a/lib/Target/RISCV/RISCVCallingConv.td
+++ /dev/null
@@ -1,57 +0,0 @@
-//===-- RISCVCallingConv.td - Calling Conventions RISCV ----*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This describes the calling conventions for the RISCV architecture.
-//
-//===----------------------------------------------------------------------===//
-
-// The RISC-V calling convention is handled with custom code in
-// RISCVISelLowering.cpp (CC_RISCV).
-
-def CSR : CalleeSavedRegs<(add X1, X3, X4, X8, X9, (sequence "X%u", 18, 27))>;
-
-// Needed for implementation of RISCVRegisterInfo::getNoPreservedMask()
-def CSR_NoRegs : CalleeSavedRegs<(add)>;
-
-// Interrupt handler needs to save/restore all registers that are used,
-// both Caller and Callee saved registers.
-def CSR_Interrupt : CalleeSavedRegs<(add X1,
-    (sequence "X%u", 3, 9),
-    (sequence "X%u", 10, 11),
-    (sequence "X%u", 12, 17),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 28, 31))>;
-
-// Same as CSR_Interrupt, but including all 32-bit FP registers.
-def CSR_XLEN_F32_Interrupt: CalleeSavedRegs<(add X1,
-    (sequence "X%u", 3, 9),
-    (sequence "X%u", 10, 11),
-    (sequence "X%u", 12, 17),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 28, 31),
-    (sequence "F%u_32", 0, 7),
-    (sequence "F%u_32", 10, 11),
-    (sequence "F%u_32", 12, 17),
-    (sequence "F%u_32", 28, 31),
-    (sequence "F%u_32", 8, 9),
-    (sequence "F%u_32", 18, 27))>;
-
-// Same as CSR_Interrupt, but including all 64-bit FP registers.
-def CSR_XLEN_F64_Interrupt: CalleeSavedRegs<(add X1,
-    (sequence "X%u", 3, 9),
-    (sequence "X%u", 10, 11),
-    (sequence "X%u", 12, 17),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 28, 31),
-    (sequence "F%u_64", 0, 7),
-    (sequence "F%u_64", 10, 11),
-    (sequence "F%u_64", 12, 17),
-    (sequence "F%u_64", 28, 31),
-    (sequence "F%u_64", 8, 9),
-    (sequence "F%u_64", 18, 27))>;
diff --git a/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp b/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
deleted file mode 100644
index 35c185aa5ed..00000000000
--- a/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
+++ /dev/null
@@ -1,556 +0,0 @@
-//===-- RISCVExpandPseudoInsts.cpp - Expand pseudo instructions -----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains a pass that expands pseudo instructions into target
-// instructions. This pass should be run after register allocation but before
-// the post-regalloc scheduling pass.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "RISCVInstrInfo.h"
-#include "RISCVTargetMachine.h"
-
-#include "llvm/CodeGen/LivePhysRegs.h"
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-
-using namespace llvm;
-
-#define RISCV_EXPAND_PSEUDO_NAME "RISCV pseudo instruction expansion pass"
-
-namespace {
-
-class RISCVExpandPseudo : public MachineFunctionPass {
-public:
-  const RISCVInstrInfo *TII;
-  static char ID;
-
-  RISCVExpandPseudo() : MachineFunctionPass(ID) {
-    initializeRISCVExpandPseudoPass(*PassRegistry::getPassRegistry());
-  }
-
-  bool runOnMachineFunction(MachineFunction &MF) override;
-
-  StringRef getPassName() const override { return RISCV_EXPAND_PSEUDO_NAME; }
-
-private:
-  bool expandMBB(MachineBasicBlock &MBB);
-  bool expandMI(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                MachineBasicBlock::iterator &NextMBBI);
-  bool expandAtomicBinOp(MachineBasicBlock &MBB,
-                         MachineBasicBlock::iterator MBBI, AtomicRMWInst::BinOp,
-                         bool IsMasked, int Width,
-                         MachineBasicBlock::iterator &NextMBBI);
-  bool expandAtomicMinMaxOp(MachineBasicBlock &MBB,
-                            MachineBasicBlock::iterator MBBI,
-                            AtomicRMWInst::BinOp, bool IsMasked, int Width,
-                            MachineBasicBlock::iterator &NextMBBI);
-  bool expandAtomicCmpXchg(MachineBasicBlock &MBB,
-                           MachineBasicBlock::iterator MBBI, bool IsMasked,
-                           int Width, MachineBasicBlock::iterator &NextMBBI);
-};
-
-char RISCVExpandPseudo::ID = 0;
-
-bool RISCVExpandPseudo::runOnMachineFunction(MachineFunction &MF) {
-  TII = static_cast<const RISCVInstrInfo *>(MF.getSubtarget().getInstrInfo());
-  bool Modified = false;
-  for (auto &MBB : MF)
-    Modified |= expandMBB(MBB);
-  return Modified;
-}
-
-bool RISCVExpandPseudo::expandMBB(MachineBasicBlock &MBB) {
-  bool Modified = false;
-
-  MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
-  while (MBBI != E) {
-    MachineBasicBlock::iterator NMBBI = std::next(MBBI);
-    Modified |= expandMI(MBB, MBBI, NMBBI);
-    MBBI = NMBBI;
-  }
-
-  return Modified;
-}
-
-bool RISCVExpandPseudo::expandMI(MachineBasicBlock &MBB,
-                                 MachineBasicBlock::iterator MBBI,
-                                 MachineBasicBlock::iterator &NextMBBI) {
-  switch (MBBI->getOpcode()) {
-  case RISCV::PseudoAtomicLoadNand32:
-    return expandAtomicBinOp(MBB, MBBI, AtomicRMWInst::Nand, false, 32,
-                             NextMBBI);
-  case RISCV::PseudoMaskedAtomicSwap32:
-    return expandAtomicBinOp(MBB, MBBI, AtomicRMWInst::Xchg, true, 32,
-                             NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadAdd32:
-    return expandAtomicBinOp(MBB, MBBI, AtomicRMWInst::Add, true, 32, NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadSub32:
-    return expandAtomicBinOp(MBB, MBBI, AtomicRMWInst::Sub, true, 32, NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadNand32:
-    return expandAtomicBinOp(MBB, MBBI, AtomicRMWInst::Nand, true, 32,
-                             NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadMax32:
-    return expandAtomicMinMaxOp(MBB, MBBI, AtomicRMWInst::Max, true, 32,
-                                NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadMin32:
-    return expandAtomicMinMaxOp(MBB, MBBI, AtomicRMWInst::Min, true, 32,
-                                NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadUMax32:
-    return expandAtomicMinMaxOp(MBB, MBBI, AtomicRMWInst::UMax, true, 32,
-                                NextMBBI);
-  case RISCV::PseudoMaskedAtomicLoadUMin32:
-    return expandAtomicMinMaxOp(MBB, MBBI, AtomicRMWInst::UMin, true, 32,
-                                NextMBBI);
-  case RISCV::PseudoCmpXchg32:
-    return expandAtomicCmpXchg(MBB, MBBI, false, 32, NextMBBI);
-  case RISCV::PseudoMaskedCmpXchg32:
-    return expandAtomicCmpXchg(MBB, MBBI, true, 32, NextMBBI);
-  }
-
-  return false;
-}
-
-static unsigned getLRForRMW32(AtomicOrdering Ordering) {
-  switch (Ordering) {
-  default:
-    llvm_unreachable("Unexpected AtomicOrdering");
-  case AtomicOrdering::Monotonic:
-    return RISCV::LR_W;
-  case AtomicOrdering::Acquire:
-    return RISCV::LR_W_AQ;
-  case AtomicOrdering::Release:
-    return RISCV::LR_W;
-  case AtomicOrdering::AcquireRelease:
-    return RISCV::LR_W_AQ;
-  case AtomicOrdering::SequentiallyConsistent:
-    return RISCV::LR_W_AQ_RL;
-  }
-}
-
-static unsigned getSCForRMW32(AtomicOrdering Ordering) {
-  switch (Ordering) {
-  default:
-    llvm_unreachable("Unexpected AtomicOrdering");
-  case AtomicOrdering::Monotonic:
-    return RISCV::SC_W;
-  case AtomicOrdering::Acquire:
-    return RISCV::SC_W;
-  case AtomicOrdering::Release:
-    return RISCV::SC_W_RL;
-  case AtomicOrdering::AcquireRelease:
-    return RISCV::SC_W_RL;
-  case AtomicOrdering::SequentiallyConsistent:
-    return RISCV::SC_W_AQ_RL;
-  }
-}
-
-static void doAtomicBinOpExpansion(const RISCVInstrInfo *TII, MachineInstr &MI,
-                                   DebugLoc DL, MachineBasicBlock *ThisMBB,
-                                   MachineBasicBlock *LoopMBB,
-                                   MachineBasicBlock *DoneMBB,
-                                   AtomicRMWInst::BinOp BinOp, int Width) {
-  assert(Width == 32 && "RV64 atomic expansion currently unsupported");
-  unsigned DestReg = MI.getOperand(0).getReg();
-  unsigned ScratchReg = MI.getOperand(1).getReg();
-  unsigned AddrReg = MI.getOperand(2).getReg();
-  unsigned IncrReg = MI.getOperand(3).getReg();
-  AtomicOrdering Ordering =
-      static_cast<AtomicOrdering>(MI.getOperand(4).getImm());
-
-  // .loop:
-  //   lr.w dest, (addr)
-  //   binop scratch, dest, val
-  //   sc.w scratch, scratch, (addr)
-  //   bnez scratch, loop
-  BuildMI(LoopMBB, DL, TII->get(getLRForRMW32(Ordering)), DestReg)
-      .addReg(AddrReg);
-  switch (BinOp) {
-  default:
-    llvm_unreachable("Unexpected AtomicRMW BinOp");
-  case AtomicRMWInst::Nand:
-    BuildMI(LoopMBB, DL, TII->get(RISCV::AND), ScratchReg)
-        .addReg(DestReg)
-        .addReg(IncrReg);
-    BuildMI(LoopMBB, DL, TII->get(RISCV::XORI), ScratchReg)
-        .addReg(ScratchReg)
-        .addImm(-1);
-    break;
-  }
-  BuildMI(LoopMBB, DL, TII->get(getSCForRMW32(Ordering)), ScratchReg)
-      .addReg(AddrReg)
-      .addReg(ScratchReg);
-  BuildMI(LoopMBB, DL, TII->get(RISCV::BNE))
-      .addReg(ScratchReg)
-      .addReg(RISCV::X0)
-      .addMBB(LoopMBB);
-}
-
-static void insertMaskedMerge(const RISCVInstrInfo *TII, DebugLoc DL,
-                              MachineBasicBlock *MBB, unsigned DestReg,
-                              unsigned OldValReg, unsigned NewValReg,
-                              unsigned MaskReg, unsigned ScratchReg) {
-  assert(OldValReg != ScratchReg && "OldValReg and ScratchReg must be unique");
-  assert(OldValReg != MaskReg && "OldValReg and MaskReg must be unique");
-  assert(ScratchReg != MaskReg && "ScratchReg and MaskReg must be unique");
-
-  // We select bits from newval and oldval using:
-  // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
-  // r = oldval ^ ((oldval ^ newval) & masktargetdata);
-  BuildMI(MBB, DL, TII->get(RISCV::XOR), ScratchReg)
-      .addReg(OldValReg)
-      .addReg(NewValReg);
-  BuildMI(MBB, DL, TII->get(RISCV::AND), ScratchReg)
-      .addReg(ScratchReg)
-      .addReg(MaskReg);
-  BuildMI(MBB, DL, TII->get(RISCV::XOR), DestReg)
-      .addReg(OldValReg)
-      .addReg(ScratchReg);
-}
-
-static void doMaskedAtomicBinOpExpansion(
-    const RISCVInstrInfo *TII, MachineInstr &MI, DebugLoc DL,
-    MachineBasicBlock *ThisMBB, MachineBasicBlock *LoopMBB,
-    MachineBasicBlock *DoneMBB, AtomicRMWInst::BinOp BinOp, int Width) {
-  assert(Width == 32 && "RV64 atomic expansion currently unsupported");
-  unsigned DestReg = MI.getOperand(0).getReg();
-  unsigned ScratchReg = MI.getOperand(1).getReg();
-  unsigned AddrReg = MI.getOperand(2).getReg();
-  unsigned IncrReg = MI.getOperand(3).getReg();
-  unsigned MaskReg = MI.getOperand(4).getReg();
-  AtomicOrdering Ordering =
-      static_cast<AtomicOrdering>(MI.getOperand(5).getImm());
-
-  // .loop:
-  //   lr.w destreg, (alignedaddr)
-  //   binop scratch, destreg, incr
-  //   xor scratch, destreg, scratch
-  //   and scratch, scratch, masktargetdata
-  //   xor scratch, destreg, scratch
-  //   sc.w scratch, scratch, (alignedaddr)
-  //   bnez scratch, loop
-  BuildMI(LoopMBB, DL, TII->get(getLRForRMW32(Ordering)), DestReg)
-      .addReg(AddrReg);
-  switch (BinOp) {
-  default:
-    llvm_unreachable("Unexpected AtomicRMW BinOp");
-  case AtomicRMWInst::Xchg:
-    BuildMI(LoopMBB, DL, TII->get(RISCV::ADD), ScratchReg)
-        .addReg(RISCV::X0)
-        .addReg(IncrReg);
-    break;
-  case AtomicRMWInst::Add:
-    BuildMI(LoopMBB, DL, TII->get(RISCV::ADD), ScratchReg)
-        .addReg(DestReg)
-        .addReg(IncrReg);
-    break;
-  case AtomicRMWInst::Sub:
-    BuildMI(LoopMBB, DL, TII->get(RISCV::SUB), ScratchReg)
-        .addReg(DestReg)
-        .addReg(IncrReg);
-    break;
-  case AtomicRMWInst::Nand:
-    BuildMI(LoopMBB, DL, TII->get(RISCV::AND), ScratchReg)
-        .addReg(DestReg)
-        .addReg(IncrReg);
-    BuildMI(LoopMBB, DL, TII->get(RISCV::XORI), ScratchReg)
-        .addReg(ScratchReg)
-        .addImm(-1);
-    break;
-  }
-
-  insertMaskedMerge(TII, DL, LoopMBB, ScratchReg, DestReg, ScratchReg, MaskReg,
-                    ScratchReg);
-
-  BuildMI(LoopMBB, DL, TII->get(getSCForRMW32(Ordering)), ScratchReg)
-      .addReg(AddrReg)
-      .addReg(ScratchReg);
-  BuildMI(LoopMBB, DL, TII->get(RISCV::BNE))
-      .addReg(ScratchReg)
-      .addReg(RISCV::X0)
-      .addMBB(LoopMBB);
-}
-
-bool RISCVExpandPseudo::expandAtomicBinOp(
-    MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-    AtomicRMWInst::BinOp BinOp, bool IsMasked, int Width,
-    MachineBasicBlock::iterator &NextMBBI) {
-  MachineInstr &MI = *MBBI;
-  DebugLoc DL = MI.getDebugLoc();
-
-  MachineFunction *MF = MBB.getParent();
-  auto LoopMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto DoneMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-
-  // Insert new MBBs.
-  MF->insert(++MBB.getIterator(), LoopMBB);
-  MF->insert(++LoopMBB->getIterator(), DoneMBB);
-
-  // Set up successors and transfer remaining instructions to DoneMBB.
-  LoopMBB->addSuccessor(LoopMBB);
-  LoopMBB->addSuccessor(DoneMBB);
-  DoneMBB->splice(DoneMBB->end(), &MBB, MI, MBB.end());
-  DoneMBB->transferSuccessors(&MBB);
-  MBB.addSuccessor(LoopMBB);
-
-  if (!IsMasked)
-    doAtomicBinOpExpansion(TII, MI, DL, &MBB, LoopMBB, DoneMBB, BinOp, Width);
-  else
-    doMaskedAtomicBinOpExpansion(TII, MI, DL, &MBB, LoopMBB, DoneMBB, BinOp,
-                                 Width);
-
-  NextMBBI = MBB.end();
-  MI.eraseFromParent();
-
-  LivePhysRegs LiveRegs;
-  computeAndAddLiveIns(LiveRegs, *LoopMBB);
-  computeAndAddLiveIns(LiveRegs, *DoneMBB);
-
-  return true;
-}
-
-static void insertSext(const RISCVInstrInfo *TII, DebugLoc DL,
-                       MachineBasicBlock *MBB, unsigned ValReg,
-                       unsigned ShamtReg) {
-  BuildMI(MBB, DL, TII->get(RISCV::SLL), ValReg)
-      .addReg(ValReg)
-      .addReg(ShamtReg);
-  BuildMI(MBB, DL, TII->get(RISCV::SRA), ValReg)
-      .addReg(ValReg)
-      .addReg(ShamtReg);
-}
-
-bool RISCVExpandPseudo::expandAtomicMinMaxOp(
-    MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-    AtomicRMWInst::BinOp BinOp, bool IsMasked, int Width,
-    MachineBasicBlock::iterator &NextMBBI) {
-  assert(IsMasked == true &&
-         "Should only need to expand masked atomic max/min");
-  assert(Width == 32 && "RV64 atomic expansion currently unsupported");
-
-  MachineInstr &MI = *MBBI;
-  DebugLoc DL = MI.getDebugLoc();
-  MachineFunction *MF = MBB.getParent();
-  auto LoopHeadMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto LoopIfBodyMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto LoopTailMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto DoneMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-
-  // Insert new MBBs.
-  MF->insert(++MBB.getIterator(), LoopHeadMBB);
-  MF->insert(++LoopHeadMBB->getIterator(), LoopIfBodyMBB);
-  MF->insert(++LoopIfBodyMBB->getIterator(), LoopTailMBB);
-  MF->insert(++LoopTailMBB->getIterator(), DoneMBB);
-
-  // Set up successors and transfer remaining instructions to DoneMBB.
-  LoopHeadMBB->addSuccessor(LoopIfBodyMBB);
-  LoopHeadMBB->addSuccessor(LoopTailMBB);
-  LoopIfBodyMBB->addSuccessor(LoopTailMBB);
-  LoopTailMBB->addSuccessor(LoopHeadMBB);
-  LoopTailMBB->addSuccessor(DoneMBB);
-  DoneMBB->splice(DoneMBB->end(), &MBB, MI, MBB.end());
-  DoneMBB->transferSuccessors(&MBB);
-  MBB.addSuccessor(LoopHeadMBB);
-
-  unsigned DestReg = MI.getOperand(0).getReg();
-  unsigned Scratch1Reg = MI.getOperand(1).getReg();
-  unsigned Scratch2Reg = MI.getOperand(2).getReg();
-  unsigned AddrReg = MI.getOperand(3).getReg();
-  unsigned IncrReg = MI.getOperand(4).getReg();
-  unsigned MaskReg = MI.getOperand(5).getReg();
-  bool IsSigned = BinOp == AtomicRMWInst::Min || BinOp == AtomicRMWInst::Max;
-  AtomicOrdering Ordering =
-      static_cast<AtomicOrdering>(MI.getOperand(IsSigned ? 7 : 6).getImm());
-
-  //
-  // .loophead:
-  //   lr.w destreg, (alignedaddr)
-  //   and scratch2, destreg, mask
-  //   mv scratch1, destreg
-  //   [sext scratch2 if signed min/max]
-  //   ifnochangeneeded scratch2, incr, .looptail
-  BuildMI(LoopHeadMBB, DL, TII->get(getLRForRMW32(Ordering)), DestReg)
-      .addReg(AddrReg);
-  BuildMI(LoopHeadMBB, DL, TII->get(RISCV::AND), Scratch2Reg)
-      .addReg(DestReg)
-      .addReg(MaskReg);
-  BuildMI(LoopHeadMBB, DL, TII->get(RISCV::ADDI), Scratch1Reg)
-      .addReg(DestReg)
-      .addImm(0);
-
-  switch (BinOp) {
-  default:
-    llvm_unreachable("Unexpected AtomicRMW BinOp");
-  case AtomicRMWInst::Max: {
-    insertSext(TII, DL, LoopHeadMBB, Scratch2Reg, MI.getOperand(6).getReg());
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BGE))
-        .addReg(Scratch2Reg)
-        .addReg(IncrReg)
-        .addMBB(LoopTailMBB);
-    break;
-  }
-  case AtomicRMWInst::Min: {
-    insertSext(TII, DL, LoopHeadMBB, Scratch2Reg, MI.getOperand(6).getReg());
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BGE))
-        .addReg(IncrReg)
-        .addReg(Scratch2Reg)
-        .addMBB(LoopTailMBB);
-    break;
-  }
-  case AtomicRMWInst::UMax:
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BGEU))
-        .addReg(Scratch2Reg)
-        .addReg(IncrReg)
-        .addMBB(LoopTailMBB);
-    break;
-  case AtomicRMWInst::UMin:
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BGEU))
-        .addReg(IncrReg)
-        .addReg(Scratch2Reg)
-        .addMBB(LoopTailMBB);
-    break;
-  }
-
-  // .loopifbody:
-  //   xor scratch1, destreg, incr
-  //   and scratch1, scratch1, mask
-  //   xor scratch1, destreg, scratch1
-  insertMaskedMerge(TII, DL, LoopIfBodyMBB, Scratch1Reg, DestReg, IncrReg,
-                    MaskReg, Scratch1Reg);
-
-  // .looptail:
-  //   sc.w scratch1, scratch1, (addr)
-  //   bnez scratch1, loop
-  BuildMI(LoopTailMBB, DL, TII->get(getSCForRMW32(Ordering)), Scratch1Reg)
-      .addReg(AddrReg)
-      .addReg(Scratch1Reg);
-  BuildMI(LoopTailMBB, DL, TII->get(RISCV::BNE))
-      .addReg(Scratch1Reg)
-      .addReg(RISCV::X0)
-      .addMBB(LoopHeadMBB);
-
-  NextMBBI = MBB.end();
-  MI.eraseFromParent();
-
-  LivePhysRegs LiveRegs;
-  computeAndAddLiveIns(LiveRegs, *LoopHeadMBB);
-  computeAndAddLiveIns(LiveRegs, *LoopIfBodyMBB);
-  computeAndAddLiveIns(LiveRegs, *LoopTailMBB);
-  computeAndAddLiveIns(LiveRegs, *DoneMBB);
-
-  return true;
-}
-
-bool RISCVExpandPseudo::expandAtomicCmpXchg(
-    MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI, bool IsMasked,
-    int Width, MachineBasicBlock::iterator &NextMBBI) {
-  assert(Width == 32 && "RV64 atomic expansion currently unsupported");
-  MachineInstr &MI = *MBBI;
-  DebugLoc DL = MI.getDebugLoc();
-  MachineFunction *MF = MBB.getParent();
-  auto LoopHeadMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto LoopTailMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-  auto DoneMBB = MF->CreateMachineBasicBlock(MBB.getBasicBlock());
-
-  // Insert new MBBs.
-  MF->insert(++MBB.getIterator(), LoopHeadMBB);
-  MF->insert(++LoopHeadMBB->getIterator(), LoopTailMBB);
-  MF->insert(++LoopTailMBB->getIterator(), DoneMBB);
-
-  // Set up successors and transfer remaining instructions to DoneMBB.
-  LoopHeadMBB->addSuccessor(LoopTailMBB);
-  LoopHeadMBB->addSuccessor(DoneMBB);
-  LoopTailMBB->addSuccessor(DoneMBB);
-  LoopTailMBB->addSuccessor(LoopHeadMBB);
-  DoneMBB->splice(DoneMBB->end(), &MBB, MI, MBB.end());
-  DoneMBB->transferSuccessors(&MBB);
-  MBB.addSuccessor(LoopHeadMBB);
-
-  unsigned DestReg = MI.getOperand(0).getReg();
-  unsigned ScratchReg = MI.getOperand(1).getReg();
-  unsigned AddrReg = MI.getOperand(2).getReg();
-  unsigned CmpValReg = MI.getOperand(3).getReg();
-  unsigned NewValReg = MI.getOperand(4).getReg();
-  AtomicOrdering Ordering =
-      static_cast<AtomicOrdering>(MI.getOperand(IsMasked ? 6 : 5).getImm());
-
-  if (!IsMasked) {
-    // .loophead:
-    //   lr.w dest, (addr)
-    //   bne dest, cmpval, done
-    BuildMI(LoopHeadMBB, DL, TII->get(getLRForRMW32(Ordering)), DestReg)
-        .addReg(AddrReg);
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BNE))
-        .addReg(DestReg)
-        .addReg(CmpValReg)
-        .addMBB(DoneMBB);
-    // .looptail:
-    //   sc.w scratch, newval, (addr)
-    //   bnez scratch, loophead
-    BuildMI(LoopTailMBB, DL, TII->get(getSCForRMW32(Ordering)), ScratchReg)
-        .addReg(AddrReg)
-        .addReg(NewValReg);
-    BuildMI(LoopTailMBB, DL, TII->get(RISCV::BNE))
-        .addReg(ScratchReg)
-        .addReg(RISCV::X0)
-        .addMBB(LoopHeadMBB);
-  } else {
-    // .loophead:
-    //   lr.w dest, (addr)
-    //   and scratch, dest, mask
-    //   bne scratch, cmpval, done
-    unsigned MaskReg = MI.getOperand(5).getReg();
-    BuildMI(LoopHeadMBB, DL, TII->get(getLRForRMW32(Ordering)), DestReg)
-        .addReg(AddrReg);
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::AND), ScratchReg)
-        .addReg(DestReg)
-        .addReg(MaskReg);
-    BuildMI(LoopHeadMBB, DL, TII->get(RISCV::BNE))
-        .addReg(ScratchReg)
-        .addReg(CmpValReg)
-        .addMBB(DoneMBB);
-
-    // .looptail:
-    //   xor scratch, dest, newval
-    //   and scratch, scratch, mask
-    //   xor scratch, dest, scratch
-    //   sc.w scratch, scratch, (adrr)
-    //   bnez scratch, loophead
-    insertMaskedMerge(TII, DL, LoopTailMBB, ScratchReg, DestReg, NewValReg,
-                      MaskReg, ScratchReg);
-    BuildMI(LoopTailMBB, DL, TII->get(getSCForRMW32(Ordering)), ScratchReg)
-        .addReg(AddrReg)
-        .addReg(ScratchReg);
-    BuildMI(LoopTailMBB, DL, TII->get(RISCV::BNE))
-        .addReg(ScratchReg)
-        .addReg(RISCV::X0)
-        .addMBB(LoopHeadMBB);
-  }
-
-  NextMBBI = MBB.end();
-  MI.eraseFromParent();
-
-  LivePhysRegs LiveRegs;
-  computeAndAddLiveIns(LiveRegs, *LoopHeadMBB);
-  computeAndAddLiveIns(LiveRegs, *LoopTailMBB);
-  computeAndAddLiveIns(LiveRegs, *DoneMBB);
-
-  return true;
-}
-
-} // end of anonymous namespace
-
-INITIALIZE_PASS(RISCVExpandPseudo, "riscv-expand-pseudo",
-                RISCV_EXPAND_PSEUDO_NAME, false, false)
-namespace llvm {
-
-FunctionPass *createRISCVExpandPseudoPass() { return new RISCVExpandPseudo(); }
-
-} // end of namespace llvm
diff --git a/lib/Target/RISCV/RISCVFrameLowering.cpp b/lib/Target/RISCV/RISCVFrameLowering.cpp
deleted file mode 100644
index 74417899c8d..00000000000
--- a/lib/Target/RISCV/RISCVFrameLowering.cpp
+++ /dev/null
@@ -1,298 +0,0 @@
-//===-- RISCVFrameLowering.cpp - RISCV Frame Information ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of TargetFrameLowering class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVFrameLowering.h"
-#include "RISCVMachineFunctionInfo.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-
-using namespace llvm;
-
-bool RISCVFrameLowering::hasFP(const MachineFunction &MF) const {
-  const TargetRegisterInfo *RegInfo = MF.getSubtarget().getRegisterInfo();
-
-  const MachineFrameInfo &MFI = MF.getFrameInfo();
-  return MF.getTarget().Options.DisableFramePointerElim(MF) ||
-         RegInfo->needsStackRealignment(MF) || MFI.hasVarSizedObjects() ||
-         MFI.isFrameAddressTaken();
-}
-
-// Determines the size of the frame and maximum call frame size.
-void RISCVFrameLowering::determineFrameLayout(MachineFunction &MF) const {
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  const RISCVRegisterInfo *RI = STI.getRegisterInfo();
-
-  // Get the number of bytes to allocate from the FrameInfo.
-  uint64_t FrameSize = MFI.getStackSize();
-
-  // Get the alignment.
-  uint64_t StackAlign = RI->needsStackRealignment(MF) ? MFI.getMaxAlignment()
-                                                      : getStackAlignment();
-
-  // Make sure the frame is aligned.
-  FrameSize = alignTo(FrameSize, StackAlign);
-
-  // Update frame info.
-  MFI.setStackSize(FrameSize);
-}
-
-void RISCVFrameLowering::adjustReg(MachineBasicBlock &MBB,
-                                   MachineBasicBlock::iterator MBBI,
-                                   const DebugLoc &DL, unsigned DestReg,
-                                   unsigned SrcReg, int64_t Val,
-                                   MachineInstr::MIFlag Flag) const {
-  MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();
-  const RISCVInstrInfo *TII = STI.getInstrInfo();
-
-  if (DestReg == SrcReg && Val == 0)
-    return;
-
-  if (isInt<12>(Val)) {
-    BuildMI(MBB, MBBI, DL, TII->get(RISCV::ADDI), DestReg)
-        .addReg(SrcReg)
-        .addImm(Val)
-        .setMIFlag(Flag);
-  } else if (isInt<32>(Val)) {
-    unsigned Opc = RISCV::ADD;
-    bool isSub = Val < 0;
-    if (isSub) {
-      Val = -Val;
-      Opc = RISCV::SUB;
-    }
-
-    unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-    TII->movImm32(MBB, MBBI, DL, ScratchReg, Val, Flag);
-    BuildMI(MBB, MBBI, DL, TII->get(Opc), DestReg)
-        .addReg(SrcReg)
-        .addReg(ScratchReg, RegState::Kill)
-        .setMIFlag(Flag);
-  } else {
-    report_fatal_error("adjustReg cannot yet handle adjustments >32 bits");
-  }
-}
-
-// Returns the register used to hold the frame pointer.
-static unsigned getFPReg(const RISCVSubtarget &STI) { return RISCV::X8; }
-
-// Returns the register used to hold the stack pointer.
-static unsigned getSPReg(const RISCVSubtarget &STI) { return RISCV::X2; }
-
-void RISCVFrameLowering::emitPrologue(MachineFunction &MF,
-                                      MachineBasicBlock &MBB) const {
-  assert(&MF.front() == &MBB && "Shrink-wrapping not yet supported");
-
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-  MachineBasicBlock::iterator MBBI = MBB.begin();
-
-  unsigned FPReg = getFPReg(STI);
-  unsigned SPReg = getSPReg(STI);
-
-  // Debug location must be unknown since the first debug location is used
-  // to determine the end of the prologue.
-  DebugLoc DL;
-
-  // Determine the correct frame layout
-  determineFrameLayout(MF);
-
-  // FIXME (note copied from Lanai): This appears to be overallocating.  Needs
-  // investigation. Get the number of bytes to allocate from the FrameInfo.
-  uint64_t StackSize = MFI.getStackSize();
-
-  // Early exit if there is no need to allocate on the stack
-  if (StackSize == 0 && !MFI.adjustsStack())
-    return;
-
-  // Allocate space on the stack if necessary.
-  adjustReg(MBB, MBBI, DL, SPReg, SPReg, -StackSize, MachineInstr::FrameSetup);
-
-  // The frame pointer is callee-saved, and code has been generated for us to
-  // save it to the stack. We need to skip over the storing of callee-saved
-  // registers as the frame pointer must be modified after it has been saved
-  // to the stack, not before.
-  // FIXME: assumes exactly one instruction is used to save each callee-saved
-  // register.
-  const std::vector<CalleeSavedInfo> &CSI = MFI.getCalleeSavedInfo();
-  std::advance(MBBI, CSI.size());
-
-  // Generate new FP.
-  if (hasFP(MF))
-    adjustReg(MBB, MBBI, DL, FPReg, SPReg,
-              StackSize - RVFI->getVarArgsSaveSize(), MachineInstr::FrameSetup);
-}
-
-void RISCVFrameLowering::emitEpilogue(MachineFunction &MF,
-                                      MachineBasicBlock &MBB) const {
-  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
-  const RISCVRegisterInfo *RI = STI.getRegisterInfo();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-  DebugLoc DL = MBBI->getDebugLoc();
-  unsigned FPReg = getFPReg(STI);
-  unsigned SPReg = getSPReg(STI);
-
-  // Skip to before the restores of callee-saved registers
-  // FIXME: assumes exactly one instruction is used to restore each
-  // callee-saved register.
-  auto LastFrameDestroy = std::prev(MBBI, MFI.getCalleeSavedInfo().size());
-
-  uint64_t StackSize = MFI.getStackSize();
-
-  // Restore the stack pointer using the value of the frame pointer. Only
-  // necessary if the stack pointer was modified, meaning the stack size is
-  // unknown.
-  if (RI->needsStackRealignment(MF) || MFI.hasVarSizedObjects()) {
-    assert(hasFP(MF) && "frame pointer should not have been eliminated");
-    adjustReg(MBB, LastFrameDestroy, DL, SPReg, FPReg,
-              -StackSize + RVFI->getVarArgsSaveSize(),
-              MachineInstr::FrameDestroy);
-  }
-
-  // Deallocate stack
-  adjustReg(MBB, MBBI, DL, SPReg, SPReg, StackSize, MachineInstr::FrameDestroy);
-}
-
-int RISCVFrameLowering::getFrameIndexReference(const MachineFunction &MF,
-                                               int FI,
-                                               unsigned &FrameReg) const {
-  const MachineFrameInfo &MFI = MF.getFrameInfo();
-  const TargetRegisterInfo *RI = MF.getSubtarget().getRegisterInfo();
-  const auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-
-  // Callee-saved registers should be referenced relative to the stack
-  // pointer (positive offset), otherwise use the frame pointer (negative
-  // offset).
-  const std::vector<CalleeSavedInfo> &CSI = MFI.getCalleeSavedInfo();
-  int MinCSFI = 0;
-  int MaxCSFI = -1;
-
-  int Offset = MFI.getObjectOffset(FI) - getOffsetOfLocalArea() +
-               MFI.getOffsetAdjustment();
-
-  if (CSI.size()) {
-    MinCSFI = CSI[0].getFrameIdx();
-    MaxCSFI = CSI[CSI.size() - 1].getFrameIdx();
-  }
-
-  if (FI >= MinCSFI && FI <= MaxCSFI) {
-    FrameReg = RISCV::X2;
-    Offset += MF.getFrameInfo().getStackSize();
-  } else {
-    FrameReg = RI->getFrameRegister(MF);
-    if (hasFP(MF))
-      Offset += RVFI->getVarArgsSaveSize();
-    else
-      Offset += MF.getFrameInfo().getStackSize();
-  }
-  return Offset;
-}
-
-void RISCVFrameLowering::determineCalleeSaves(MachineFunction &MF,
-                                              BitVector &SavedRegs,
-                                              RegScavenger *RS) const {
-  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);
-  // Unconditionally spill RA and FP only if the function uses a frame
-  // pointer.
-  if (hasFP(MF)) {
-    SavedRegs.set(RISCV::X1);
-    SavedRegs.set(RISCV::X8);
-  }
-
-  // If interrupt is enabled and there are calls in the handler,
-  // unconditionally save all Caller-saved registers and
-  // all FP registers, regardless whether they are used.
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-
-  if (MF.getFunction().hasFnAttribute("interrupt") && MFI.hasCalls()) {
-
-    static const MCPhysReg CSRegs[] = { RISCV::X1,      /* ra */
-      RISCV::X5, RISCV::X6, RISCV::X7,                  /* t0-t2 */
-      RISCV::X10, RISCV::X11,                           /* a0-a1, a2-a7 */
-      RISCV::X12, RISCV::X13, RISCV::X14, RISCV::X15, RISCV::X16, RISCV::X17,
-      RISCV::X28, RISCV::X29, RISCV::X30, RISCV::X31, 0 /* t3-t6 */
-    };
-
-    for (unsigned i = 0; CSRegs[i]; ++i)
-      SavedRegs.set(CSRegs[i]);
-
-    if (MF.getSubtarget<RISCVSubtarget>().hasStdExtD() ||
-        MF.getSubtarget<RISCVSubtarget>().hasStdExtF()) {
-
-      // If interrupt is enabled, this list contains all FP registers.
-      const MCPhysReg * Regs = MF.getRegInfo().getCalleeSavedRegs();
-
-      for (unsigned i = 0; Regs[i]; ++i)
-        if (RISCV::FPR32RegClass.contains(Regs[i]) ||
-            RISCV::FPR64RegClass.contains(Regs[i]))
-          SavedRegs.set(Regs[i]);
-    }
-  }
-}
-
-void RISCVFrameLowering::processFunctionBeforeFrameFinalized(
-    MachineFunction &MF, RegScavenger *RS) const {
-  const TargetRegisterInfo *RegInfo = MF.getSubtarget().getRegisterInfo();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  const TargetRegisterClass *RC = &RISCV::GPRRegClass;
-  // estimateStackSize has been observed to under-estimate the final stack
-  // size, so give ourselves wiggle-room by checking for stack size
-  // representable an 11-bit signed field rather than 12-bits.
-  // FIXME: It may be possible to craft a function with a small stack that
-  // still needs an emergency spill slot for branch relaxation. This case
-  // would currently be missed.
-  if (!isInt<11>(MFI.estimateStackSize(MF))) {
-    int RegScavFI = MFI.CreateStackObject(
-        RegInfo->getSpillSize(*RC), RegInfo->getSpillAlignment(*RC), false);
-    RS->addScavengingFrameIndex(RegScavFI);
-  }
-}
-
-// Not preserve stack space within prologue for outgoing variables when the
-// function contains variable size objects and let eliminateCallFramePseudoInstr
-// preserve stack space for it.
-bool RISCVFrameLowering::hasReservedCallFrame(const MachineFunction &MF) const {
-  return !MF.getFrameInfo().hasVarSizedObjects();
-}
-
-// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions.
-MachineBasicBlock::iterator RISCVFrameLowering::eliminateCallFramePseudoInstr(
-    MachineFunction &MF, MachineBasicBlock &MBB,
-    MachineBasicBlock::iterator MI) const {
-  unsigned SPReg = RISCV::X2;
-  DebugLoc DL = MI->getDebugLoc();
-
-  if (!hasReservedCallFrame(MF)) {
-    // If space has not been reserved for a call frame, ADJCALLSTACKDOWN and
-    // ADJCALLSTACKUP must be converted to instructions manipulating the stack
-    // pointer. This is necessary when there is a variable length stack
-    // allocation (e.g. alloca), which means it's not possible to allocate
-    // space for outgoing arguments from within the function prologue.
-    int64_t Amount = MI->getOperand(0).getImm();
-
-    if (Amount != 0) {
-      // Ensure the stack remains aligned after adjustment.
-      Amount = alignSPAdjust(Amount);
-
-      if (MI->getOpcode() == RISCV::ADJCALLSTACKDOWN)
-        Amount = -Amount;
-
-      adjustReg(MBB, MI, DL, SPReg, SPReg, Amount, MachineInstr::NoFlags);
-    }
-  }
-
-  return MBB.erase(MI);
-}
diff --git a/lib/Target/RISCV/RISCVFrameLowering.h b/lib/Target/RISCV/RISCVFrameLowering.h
deleted file mode 100644
index ca653c2b9f1..00000000000
--- a/lib/Target/RISCV/RISCVFrameLowering.h
+++ /dev/null
@@ -1,59 +0,0 @@
-//===-- RISCVFrameLowering.h - Define frame lowering for RISCV -*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class implements RISCV-specific bits of TargetFrameLowering class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVFRAMELOWERING_H
-#define LLVM_LIB_TARGET_RISCV_RISCVFRAMELOWERING_H
-
-#include "llvm/CodeGen/TargetFrameLowering.h"
-
-namespace llvm {
-class RISCVSubtarget;
-
-class RISCVFrameLowering : public TargetFrameLowering {
-public:
-  explicit RISCVFrameLowering(const RISCVSubtarget &STI)
-      : TargetFrameLowering(StackGrowsDown,
-                            /*StackAlignment=*/16,
-                            /*LocalAreaOffset=*/0),
-        STI(STI) {}
-
-  void emitPrologue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
-  void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
-
-  int getFrameIndexReference(const MachineFunction &MF, int FI,
-                             unsigned &FrameReg) const override;
-
-  void determineCalleeSaves(MachineFunction &MF, BitVector &SavedRegs,
-                            RegScavenger *RS) const override;
-
-  void processFunctionBeforeFrameFinalized(MachineFunction &MF,
-                                           RegScavenger *RS) const override;
-
-  bool hasFP(const MachineFunction &MF) const override;
-
-  bool hasReservedCallFrame(const MachineFunction &MF) const override;
-  MachineBasicBlock::iterator
-  eliminateCallFramePseudoInstr(MachineFunction &MF, MachineBasicBlock &MBB,
-                                MachineBasicBlock::iterator MI) const override;
-
-protected:
-  const RISCVSubtarget &STI;
-
-private:
-  void determineFrameLayout(MachineFunction &MF) const;
-  void adjustReg(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                 const DebugLoc &DL, unsigned DestReg, unsigned SrcReg,
-                 int64_t Val, MachineInstr::MIFlag Flag) const;
-};
-}
-#endif
diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
deleted file mode 100644
index aa80365feb8..00000000000
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ /dev/null
@@ -1,282 +0,0 @@
-//===-- RISCVISelDAGToDAG.cpp - A dag to dag inst selector for RISCV ------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines an instruction selector for the RISCV target.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "RISCV.h"
-#include "RISCVTargetMachine.h"
-#include "Utils/RISCVMatInt.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/SelectionDAGISel.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/MathExtras.h"
-#include "llvm/Support/raw_ostream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-isel"
-
-// RISCV-specific code to select RISCV machine instructions for
-// SelectionDAG operations.
-namespace {
-class RISCVDAGToDAGISel final : public SelectionDAGISel {
-  const RISCVSubtarget *Subtarget;
-
-public:
-  explicit RISCVDAGToDAGISel(RISCVTargetMachine &TargetMachine)
-      : SelectionDAGISel(TargetMachine) {}
-
-  StringRef getPassName() const override {
-    return "RISCV DAG->DAG Pattern Instruction Selection";
-  }
-
-  bool runOnMachineFunction(MachineFunction &MF) override {
-    Subtarget = &MF.getSubtarget<RISCVSubtarget>();
-    return SelectionDAGISel::runOnMachineFunction(MF);
-  }
-
-  void PostprocessISelDAG() override;
-
-  void Select(SDNode *Node) override;
-
-  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
-                                    std::vector<SDValue> &OutOps) override;
-
-  bool SelectAddrFI(SDValue Addr, SDValue &Base);
-
-// Include the pieces autogenerated from the target description.
-#include "RISCVGenDAGISel.inc"
-
-private:
-  void doPeepholeLoadStoreADDI();
-};
-}
-
-void RISCVDAGToDAGISel::PostprocessISelDAG() {
-  doPeepholeLoadStoreADDI();
-}
-
-static SDNode *selectImm(SelectionDAG *CurDAG, const SDLoc &DL, int64_t Imm,
-                         MVT XLenVT) {
-  RISCVMatInt::InstSeq Seq;
-  RISCVMatInt::generateInstSeq(Imm, XLenVT == MVT::i64, Seq);
-
-  SDNode *Result;
-  SDValue SrcReg = CurDAG->getRegister(RISCV::X0, XLenVT);
-  for (RISCVMatInt::Inst &Inst : Seq) {
-    SDValue SDImm = CurDAG->getTargetConstant(Inst.Imm, DL, XLenVT);
-    if (Inst.Opc == RISCV::LUI)
-      Result = CurDAG->getMachineNode(RISCV::LUI, DL, XLenVT, SDImm);
-    else
-      Result = CurDAG->getMachineNode(Inst.Opc, DL, XLenVT, SrcReg, SDImm);
-
-    // Only the first instruction has X0 as its source.
-    SrcReg = SDValue(Result, 0);
-  }
-
-  return Result;
-}
-
-// Returns true if the Node is an ISD::AND with a constant argument. If so,
-// set Mask to that constant value.
-static bool isConstantMask(SDNode *Node, uint64_t &Mask) {
-  if (Node->getOpcode() == ISD::AND &&
-      Node->getOperand(1).getOpcode() == ISD::Constant) {
-    Mask = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
-    return true;
-  }
-  return false;
-}
-
-void RISCVDAGToDAGISel::Select(SDNode *Node) {
-  // If we have a custom node, we have already selected.
-  if (Node->isMachineOpcode()) {
-    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
-    Node->setNodeId(-1);
-    return;
-  }
-
-  // Instruction Selection not handled by the auto-generated tablegen selection
-  // should be handled here.
-  unsigned Opcode = Node->getOpcode();
-  MVT XLenVT = Subtarget->getXLenVT();
-  SDLoc DL(Node);
-  EVT VT = Node->getValueType(0);
-
-  switch (Opcode) {
-  case ISD::Constant: {
-    auto ConstNode = cast<ConstantSDNode>(Node);
-    if (VT == XLenVT && ConstNode->isNullValue()) {
-      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
-                                           RISCV::X0, XLenVT);
-      ReplaceNode(Node, New.getNode());
-      return;
-    }
-    int64_t Imm = ConstNode->getSExtValue();
-    if (XLenVT == MVT::i64) {
-      ReplaceNode(Node, selectImm(CurDAG, SDLoc(Node), Imm, XLenVT));
-      return;
-    }
-    break;
-  }
-  case ISD::FrameIndex: {
-    SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
-    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
-    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
-    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::ADDI, DL, VT, TFI, Imm));
-    return;
-  }
-  case ISD::SRL: {
-    if (!Subtarget->is64Bit())
-      break;
-    SDValue Op0 = Node->getOperand(0);
-    SDValue Op1 = Node->getOperand(1);
-    uint64_t Mask;
-    // Match (srl (and val, mask), imm) where the result would be a
-    // zero-extended 32-bit integer. i.e. the mask is 0xffffffff or the result
-    // is equivalent to this (SimplifyDemandedBits may have removed lower bits
-    // from the mask that aren't necessary due to the right-shifting).
-    if (Op1.getOpcode() == ISD::Constant &&
-        isConstantMask(Op0.getNode(), Mask)) {
-      uint64_t ShAmt = cast<ConstantSDNode>(Op1.getNode())->getZExtValue();
-
-      if ((Mask | maskTrailingOnes<uint64_t>(ShAmt)) == 0xffffffff) {
-        SDValue ShAmtVal =
-            CurDAG->getTargetConstant(ShAmt, SDLoc(Node), XLenVT);
-        CurDAG->SelectNodeTo(Node, RISCV::SRLIW, XLenVT, Op0.getOperand(0),
-                             ShAmtVal);
-        return;
-      }
-    }
-  }
-  }
-
-  // Select the default instruction.
-  SelectCode(Node);
-}
-
-bool RISCVDAGToDAGISel::SelectInlineAsmMemoryOperand(
-    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
-  switch (ConstraintID) {
-  case InlineAsm::Constraint_i:
-  case InlineAsm::Constraint_m:
-    // We just support simple memory operands that have a single address
-    // operand and need no special handling.
-    OutOps.push_back(Op);
-    return false;
-  default:
-    break;
-  }
-
-  return true;
-}
-
-bool RISCVDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
-  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
-    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Subtarget->getXLenVT());
-    return true;
-  }
-  return false;
-}
-
-// Merge an ADDI into the offset of a load/store instruction where possible.
-// (load (add base, off), 0) -> (load base, off)
-// (store val, (add base, off)) -> (store val, base, off)
-void RISCVDAGToDAGISel::doPeepholeLoadStoreADDI() {
-  SelectionDAG::allnodes_iterator Position(CurDAG->getRoot().getNode());
-  ++Position;
-
-  while (Position != CurDAG->allnodes_begin()) {
-    SDNode *N = &*--Position;
-    // Skip dead nodes and any non-machine opcodes.
-    if (N->use_empty() || !N->isMachineOpcode())
-      continue;
-
-    int OffsetOpIdx;
-    int BaseOpIdx;
-
-    // Only attempt this optimisation for I-type loads and S-type stores.
-    switch (N->getMachineOpcode()) {
-    default:
-      continue;
-    case RISCV::LB:
-    case RISCV::LH:
-    case RISCV::LW:
-    case RISCV::LBU:
-    case RISCV::LHU:
-    case RISCV::LWU:
-    case RISCV::LD:
-    case RISCV::FLW:
-    case RISCV::FLD:
-      BaseOpIdx = 0;
-      OffsetOpIdx = 1;
-      break;
-    case RISCV::SB:
-    case RISCV::SH:
-    case RISCV::SW:
-    case RISCV::SD:
-    case RISCV::FSW:
-    case RISCV::FSD:
-      BaseOpIdx = 1;
-      OffsetOpIdx = 2;
-      break;
-    }
-
-    // Currently, the load/store offset must be 0 to be considered for this
-    // peephole optimisation.
-    if (!isa<ConstantSDNode>(N->getOperand(OffsetOpIdx)) ||
-        N->getConstantOperandVal(OffsetOpIdx) != 0)
-      continue;
-
-    SDValue Base = N->getOperand(BaseOpIdx);
-
-    // If the base is an ADDI, we can merge it in to the load/store.
-    if (!Base.isMachineOpcode() || Base.getMachineOpcode() != RISCV::ADDI)
-      continue;
-
-    SDValue ImmOperand = Base.getOperand(1);
-
-    if (auto Const = dyn_cast<ConstantSDNode>(ImmOperand)) {
-      ImmOperand = CurDAG->getTargetConstant(
-          Const->getSExtValue(), SDLoc(ImmOperand), ImmOperand.getValueType());
-    } else if (auto GA = dyn_cast<GlobalAddressSDNode>(ImmOperand)) {
-      ImmOperand = CurDAG->getTargetGlobalAddress(
-          GA->getGlobal(), SDLoc(ImmOperand), ImmOperand.getValueType(),
-          GA->getOffset(), GA->getTargetFlags());
-    } else {
-      continue;
-    }
-
-    LLVM_DEBUG(dbgs() << "Folding add-immediate into mem-op:\nBase:    ");
-    LLVM_DEBUG(Base->dump(CurDAG));
-    LLVM_DEBUG(dbgs() << "\nN: ");
-    LLVM_DEBUG(N->dump(CurDAG));
-    LLVM_DEBUG(dbgs() << "\n");
-
-    // Modify the offset operand of the load/store.
-    if (BaseOpIdx == 0) // Load
-      CurDAG->UpdateNodeOperands(N, Base.getOperand(0), ImmOperand,
-                                 N->getOperand(2));
-    else // Store
-      CurDAG->UpdateNodeOperands(N, N->getOperand(0), Base.getOperand(0),
-                                 ImmOperand, N->getOperand(3));
-
-    // The add-immediate may now be dead, in which case remove it.
-    if (Base.getNode()->use_empty())
-      CurDAG->RemoveDeadNode(Base.getNode());
-  }
-}
-
-// This pass converts a legalized DAG into a RISCV-specific DAG, ready
-// for instruction scheduling.
-FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
-  return new RISCVDAGToDAGISel(TM);
-}
diff --git a/lib/Target/RISCV/RISCVISelLowering.cpp b/lib/Target/RISCV/RISCVISelLowering.cpp
deleted file mode 100644
index e78085edac3..00000000000
--- a/lib/Target/RISCV/RISCVISelLowering.cpp
+++ /dev/null
@@ -1,1733 +0,0 @@
-//===-- RISCVISelLowering.cpp - RISCV DAG Lowering Implementation  --------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the interfaces that RISCV uses to lower LLVM code into a
-// selection DAG.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVISelLowering.h"
-#include "RISCV.h"
-#include "RISCVMachineFunctionInfo.h"
-#include "RISCVRegisterInfo.h"
-#include "RISCVSubtarget.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/ADT/Statistic.h"
-#include "llvm/CodeGen/CallingConvLower.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/SelectionDAGISel.h"
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
-#include "llvm/CodeGen/ValueTypes.h"
-#include "llvm/IR/DiagnosticInfo.h"
-#include "llvm/IR/DiagnosticPrinter.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-lower"
-
-STATISTIC(NumTailCalls, "Number of tail calls");
-
-RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
-                                         const RISCVSubtarget &STI)
-    : TargetLowering(TM), Subtarget(STI) {
-
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  // Set up the register classes.
-  addRegisterClass(XLenVT, &RISCV::GPRRegClass);
-
-  if (Subtarget.hasStdExtF())
-    addRegisterClass(MVT::f32, &RISCV::FPR32RegClass);
-  if (Subtarget.hasStdExtD())
-    addRegisterClass(MVT::f64, &RISCV::FPR64RegClass);
-
-  // Compute derived properties from the register classes.
-  computeRegisterProperties(STI.getRegisterInfo());
-
-  setStackPointerRegisterToSaveRestore(RISCV::X2);
-
-  for (auto N : {ISD::EXTLOAD, ISD::SEXTLOAD, ISD::ZEXTLOAD})
-    setLoadExtAction(N, XLenVT, MVT::i1, Promote);
-
-  // TODO: add all necessary setOperationAction calls.
-  setOperationAction(ISD::DYNAMIC_STACKALLOC, XLenVT, Expand);
-
-  setOperationAction(ISD::BR_JT, MVT::Other, Expand);
-  setOperationAction(ISD::BR_CC, XLenVT, Expand);
-  setOperationAction(ISD::SELECT, XLenVT, Custom);
-  setOperationAction(ISD::SELECT_CC, XLenVT, Expand);
-
-  setOperationAction(ISD::STACKSAVE, MVT::Other, Expand);
-  setOperationAction(ISD::STACKRESTORE, MVT::Other, Expand);
-
-  setOperationAction(ISD::VASTART, MVT::Other, Custom);
-  setOperationAction(ISD::VAARG, MVT::Other, Expand);
-  setOperationAction(ISD::VACOPY, MVT::Other, Expand);
-  setOperationAction(ISD::VAEND, MVT::Other, Expand);
-
-  for (auto VT : {MVT::i1, MVT::i8, MVT::i16})
-    setOperationAction(ISD::SIGN_EXTEND_INREG, VT, Expand);
-
-  if (!Subtarget.hasStdExtM()) {
-    setOperationAction(ISD::MUL, XLenVT, Expand);
-    setOperationAction(ISD::MULHS, XLenVT, Expand);
-    setOperationAction(ISD::MULHU, XLenVT, Expand);
-    setOperationAction(ISD::SDIV, XLenVT, Expand);
-    setOperationAction(ISD::UDIV, XLenVT, Expand);
-    setOperationAction(ISD::SREM, XLenVT, Expand);
-    setOperationAction(ISD::UREM, XLenVT, Expand);
-  }
-
-  setOperationAction(ISD::SDIVREM, XLenVT, Expand);
-  setOperationAction(ISD::UDIVREM, XLenVT, Expand);
-  setOperationAction(ISD::SMUL_LOHI, XLenVT, Expand);
-  setOperationAction(ISD::UMUL_LOHI, XLenVT, Expand);
-
-  setOperationAction(ISD::SHL_PARTS, XLenVT, Expand);
-  setOperationAction(ISD::SRL_PARTS, XLenVT, Expand);
-  setOperationAction(ISD::SRA_PARTS, XLenVT, Expand);
-
-  setOperationAction(ISD::ROTL, XLenVT, Expand);
-  setOperationAction(ISD::ROTR, XLenVT, Expand);
-  setOperationAction(ISD::BSWAP, XLenVT, Expand);
-  setOperationAction(ISD::CTTZ, XLenVT, Expand);
-  setOperationAction(ISD::CTLZ, XLenVT, Expand);
-  setOperationAction(ISD::CTPOP, XLenVT, Expand);
-
-  ISD::CondCode FPCCToExtend[] = {
-      ISD::SETOGT, ISD::SETOGE, ISD::SETONE, ISD::SETO,   ISD::SETUEQ,
-      ISD::SETUGT, ISD::SETUGE, ISD::SETULT, ISD::SETULE, ISD::SETUNE,
-      ISD::SETGT,  ISD::SETGE,  ISD::SETNE};
-
-  ISD::NodeType FPOpToExtend[] = {
-      ISD::FSIN, ISD::FCOS, ISD::FSINCOS, ISD::FPOW, ISD::FREM};
-
-  if (Subtarget.hasStdExtF()) {
-    setOperationAction(ISD::FMINNUM, MVT::f32, Legal);
-    setOperationAction(ISD::FMAXNUM, MVT::f32, Legal);
-    for (auto CC : FPCCToExtend)
-      setCondCodeAction(CC, MVT::f32, Expand);
-    setOperationAction(ISD::SELECT_CC, MVT::f32, Expand);
-    setOperationAction(ISD::SELECT, MVT::f32, Custom);
-    setOperationAction(ISD::BR_CC, MVT::f32, Expand);
-    for (auto Op : FPOpToExtend)
-      setOperationAction(Op, MVT::f32, Expand);
-  }
-
-  if (Subtarget.hasStdExtD()) {
-    setOperationAction(ISD::FMINNUM, MVT::f64, Legal);
-    setOperationAction(ISD::FMAXNUM, MVT::f64, Legal);
-    for (auto CC : FPCCToExtend)
-      setCondCodeAction(CC, MVT::f64, Expand);
-    setOperationAction(ISD::SELECT_CC, MVT::f64, Expand);
-    setOperationAction(ISD::SELECT, MVT::f64, Custom);
-    setOperationAction(ISD::BR_CC, MVT::f64, Expand);
-    setLoadExtAction(ISD::EXTLOAD, MVT::f64, MVT::f32, Expand);
-    setTruncStoreAction(MVT::f64, MVT::f32, Expand);
-    for (auto Op : FPOpToExtend)
-      setOperationAction(Op, MVT::f64, Expand);
-  }
-
-  setOperationAction(ISD::GlobalAddress, XLenVT, Custom);
-  setOperationAction(ISD::BlockAddress, XLenVT, Custom);
-  setOperationAction(ISD::ConstantPool, XLenVT, Custom);
-
-  if (Subtarget.hasStdExtA()) {
-    setMaxAtomicSizeInBitsSupported(Subtarget.getXLen());
-    setMinCmpXchgSizeInBits(32);
-  } else {
-    setMaxAtomicSizeInBitsSupported(0);
-  }
-
-  setBooleanContents(ZeroOrOneBooleanContent);
-
-  // Function alignments (log2).
-  unsigned FunctionAlignment = Subtarget.hasStdExtC() ? 1 : 2;
-  setMinFunctionAlignment(FunctionAlignment);
-  setPrefFunctionAlignment(FunctionAlignment);
-
-  // Effectively disable jump table generation.
-  setMinimumJumpTableEntries(INT_MAX);
-}
-
-EVT RISCVTargetLowering::getSetCCResultType(const DataLayout &DL, LLVMContext &,
-                                            EVT VT) const {
-  if (!VT.isVector())
-    return getPointerTy(DL);
-  return VT.changeVectorElementTypeToInteger();
-}
-
-bool RISCVTargetLowering::getTgtMemIntrinsic(IntrinsicInfo &Info,
-                                             const CallInst &I,
-                                             MachineFunction &MF,
-                                             unsigned Intrinsic) const {
-  switch (Intrinsic) {
-  default:
-    return false;
-  case Intrinsic::riscv_masked_atomicrmw_xchg_i32:
-  case Intrinsic::riscv_masked_atomicrmw_add_i32:
-  case Intrinsic::riscv_masked_atomicrmw_sub_i32:
-  case Intrinsic::riscv_masked_atomicrmw_nand_i32:
-  case Intrinsic::riscv_masked_atomicrmw_max_i32:
-  case Intrinsic::riscv_masked_atomicrmw_min_i32:
-  case Intrinsic::riscv_masked_atomicrmw_umax_i32:
-  case Intrinsic::riscv_masked_atomicrmw_umin_i32:
-  case Intrinsic::riscv_masked_cmpxchg_i32:
-    PointerType *PtrTy = cast<PointerType>(I.getArgOperand(0)->getType());
-    Info.opc = ISD::INTRINSIC_W_CHAIN;
-    Info.memVT = MVT::getVT(PtrTy->getElementType());
-    Info.ptrVal = I.getArgOperand(0);
-    Info.offset = 0;
-    Info.align = 4;
-    Info.flags = MachineMemOperand::MOLoad | MachineMemOperand::MOStore |
-                 MachineMemOperand::MOVolatile;
-    return true;
-  }
-}
-
-bool RISCVTargetLowering::isLegalAddressingMode(const DataLayout &DL,
-                                                const AddrMode &AM, Type *Ty,
-                                                unsigned AS,
-                                                Instruction *I) const {
-  // No global is ever allowed as a base.
-  if (AM.BaseGV)
-    return false;
-
-  // Require a 12-bit signed offset.
-  if (!isInt<12>(AM.BaseOffs))
-    return false;
-
-  switch (AM.Scale) {
-  case 0: // "r+i" or just "i", depending on HasBaseReg.
-    break;
-  case 1:
-    if (!AM.HasBaseReg) // allow "r+i".
-      break;
-    return false; // disallow "r+r" or "r+r+i".
-  default:
-    return false;
-  }
-
-  return true;
-}
-
-bool RISCVTargetLowering::isLegalICmpImmediate(int64_t Imm) const {
-  return isInt<12>(Imm);
-}
-
-bool RISCVTargetLowering::isLegalAddImmediate(int64_t Imm) const {
-  return isInt<12>(Imm);
-}
-
-// On RV32, 64-bit integers are split into their high and low parts and held
-// in two different registers, so the trunc is free since the low register can
-// just be used.
-bool RISCVTargetLowering::isTruncateFree(Type *SrcTy, Type *DstTy) const {
-  if (Subtarget.is64Bit() || !SrcTy->isIntegerTy() || !DstTy->isIntegerTy())
-    return false;
-  unsigned SrcBits = SrcTy->getPrimitiveSizeInBits();
-  unsigned DestBits = DstTy->getPrimitiveSizeInBits();
-  return (SrcBits == 64 && DestBits == 32);
-}
-
-bool RISCVTargetLowering::isTruncateFree(EVT SrcVT, EVT DstVT) const {
-  if (Subtarget.is64Bit() || SrcVT.isVector() || DstVT.isVector() ||
-      !SrcVT.isInteger() || !DstVT.isInteger())
-    return false;
-  unsigned SrcBits = SrcVT.getSizeInBits();
-  unsigned DestBits = DstVT.getSizeInBits();
-  return (SrcBits == 64 && DestBits == 32);
-}
-
-bool RISCVTargetLowering::isZExtFree(SDValue Val, EVT VT2) const {
-  // Zexts are free if they can be combined with a load.
-  if (auto *LD = dyn_cast<LoadSDNode>(Val)) {
-    EVT MemVT = LD->getMemoryVT();
-    if ((MemVT == MVT::i8 || MemVT == MVT::i16 ||
-         (Subtarget.is64Bit() && MemVT == MVT::i32)) &&
-        (LD->getExtensionType() == ISD::NON_EXTLOAD ||
-         LD->getExtensionType() == ISD::ZEXTLOAD))
-      return true;
-  }
-
-  return TargetLowering::isZExtFree(Val, VT2);
-}
-
-bool RISCVTargetLowering::isSExtCheaperThanZExt(EVT SrcVT, EVT DstVT) const {
-  return Subtarget.is64Bit() && SrcVT == MVT::i32 && DstVT == MVT::i64;
-}
-
-// Changes the condition code and swaps operands if necessary, so the SetCC
-// operation matches one of the comparisons supported directly in the RISC-V
-// ISA.
-static void normaliseSetCC(SDValue &LHS, SDValue &RHS, ISD::CondCode &CC) {
-  switch (CC) {
-  default:
-    break;
-  case ISD::SETGT:
-  case ISD::SETLE:
-  case ISD::SETUGT:
-  case ISD::SETULE:
-    CC = ISD::getSetCCSwappedOperands(CC);
-    std::swap(LHS, RHS);
-    break;
-  }
-}
-
-// Return the RISC-V branch opcode that matches the given DAG integer
-// condition code. The CondCode must be one of those supported by the RISC-V
-// ISA (see normaliseSetCC).
-static unsigned getBranchOpcodeForIntCondCode(ISD::CondCode CC) {
-  switch (CC) {
-  default:
-    llvm_unreachable("Unsupported CondCode");
-  case ISD::SETEQ:
-    return RISCV::BEQ;
-  case ISD::SETNE:
-    return RISCV::BNE;
-  case ISD::SETLT:
-    return RISCV::BLT;
-  case ISD::SETGE:
-    return RISCV::BGE;
-  case ISD::SETULT:
-    return RISCV::BLTU;
-  case ISD::SETUGE:
-    return RISCV::BGEU;
-  }
-}
-
-SDValue RISCVTargetLowering::LowerOperation(SDValue Op,
-                                            SelectionDAG &DAG) const {
-  switch (Op.getOpcode()) {
-  default:
-    report_fatal_error("unimplemented operand");
-  case ISD::GlobalAddress:
-    return lowerGlobalAddress(Op, DAG);
-  case ISD::BlockAddress:
-    return lowerBlockAddress(Op, DAG);
-  case ISD::ConstantPool:
-    return lowerConstantPool(Op, DAG);
-  case ISD::SELECT:
-    return lowerSELECT(Op, DAG);
-  case ISD::VASTART:
-    return lowerVASTART(Op, DAG);
-  case ISD::FRAMEADDR:
-    return lowerFRAMEADDR(Op, DAG);
-  case ISD::RETURNADDR:
-    return lowerRETURNADDR(Op, DAG);
-  }
-}
-
-SDValue RISCVTargetLowering::lowerGlobalAddress(SDValue Op,
-                                                SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  GlobalAddressSDNode *N = cast<GlobalAddressSDNode>(Op);
-  const GlobalValue *GV = N->getGlobal();
-  int64_t Offset = N->getOffset();
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  if (isPositionIndependent())
-    report_fatal_error("Unable to lowerGlobalAddress");
-  // In order to maximise the opportunity for common subexpression elimination,
-  // emit a separate ADD node for the global address offset instead of folding
-  // it in the global address node. Later peephole optimisations may choose to
-  // fold it back in when profitable.
-  SDValue GAHi = DAG.getTargetGlobalAddress(GV, DL, Ty, 0, RISCVII::MO_HI);
-  SDValue GALo = DAG.getTargetGlobalAddress(GV, DL, Ty, 0, RISCVII::MO_LO);
-  SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, GAHi), 0);
-  SDValue MNLo =
-    SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, GALo), 0);
-  if (Offset != 0)
-    return DAG.getNode(ISD::ADD, DL, Ty, MNLo,
-                       DAG.getConstant(Offset, DL, XLenVT));
-  return MNLo;
-}
-
-SDValue RISCVTargetLowering::lowerBlockAddress(SDValue Op,
-                                               SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  BlockAddressSDNode *N = cast<BlockAddressSDNode>(Op);
-  const BlockAddress *BA = N->getBlockAddress();
-  int64_t Offset = N->getOffset();
-
-  if (isPositionIndependent())
-    report_fatal_error("Unable to lowerBlockAddress");
-
-  SDValue BAHi = DAG.getTargetBlockAddress(BA, Ty, Offset, RISCVII::MO_HI);
-  SDValue BALo = DAG.getTargetBlockAddress(BA, Ty, Offset, RISCVII::MO_LO);
-  SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, BAHi), 0);
-  SDValue MNLo =
-    SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, BALo), 0);
-  return MNLo;
-}
-
-SDValue RISCVTargetLowering::lowerConstantPool(SDValue Op,
-                                               SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  ConstantPoolSDNode *N = cast<ConstantPoolSDNode>(Op);
-  const Constant *CPA = N->getConstVal();
-  int64_t Offset = N->getOffset();
-  unsigned Alignment = N->getAlignment();
-
-  if (!isPositionIndependent()) {
-    SDValue CPAHi =
-        DAG.getTargetConstantPool(CPA, Ty, Alignment, Offset, RISCVII::MO_HI);
-    SDValue CPALo =
-        DAG.getTargetConstantPool(CPA, Ty, Alignment, Offset, RISCVII::MO_LO);
-    SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, CPAHi), 0);
-    SDValue MNLo =
-        SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, CPALo), 0);
-    return MNLo;
-  } else {
-    report_fatal_error("Unable to lowerConstantPool");
-  }
-}
-
-SDValue RISCVTargetLowering::lowerSELECT(SDValue Op, SelectionDAG &DAG) const {
-  SDValue CondV = Op.getOperand(0);
-  SDValue TrueV = Op.getOperand(1);
-  SDValue FalseV = Op.getOperand(2);
-  SDLoc DL(Op);
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  // If the result type is XLenVT and CondV is the output of a SETCC node
-  // which also operated on XLenVT inputs, then merge the SETCC node into the
-  // lowered RISCVISD::SELECT_CC to take advantage of the integer
-  // compare+branch instructions. i.e.:
-  // (select (setcc lhs, rhs, cc), truev, falsev)
-  // -> (riscvisd::select_cc lhs, rhs, cc, truev, falsev)
-  if (Op.getSimpleValueType() == XLenVT && CondV.getOpcode() == ISD::SETCC &&
-      CondV.getOperand(0).getSimpleValueType() == XLenVT) {
-    SDValue LHS = CondV.getOperand(0);
-    SDValue RHS = CondV.getOperand(1);
-    auto CC = cast<CondCodeSDNode>(CondV.getOperand(2));
-    ISD::CondCode CCVal = CC->get();
-
-    normaliseSetCC(LHS, RHS, CCVal);
-
-    SDValue TargetCC = DAG.getConstant(CCVal, DL, XLenVT);
-    SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
-    SDValue Ops[] = {LHS, RHS, TargetCC, TrueV, FalseV};
-    return DAG.getNode(RISCVISD::SELECT_CC, DL, VTs, Ops);
-  }
-
-  // Otherwise:
-  // (select condv, truev, falsev)
-  // -> (riscvisd::select_cc condv, zero, setne, truev, falsev)
-  SDValue Zero = DAG.getConstant(0, DL, XLenVT);
-  SDValue SetNE = DAG.getConstant(ISD::SETNE, DL, XLenVT);
-
-  SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
-  SDValue Ops[] = {CondV, Zero, SetNE, TrueV, FalseV};
-
-  return DAG.getNode(RISCVISD::SELECT_CC, DL, VTs, Ops);
-}
-
-SDValue RISCVTargetLowering::lowerVASTART(SDValue Op, SelectionDAG &DAG) const {
-  MachineFunction &MF = DAG.getMachineFunction();
-  RISCVMachineFunctionInfo *FuncInfo = MF.getInfo<RISCVMachineFunctionInfo>();
-
-  SDLoc DL(Op);
-  SDValue FI = DAG.getFrameIndex(FuncInfo->getVarArgsFrameIndex(),
-                                 getPointerTy(MF.getDataLayout()));
-
-  // vastart just stores the address of the VarArgsFrameIndex slot into the
-  // memory location argument.
-  const Value *SV = cast<SrcValueSDNode>(Op.getOperand(2))->getValue();
-  return DAG.getStore(Op.getOperand(0), DL, FI, Op.getOperand(1),
-                      MachinePointerInfo(SV));
-}
-
-SDValue RISCVTargetLowering::lowerFRAMEADDR(SDValue Op,
-                                            SelectionDAG &DAG) const {
-  const RISCVRegisterInfo &RI = *Subtarget.getRegisterInfo();
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  MFI.setFrameAddressIsTaken(true);
-  unsigned FrameReg = RI.getFrameRegister(MF);
-  int XLenInBytes = Subtarget.getXLen() / 8;
-
-  EVT VT = Op.getValueType();
-  SDLoc DL(Op);
-  SDValue FrameAddr = DAG.getCopyFromReg(DAG.getEntryNode(), DL, FrameReg, VT);
-  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
-  while (Depth--) {
-    int Offset = -(XLenInBytes * 2);
-    SDValue Ptr = DAG.getNode(ISD::ADD, DL, VT, FrameAddr,
-                              DAG.getIntPtrConstant(Offset, DL));
-    FrameAddr =
-        DAG.getLoad(VT, DL, DAG.getEntryNode(), Ptr, MachinePointerInfo());
-  }
-  return FrameAddr;
-}
-
-SDValue RISCVTargetLowering::lowerRETURNADDR(SDValue Op,
-                                             SelectionDAG &DAG) const {
-  const RISCVRegisterInfo &RI = *Subtarget.getRegisterInfo();
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  MFI.setReturnAddressIsTaken(true);
-  MVT XLenVT = Subtarget.getXLenVT();
-  int XLenInBytes = Subtarget.getXLen() / 8;
-
-  if (verifyReturnAddressArgumentIsConstant(Op, DAG))
-    return SDValue();
-
-  EVT VT = Op.getValueType();
-  SDLoc DL(Op);
-  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
-  if (Depth) {
-    int Off = -XLenInBytes;
-    SDValue FrameAddr = lowerFRAMEADDR(Op, DAG);
-    SDValue Offset = DAG.getConstant(Off, DL, VT);
-    return DAG.getLoad(VT, DL, DAG.getEntryNode(),
-                       DAG.getNode(ISD::ADD, DL, VT, FrameAddr, Offset),
-                       MachinePointerInfo());
-  }
-
-  // Return the value of the return address register, marking it an implicit
-  // live-in.
-  unsigned Reg = MF.addLiveIn(RI.getRARegister(), getRegClassFor(XLenVT));
-  return DAG.getCopyFromReg(DAG.getEntryNode(), DL, Reg, XLenVT);
-}
-
-SDValue RISCVTargetLowering::PerformDAGCombine(SDNode *N,
-                                               DAGCombinerInfo &DCI) const {
-  switch (N->getOpcode()) {
-  default:
-    break;
-  case RISCVISD::SplitF64: {
-    // If the input to SplitF64 is just BuildPairF64 then the operation is
-    // redundant. Instead, use BuildPairF64's operands directly.
-    SDValue Op0 = N->getOperand(0);
-    if (Op0->getOpcode() != RISCVISD::BuildPairF64)
-      break;
-    return DCI.CombineTo(N, Op0.getOperand(0), Op0.getOperand(1));
-  }
-  }
-
-  return SDValue();
-}
-
-static MachineBasicBlock *emitSplitF64Pseudo(MachineInstr &MI,
-                                             MachineBasicBlock *BB) {
-  assert(MI.getOpcode() == RISCV::SplitF64Pseudo && "Unexpected instruction");
-
-  MachineFunction &MF = *BB->getParent();
-  DebugLoc DL = MI.getDebugLoc();
-  const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();
-  const TargetRegisterInfo *RI = MF.getSubtarget().getRegisterInfo();
-  unsigned LoReg = MI.getOperand(0).getReg();
-  unsigned HiReg = MI.getOperand(1).getReg();
-  unsigned SrcReg = MI.getOperand(2).getReg();
-  const TargetRegisterClass *SrcRC = &RISCV::FPR64RegClass;
-  int FI = MF.getInfo<RISCVMachineFunctionInfo>()->getMoveF64FrameIndex();
-
-  TII.storeRegToStackSlot(*BB, MI, SrcReg, MI.getOperand(2).isKill(), FI, SrcRC,
-                          RI);
-  MachineMemOperand *MMO =
-      MF.getMachineMemOperand(MachinePointerInfo::getFixedStack(MF, FI),
-                              MachineMemOperand::MOLoad, 8, 8);
-  BuildMI(*BB, MI, DL, TII.get(RISCV::LW), LoReg)
-      .addFrameIndex(FI)
-      .addImm(0)
-      .addMemOperand(MMO);
-  BuildMI(*BB, MI, DL, TII.get(RISCV::LW), HiReg)
-      .addFrameIndex(FI)
-      .addImm(4)
-      .addMemOperand(MMO);
-  MI.eraseFromParent(); // The pseudo instruction is gone now.
-  return BB;
-}
-
-static MachineBasicBlock *emitBuildPairF64Pseudo(MachineInstr &MI,
-                                                 MachineBasicBlock *BB) {
-  assert(MI.getOpcode() == RISCV::BuildPairF64Pseudo &&
-         "Unexpected instruction");
-
-  MachineFunction &MF = *BB->getParent();
-  DebugLoc DL = MI.getDebugLoc();
-  const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();
-  const TargetRegisterInfo *RI = MF.getSubtarget().getRegisterInfo();
-  unsigned DstReg = MI.getOperand(0).getReg();
-  unsigned LoReg = MI.getOperand(1).getReg();
-  unsigned HiReg = MI.getOperand(2).getReg();
-  const TargetRegisterClass *DstRC = &RISCV::FPR64RegClass;
-  int FI = MF.getInfo<RISCVMachineFunctionInfo>()->getMoveF64FrameIndex();
-
-  MachineMemOperand *MMO =
-      MF.getMachineMemOperand(MachinePointerInfo::getFixedStack(MF, FI),
-                              MachineMemOperand::MOStore, 8, 8);
-  BuildMI(*BB, MI, DL, TII.get(RISCV::SW))
-      .addReg(LoReg, getKillRegState(MI.getOperand(1).isKill()))
-      .addFrameIndex(FI)
-      .addImm(0)
-      .addMemOperand(MMO);
-  BuildMI(*BB, MI, DL, TII.get(RISCV::SW))
-      .addReg(HiReg, getKillRegState(MI.getOperand(2).isKill()))
-      .addFrameIndex(FI)
-      .addImm(4)
-      .addMemOperand(MMO);
-  TII.loadRegFromStackSlot(*BB, MI, DstReg, FI, DstRC, RI);
-  MI.eraseFromParent(); // The pseudo instruction is gone now.
-  return BB;
-}
-
-MachineBasicBlock *
-RISCVTargetLowering::EmitInstrWithCustomInserter(MachineInstr &MI,
-                                                 MachineBasicBlock *BB) const {
-  switch (MI.getOpcode()) {
-  default:
-    llvm_unreachable("Unexpected instr type to insert");
-  case RISCV::Select_GPR_Using_CC_GPR:
-  case RISCV::Select_FPR32_Using_CC_GPR:
-  case RISCV::Select_FPR64_Using_CC_GPR:
-    break;
-  case RISCV::BuildPairF64Pseudo:
-    return emitBuildPairF64Pseudo(MI, BB);
-  case RISCV::SplitF64Pseudo:
-    return emitSplitF64Pseudo(MI, BB);
-  }
-
-  // To "insert" a SELECT instruction, we actually have to insert the triangle
-  // control-flow pattern.  The incoming instruction knows the destination vreg
-  // to set, the condition code register to branch on, the true/false values to
-  // select between, and the condcode to use to select the appropriate branch.
-  //
-  // We produce the following control flow:
-  //     HeadMBB
-  //     |  \
-  //     |  IfFalseMBB
-  //     | /
-  //    TailMBB
-  const TargetInstrInfo &TII = *BB->getParent()->getSubtarget().getInstrInfo();
-  const BasicBlock *LLVM_BB = BB->getBasicBlock();
-  DebugLoc DL = MI.getDebugLoc();
-  MachineFunction::iterator I = ++BB->getIterator();
-
-  MachineBasicBlock *HeadMBB = BB;
-  MachineFunction *F = BB->getParent();
-  MachineBasicBlock *TailMBB = F->CreateMachineBasicBlock(LLVM_BB);
-  MachineBasicBlock *IfFalseMBB = F->CreateMachineBasicBlock(LLVM_BB);
-
-  F->insert(I, IfFalseMBB);
-  F->insert(I, TailMBB);
-  // Move all remaining instructions to TailMBB.
-  TailMBB->splice(TailMBB->begin(), HeadMBB,
-                  std::next(MachineBasicBlock::iterator(MI)), HeadMBB->end());
-  // Update machine-CFG edges by transferring all successors of the current
-  // block to the new block which will contain the Phi node for the select.
-  TailMBB->transferSuccessorsAndUpdatePHIs(HeadMBB);
-  // Set the successors for HeadMBB.
-  HeadMBB->addSuccessor(IfFalseMBB);
-  HeadMBB->addSuccessor(TailMBB);
-
-  // Insert appropriate branch.
-  unsigned LHS = MI.getOperand(1).getReg();
-  unsigned RHS = MI.getOperand(2).getReg();
-  auto CC = static_cast<ISD::CondCode>(MI.getOperand(3).getImm());
-  unsigned Opcode = getBranchOpcodeForIntCondCode(CC);
-
-  BuildMI(HeadMBB, DL, TII.get(Opcode))
-    .addReg(LHS)
-    .addReg(RHS)
-    .addMBB(TailMBB);
-
-  // IfFalseMBB just falls through to TailMBB.
-  IfFalseMBB->addSuccessor(TailMBB);
-
-  // %Result = phi [ %TrueValue, HeadMBB ], [ %FalseValue, IfFalseMBB ]
-  BuildMI(*TailMBB, TailMBB->begin(), DL, TII.get(RISCV::PHI),
-          MI.getOperand(0).getReg())
-      .addReg(MI.getOperand(4).getReg())
-      .addMBB(HeadMBB)
-      .addReg(MI.getOperand(5).getReg())
-      .addMBB(IfFalseMBB);
-
-  MI.eraseFromParent(); // The pseudo instruction is gone now.
-  return TailMBB;
-}
-
-// Calling Convention Implementation.
-// The expectations for frontend ABI lowering vary from target to target.
-// Ideally, an LLVM frontend would be able to avoid worrying about many ABI
-// details, but this is a longer term goal. For now, we simply try to keep the
-// role of the frontend as simple and well-defined as possible. The rules can
-// be summarised as:
-// * Never split up large scalar arguments. We handle them here.
-// * If a hardfloat calling convention is being used, and the struct may be
-// passed in a pair of registers (fp+fp, int+fp), and both registers are
-// available, then pass as two separate arguments. If either the GPRs or FPRs
-// are exhausted, then pass according to the rule below.
-// * If a struct could never be passed in registers or directly in a stack
-// slot (as it is larger than 2*XLEN and the floating point rules don't
-// apply), then pass it using a pointer with the byval attribute.
-// * If a struct is less than 2*XLEN, then coerce to either a two-element
-// word-sized array or a 2*XLEN scalar (depending on alignment).
-// * The frontend can determine whether a struct is returned by reference or
-// not based on its size and fields. If it will be returned by reference, the
-// frontend must modify the prototype so a pointer with the sret annotation is
-// passed as the first argument. This is not necessary for large scalar
-// returns.
-// * Struct return values and varargs should be coerced to structs containing
-// register-size fields in the same situations they would be for fixed
-// arguments.
-
-static const MCPhysReg ArgGPRs[] = {
-  RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13,
-  RISCV::X14, RISCV::X15, RISCV::X16, RISCV::X17
-};
-
-// Pass a 2*XLEN argument that has been split into two XLEN values through
-// registers or the stack as necessary.
-static bool CC_RISCVAssign2XLen(unsigned XLen, CCState &State, CCValAssign VA1,
-                                ISD::ArgFlagsTy ArgFlags1, unsigned ValNo2,
-                                MVT ValVT2, MVT LocVT2,
-                                ISD::ArgFlagsTy ArgFlags2) {
-  unsigned XLenInBytes = XLen / 8;
-  if (unsigned Reg = State.AllocateReg(ArgGPRs)) {
-    // At least one half can be passed via register.
-    State.addLoc(CCValAssign::getReg(VA1.getValNo(), VA1.getValVT(), Reg,
-                                     VA1.getLocVT(), CCValAssign::Full));
-  } else {
-    // Both halves must be passed on the stack, with proper alignment.
-    unsigned StackAlign = std::max(XLenInBytes, ArgFlags1.getOrigAlign());
-    State.addLoc(
-        CCValAssign::getMem(VA1.getValNo(), VA1.getValVT(),
-                            State.AllocateStack(XLenInBytes, StackAlign),
-                            VA1.getLocVT(), CCValAssign::Full));
-    State.addLoc(CCValAssign::getMem(
-        ValNo2, ValVT2, State.AllocateStack(XLenInBytes, XLenInBytes), LocVT2,
-        CCValAssign::Full));
-    return false;
-  }
-
-  if (unsigned Reg = State.AllocateReg(ArgGPRs)) {
-    // The second half can also be passed via register.
-    State.addLoc(
-        CCValAssign::getReg(ValNo2, ValVT2, Reg, LocVT2, CCValAssign::Full));
-  } else {
-    // The second half is passed via the stack, without additional alignment.
-    State.addLoc(CCValAssign::getMem(
-        ValNo2, ValVT2, State.AllocateStack(XLenInBytes, XLenInBytes), LocVT2,
-        CCValAssign::Full));
-  }
-
-  return false;
-}
-
-// Implements the RISC-V calling convention. Returns true upon failure.
-static bool CC_RISCV(const DataLayout &DL, unsigned ValNo, MVT ValVT, MVT LocVT,
-                     CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
-                     CCState &State, bool IsFixed, bool IsRet, Type *OrigTy) {
-  unsigned XLen = DL.getLargestLegalIntTypeSizeInBits();
-  assert(XLen == 32 || XLen == 64);
-  MVT XLenVT = XLen == 32 ? MVT::i32 : MVT::i64;
-  if (ValVT == MVT::f32) {
-    LocVT = MVT::i32;
-    LocInfo = CCValAssign::BCvt;
-  }
-
-  // Any return value split in to more than two values can't be returned
-  // directly.
-  if (IsRet && ValNo > 1)
-    return true;
-
-  // If this is a variadic argument, the RISC-V calling convention requires
-  // that it is assigned an 'even' or 'aligned' register if it has 8-byte
-  // alignment (RV32) or 16-byte alignment (RV64). An aligned register should
-  // be used regardless of whether the original argument was split during
-  // legalisation or not. The argument will not be passed by registers if the
-  // original type is larger than 2*XLEN, so the register alignment rule does
-  // not apply.
-  unsigned TwoXLenInBytes = (2 * XLen) / 8;
-  if (!IsFixed && ArgFlags.getOrigAlign() == TwoXLenInBytes &&
-      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes) {
-    unsigned RegIdx = State.getFirstUnallocated(ArgGPRs);
-    // Skip 'odd' register if necessary.
-    if (RegIdx != array_lengthof(ArgGPRs) && RegIdx % 2 == 1)
-      State.AllocateReg(ArgGPRs);
-  }
-
-  SmallVectorImpl<CCValAssign> &PendingLocs = State.getPendingLocs();
-  SmallVectorImpl<ISD::ArgFlagsTy> &PendingArgFlags =
-      State.getPendingArgFlags();
-
-  assert(PendingLocs.size() == PendingArgFlags.size() &&
-         "PendingLocs and PendingArgFlags out of sync");
-
-  // Handle passing f64 on RV32D with a soft float ABI.
-  if (XLen == 32 && ValVT == MVT::f64) {
-    assert(!ArgFlags.isSplit() && PendingLocs.empty() &&
-           "Can't lower f64 if it is split");
-    // Depending on available argument GPRS, f64 may be passed in a pair of
-    // GPRs, split between a GPR and the stack, or passed completely on the
-    // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these
-    // cases.
-    unsigned Reg = State.AllocateReg(ArgGPRs);
-    LocVT = MVT::i32;
-    if (!Reg) {
-      unsigned StackOffset = State.AllocateStack(8, 8);
-      State.addLoc(
-          CCValAssign::getMem(ValNo, ValVT, StackOffset, LocVT, LocInfo));
-      return false;
-    }
-    if (!State.AllocateReg(ArgGPRs))
-      State.AllocateStack(4, 4);
-    State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
-    return false;
-  }
-
-  // Split arguments might be passed indirectly, so keep track of the pending
-  // values.
-  if (ArgFlags.isSplit() || !PendingLocs.empty()) {
-    LocVT = XLenVT;
-    LocInfo = CCValAssign::Indirect;
-    PendingLocs.push_back(
-        CCValAssign::getPending(ValNo, ValVT, LocVT, LocInfo));
-    PendingArgFlags.push_back(ArgFlags);
-    if (!ArgFlags.isSplitEnd()) {
-      return false;
-    }
-  }
-
-  // If the split argument only had two elements, it should be passed directly
-  // in registers or on the stack.
-  if (ArgFlags.isSplitEnd() && PendingLocs.size() <= 2) {
-    assert(PendingLocs.size() == 2 && "Unexpected PendingLocs.size()");
-    // Apply the normal calling convention rules to the first half of the
-    // split argument.
-    CCValAssign VA = PendingLocs[0];
-    ISD::ArgFlagsTy AF = PendingArgFlags[0];
-    PendingLocs.clear();
-    PendingArgFlags.clear();
-    return CC_RISCVAssign2XLen(XLen, State, VA, AF, ValNo, ValVT, LocVT,
-                               ArgFlags);
-  }
-
-  // Allocate to a register if possible, or else a stack slot.
-  unsigned Reg = State.AllocateReg(ArgGPRs);
-  unsigned StackOffset = Reg ? 0 : State.AllocateStack(XLen / 8, XLen / 8);
-
-  // If we reach this point and PendingLocs is non-empty, we must be at the
-  // end of a split argument that must be passed indirectly.
-  if (!PendingLocs.empty()) {
-    assert(ArgFlags.isSplitEnd() && "Expected ArgFlags.isSplitEnd()");
-    assert(PendingLocs.size() > 2 && "Unexpected PendingLocs.size()");
-
-    for (auto &It : PendingLocs) {
-      if (Reg)
-        It.convertToReg(Reg);
-      else
-        It.convertToMem(StackOffset);
-      State.addLoc(It);
-    }
-    PendingLocs.clear();
-    PendingArgFlags.clear();
-    return false;
-  }
-
-  assert(LocVT == XLenVT && "Expected an XLenVT at this stage");
-
-  if (Reg) {
-    State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
-    return false;
-  }
-
-  if (ValVT == MVT::f32) {
-    LocVT = MVT::f32;
-    LocInfo = CCValAssign::Full;
-  }
-  State.addLoc(CCValAssign::getMem(ValNo, ValVT, StackOffset, LocVT, LocInfo));
-  return false;
-}
-
-void RISCVTargetLowering::analyzeInputArgs(
-    MachineFunction &MF, CCState &CCInfo,
-    const SmallVectorImpl<ISD::InputArg> &Ins, bool IsRet) const {
-  unsigned NumArgs = Ins.size();
-  FunctionType *FType = MF.getFunction().getFunctionType();
-
-  for (unsigned i = 0; i != NumArgs; ++i) {
-    MVT ArgVT = Ins[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Ins[i].Flags;
-
-    Type *ArgTy = nullptr;
-    if (IsRet)
-      ArgTy = FType->getReturnType();
-    else if (Ins[i].isOrigArg())
-      ArgTy = FType->getParamType(Ins[i].getOrigArgIndex());
-
-    if (CC_RISCV(MF.getDataLayout(), i, ArgVT, ArgVT, CCValAssign::Full,
-                 ArgFlags, CCInfo, /*IsRet=*/true, IsRet, ArgTy)) {
-      LLVM_DEBUG(dbgs() << "InputArg #" << i << " has unhandled type "
-                        << EVT(ArgVT).getEVTString() << '\n');
-      llvm_unreachable(nullptr);
-    }
-  }
-}
-
-void RISCVTargetLowering::analyzeOutputArgs(
-    MachineFunction &MF, CCState &CCInfo,
-    const SmallVectorImpl<ISD::OutputArg> &Outs, bool IsRet,
-    CallLoweringInfo *CLI) const {
-  unsigned NumArgs = Outs.size();
-
-  for (unsigned i = 0; i != NumArgs; i++) {
-    MVT ArgVT = Outs[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Outs[i].Flags;
-    Type *OrigTy = CLI ? CLI->getArgs()[Outs[i].OrigArgIndex].Ty : nullptr;
-
-    if (CC_RISCV(MF.getDataLayout(), i, ArgVT, ArgVT, CCValAssign::Full,
-                 ArgFlags, CCInfo, Outs[i].IsFixed, IsRet, OrigTy)) {
-      LLVM_DEBUG(dbgs() << "OutputArg #" << i << " has unhandled type "
-                        << EVT(ArgVT).getEVTString() << "\n");
-      llvm_unreachable(nullptr);
-    }
-  }
-}
-
-// Convert Val to a ValVT. Should not be called for CCValAssign::Indirect
-// values.
-static SDValue convertLocVTToValVT(SelectionDAG &DAG, SDValue Val,
-                                   const CCValAssign &VA, const SDLoc &DL) {
-  switch (VA.getLocInfo()) {
-  default:
-    llvm_unreachable("Unexpected CCValAssign::LocInfo");
-  case CCValAssign::Full:
-    break;
-  case CCValAssign::BCvt:
-    Val = DAG.getNode(ISD::BITCAST, DL, VA.getValVT(), Val);
-    break;
-  }
-  return Val;
-}
-
-// The caller is responsible for loading the full value if the argument is
-// passed with CCValAssign::Indirect.
-static SDValue unpackFromRegLoc(SelectionDAG &DAG, SDValue Chain,
-                                const CCValAssign &VA, const SDLoc &DL) {
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineRegisterInfo &RegInfo = MF.getRegInfo();
-  EVT LocVT = VA.getLocVT();
-  SDValue Val;
-
-  unsigned VReg = RegInfo.createVirtualRegister(&RISCV::GPRRegClass);
-  RegInfo.addLiveIn(VA.getLocReg(), VReg);
-  Val = DAG.getCopyFromReg(Chain, DL, VReg, LocVT);
-
-  if (VA.getLocInfo() == CCValAssign::Indirect)
-    return Val;
-
-  return convertLocVTToValVT(DAG, Val, VA, DL);
-}
-
-static SDValue convertValVTToLocVT(SelectionDAG &DAG, SDValue Val,
-                                   const CCValAssign &VA, const SDLoc &DL) {
-  EVT LocVT = VA.getLocVT();
-
-  switch (VA.getLocInfo()) {
-  default:
-    llvm_unreachable("Unexpected CCValAssign::LocInfo");
-  case CCValAssign::Full:
-    break;
-  case CCValAssign::BCvt:
-    Val = DAG.getNode(ISD::BITCAST, DL, LocVT, Val);
-    break;
-  }
-  return Val;
-}
-
-// The caller is responsible for loading the full value if the argument is
-// passed with CCValAssign::Indirect.
-static SDValue unpackFromMemLoc(SelectionDAG &DAG, SDValue Chain,
-                                const CCValAssign &VA, const SDLoc &DL) {
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  EVT LocVT = VA.getLocVT();
-  EVT ValVT = VA.getValVT();
-  EVT PtrVT = MVT::getIntegerVT(DAG.getDataLayout().getPointerSizeInBits(0));
-  int FI = MFI.CreateFixedObject(ValVT.getSizeInBits() / 8,
-                                 VA.getLocMemOffset(), /*Immutable=*/true);
-  SDValue FIN = DAG.getFrameIndex(FI, PtrVT);
-  SDValue Val;
-
-  ISD::LoadExtType ExtType;
-  switch (VA.getLocInfo()) {
-  default:
-    llvm_unreachable("Unexpected CCValAssign::LocInfo");
-  case CCValAssign::Full:
-  case CCValAssign::Indirect:
-    ExtType = ISD::NON_EXTLOAD;
-    break;
-  }
-  Val = DAG.getExtLoad(
-      ExtType, DL, LocVT, Chain, FIN,
-      MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI), ValVT);
-  return Val;
-}
-
-static SDValue unpackF64OnRV32DSoftABI(SelectionDAG &DAG, SDValue Chain,
-                                       const CCValAssign &VA, const SDLoc &DL) {
-  assert(VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64 &&
-         "Unexpected VA");
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  MachineRegisterInfo &RegInfo = MF.getRegInfo();
-
-  if (VA.isMemLoc()) {
-    // f64 is passed on the stack.
-    int FI = MFI.CreateFixedObject(8, VA.getLocMemOffset(), /*Immutable=*/true);
-    SDValue FIN = DAG.getFrameIndex(FI, MVT::i32);
-    return DAG.getLoad(MVT::f64, DL, Chain, FIN,
-                       MachinePointerInfo::getFixedStack(MF, FI));
-  }
-
-  assert(VA.isRegLoc() && "Expected register VA assignment");
-
-  unsigned LoVReg = RegInfo.createVirtualRegister(&RISCV::GPRRegClass);
-  RegInfo.addLiveIn(VA.getLocReg(), LoVReg);
-  SDValue Lo = DAG.getCopyFromReg(Chain, DL, LoVReg, MVT::i32);
-  SDValue Hi;
-  if (VA.getLocReg() == RISCV::X17) {
-    // Second half of f64 is passed on the stack.
-    int FI = MFI.CreateFixedObject(4, 0, /*Immutable=*/true);
-    SDValue FIN = DAG.getFrameIndex(FI, MVT::i32);
-    Hi = DAG.getLoad(MVT::i32, DL, Chain, FIN,
-                     MachinePointerInfo::getFixedStack(MF, FI));
-  } else {
-    // Second half of f64 is passed in another GPR.
-    unsigned HiVReg = RegInfo.createVirtualRegister(&RISCV::GPRRegClass);
-    RegInfo.addLiveIn(VA.getLocReg() + 1, HiVReg);
-    Hi = DAG.getCopyFromReg(Chain, DL, HiVReg, MVT::i32);
-  }
-  return DAG.getNode(RISCVISD::BuildPairF64, DL, MVT::f64, Lo, Hi);
-}
-
-// Transform physical registers into virtual registers.
-SDValue RISCVTargetLowering::LowerFormalArguments(
-    SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
-    const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &DL,
-    SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
-
-  switch (CallConv) {
-  default:
-    report_fatal_error("Unsupported calling convention");
-  case CallingConv::C:
-  case CallingConv::Fast:
-    break;
-  }
-
-  MachineFunction &MF = DAG.getMachineFunction();
-
-  const Function &Func = MF.getFunction();
-  if (Func.hasFnAttribute("interrupt")) {
-    if (!Func.arg_empty())
-      report_fatal_error(
-        "Functions with the interrupt attribute cannot have arguments!");
-
-    StringRef Kind =
-      MF.getFunction().getFnAttribute("interrupt").getValueAsString();
-
-    if (!(Kind == "user" || Kind == "supervisor" || Kind == "machine"))
-      report_fatal_error(
-        "Function interrupt attribute argument not supported!");
-  }
-
-  EVT PtrVT = getPointerTy(DAG.getDataLayout());
-  MVT XLenVT = Subtarget.getXLenVT();
-  unsigned XLenInBytes = Subtarget.getXLen() / 8;
-  // Used with vargs to acumulate store chains.
-  std::vector<SDValue> OutChains;
-
-  // Assign locations to all of the incoming arguments.
-  SmallVector<CCValAssign, 16> ArgLocs;
-  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
-  analyzeInputArgs(MF, CCInfo, Ins, /*IsRet=*/false);
-
-  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
-    CCValAssign &VA = ArgLocs[i];
-    SDValue ArgValue;
-    // Passing f64 on RV32D with a soft float ABI must be handled as a special
-    // case.
-    if (VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64)
-      ArgValue = unpackF64OnRV32DSoftABI(DAG, Chain, VA, DL);
-    else if (VA.isRegLoc())
-      ArgValue = unpackFromRegLoc(DAG, Chain, VA, DL);
-    else
-      ArgValue = unpackFromMemLoc(DAG, Chain, VA, DL);
-
-    if (VA.getLocInfo() == CCValAssign::Indirect) {
-      // If the original argument was split and passed by reference (e.g. i128
-      // on RV32), we need to load all parts of it here (using the same
-      // address).
-      InVals.push_back(DAG.getLoad(VA.getValVT(), DL, Chain, ArgValue,
-                                   MachinePointerInfo()));
-      unsigned ArgIndex = Ins[i].OrigArgIndex;
-      assert(Ins[i].PartOffset == 0);
-      while (i + 1 != e && Ins[i + 1].OrigArgIndex == ArgIndex) {
-        CCValAssign &PartVA = ArgLocs[i + 1];
-        unsigned PartOffset = Ins[i + 1].PartOffset;
-        SDValue Address = DAG.getNode(ISD::ADD, DL, PtrVT, ArgValue,
-                                      DAG.getIntPtrConstant(PartOffset, DL));
-        InVals.push_back(DAG.getLoad(PartVA.getValVT(), DL, Chain, Address,
-                                     MachinePointerInfo()));
-        ++i;
-      }
-      continue;
-    }
-    InVals.push_back(ArgValue);
-  }
-
-  if (IsVarArg) {
-    ArrayRef<MCPhysReg> ArgRegs = makeArrayRef(ArgGPRs);
-    unsigned Idx = CCInfo.getFirstUnallocated(ArgRegs);
-    const TargetRegisterClass *RC = &RISCV::GPRRegClass;
-    MachineFrameInfo &MFI = MF.getFrameInfo();
-    MachineRegisterInfo &RegInfo = MF.getRegInfo();
-    RISCVMachineFunctionInfo *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-
-    // Offset of the first variable argument from stack pointer, and size of
-    // the vararg save area. For now, the varargs save area is either zero or
-    // large enough to hold a0-a7.
-    int VaArgOffset, VarArgsSaveSize;
-
-    // If all registers are allocated, then all varargs must be passed on the
-    // stack and we don't need to save any argregs.
-    if (ArgRegs.size() == Idx) {
-      VaArgOffset = CCInfo.getNextStackOffset();
-      VarArgsSaveSize = 0;
-    } else {
-      VarArgsSaveSize = XLenInBytes * (ArgRegs.size() - Idx);
-      VaArgOffset = -VarArgsSaveSize;
-    }
-
-    // Record the frame index of the first variable argument
-    // which is a value necessary to VASTART.
-    int FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset, true);
-    RVFI->setVarArgsFrameIndex(FI);
-
-    // If saving an odd number of registers then create an extra stack slot to
-    // ensure that the frame pointer is 2*XLEN-aligned, which in turn ensures
-    // offsets to even-numbered registered remain 2*XLEN-aligned.
-    if (Idx % 2) {
-      FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset - (int)XLenInBytes,
-                                 true);
-      VarArgsSaveSize += XLenInBytes;
-    }
-
-    // Copy the integer registers that may have been used for passing varargs
-    // to the vararg save area.
-    for (unsigned I = Idx; I < ArgRegs.size();
-         ++I, VaArgOffset += XLenInBytes) {
-      const unsigned Reg = RegInfo.createVirtualRegister(RC);
-      RegInfo.addLiveIn(ArgRegs[I], Reg);
-      SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, Reg, XLenVT);
-      FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset, true);
-      SDValue PtrOff = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
-      SDValue Store = DAG.getStore(Chain, DL, ArgValue, PtrOff,
-                                   MachinePointerInfo::getFixedStack(MF, FI));
-      cast<StoreSDNode>(Store.getNode())
-          ->getMemOperand()
-          ->setValue((Value *)nullptr);
-      OutChains.push_back(Store);
-    }
-    RVFI->setVarArgsSaveSize(VarArgsSaveSize);
-  }
-
-  // All stores are grouped in one node to allow the matching between
-  // the size of Ins and InVals. This only happens for vararg functions.
-  if (!OutChains.empty()) {
-    OutChains.push_back(Chain);
-    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, OutChains);
-  }
-
-  return Chain;
-}
-
-/// IsEligibleForTailCallOptimization - Check whether the call is eligible
-/// for tail call optimization.
-/// Note: This is modelled after ARM's IsEligibleForTailCallOptimization.
-bool RISCVTargetLowering::IsEligibleForTailCallOptimization(
-  CCState &CCInfo, CallLoweringInfo &CLI, MachineFunction &MF,
-  const SmallVector<CCValAssign, 16> &ArgLocs) const {
-
-  auto &Callee = CLI.Callee;
-  auto CalleeCC = CLI.CallConv;
-  auto IsVarArg = CLI.IsVarArg;
-  auto &Outs = CLI.Outs;
-  auto &Caller = MF.getFunction();
-  auto CallerCC = Caller.getCallingConv();
-
-  // Do not tail call opt functions with "disable-tail-calls" attribute.
-  if (Caller.getFnAttribute("disable-tail-calls").getValueAsString() == "true")
-    return false;
-
-  // Exception-handling functions need a special set of instructions to
-  // indicate a return to the hardware. Tail-calling another function would
-  // probably break this.
-  // TODO: The "interrupt" attribute isn't currently defined by RISC-V. This
-  // should be expanded as new function attributes are introduced.
-  if (Caller.hasFnAttribute("interrupt"))
-    return false;
-
-  // Do not tail call opt functions with varargs.
-  if (IsVarArg)
-    return false;
-
-  // Do not tail call opt if the stack is used to pass parameters.
-  if (CCInfo.getNextStackOffset() != 0)
-    return false;
-
-  // Do not tail call opt if any parameters need to be passed indirectly.
-  // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are
-  // passed indirectly. So the address of the value will be passed in a
-  // register, or if not available, then the address is put on the stack. In
-  // order to pass indirectly, space on the stack often needs to be allocated
-  // in order to store the value. In this case the CCInfo.getNextStackOffset()
-  // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs
-  // are passed CCValAssign::Indirect.
-  for (auto &VA : ArgLocs)
-    if (VA.getLocInfo() == CCValAssign::Indirect)
-      return false;
-
-  // Do not tail call opt if either caller or callee uses struct return
-  // semantics.
-  auto IsCallerStructRet = Caller.hasStructRetAttr();
-  auto IsCalleeStructRet = Outs.empty() ? false : Outs[0].Flags.isSRet();
-  if (IsCallerStructRet || IsCalleeStructRet)
-    return false;
-
-  // Externally-defined functions with weak linkage should not be
-  // tail-called. The behaviour of branch instructions in this situation (as
-  // used for tail calls) is implementation-defined, so we cannot rely on the
-  // linker replacing the tail call with a return.
-  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {
-    const GlobalValue *GV = G->getGlobal();
-    if (GV->hasExternalWeakLinkage())
-      return false;
-  }
-
-  // The callee has to preserve all registers the caller needs to preserve.
-  const RISCVRegisterInfo *TRI = Subtarget.getRegisterInfo();
-  const uint32_t *CallerPreserved = TRI->getCallPreservedMask(MF, CallerCC);
-  if (CalleeCC != CallerCC) {
-    const uint32_t *CalleePreserved = TRI->getCallPreservedMask(MF, CalleeCC);
-    if (!TRI->regmaskSubsetEqual(CallerPreserved, CalleePreserved))
-      return false;
-  }
-
-  // Byval parameters hand the function a pointer directly into the stack area
-  // we want to reuse during a tail call. Working around this *is* possible
-  // but less efficient and uglier in LowerCall.
-  for (auto &Arg : Outs)
-    if (Arg.Flags.isByVal())
-      return false;
-
-  return true;
-}
-
-// Lower a call to a callseq_start + CALL + callseq_end chain, and add input
-// and output parameter nodes.
-SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
-                                       SmallVectorImpl<SDValue> &InVals) const {
-  SelectionDAG &DAG = CLI.DAG;
-  SDLoc &DL = CLI.DL;
-  SmallVectorImpl<ISD::OutputArg> &Outs = CLI.Outs;
-  SmallVectorImpl<SDValue> &OutVals = CLI.OutVals;
-  SmallVectorImpl<ISD::InputArg> &Ins = CLI.Ins;
-  SDValue Chain = CLI.Chain;
-  SDValue Callee = CLI.Callee;
-  bool &IsTailCall = CLI.IsTailCall;
-  CallingConv::ID CallConv = CLI.CallConv;
-  bool IsVarArg = CLI.IsVarArg;
-  EVT PtrVT = getPointerTy(DAG.getDataLayout());
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  MachineFunction &MF = DAG.getMachineFunction();
-
-  // Analyze the operands of the call, assigning locations to each operand.
-  SmallVector<CCValAssign, 16> ArgLocs;
-  CCState ArgCCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
-  analyzeOutputArgs(MF, ArgCCInfo, Outs, /*IsRet=*/false, &CLI);
-
-  // Check if it's really possible to do a tail call.
-  if (IsTailCall)
-    IsTailCall = IsEligibleForTailCallOptimization(ArgCCInfo, CLI, MF,
-                                                   ArgLocs);
-
-  if (IsTailCall)
-    ++NumTailCalls;
-  else if (CLI.CS && CLI.CS.isMustTailCall())
-    report_fatal_error("failed to perform tail call elimination on a call "
-                       "site marked musttail");
-
-  // Get a count of how many bytes are to be pushed on the stack.
-  unsigned NumBytes = ArgCCInfo.getNextStackOffset();
-
-  // Create local copies for byval args
-  SmallVector<SDValue, 8> ByValArgs;
-  for (unsigned i = 0, e = Outs.size(); i != e; ++i) {
-    ISD::ArgFlagsTy Flags = Outs[i].Flags;
-    if (!Flags.isByVal())
-      continue;
-
-    SDValue Arg = OutVals[i];
-    unsigned Size = Flags.getByValSize();
-    unsigned Align = Flags.getByValAlign();
-
-    int FI = MF.getFrameInfo().CreateStackObject(Size, Align, /*isSS=*/false);
-    SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
-    SDValue SizeNode = DAG.getConstant(Size, DL, XLenVT);
-
-    Chain = DAG.getMemcpy(Chain, DL, FIPtr, Arg, SizeNode, Align,
-                          /*IsVolatile=*/false,
-                          /*AlwaysInline=*/false,
-                          IsTailCall, MachinePointerInfo(),
-                          MachinePointerInfo());
-    ByValArgs.push_back(FIPtr);
-  }
-
-  if (!IsTailCall)
-    Chain = DAG.getCALLSEQ_START(Chain, NumBytes, 0, CLI.DL);
-
-  // Copy argument values to their designated locations.
-  SmallVector<std::pair<unsigned, SDValue>, 8> RegsToPass;
-  SmallVector<SDValue, 8> MemOpChains;
-  SDValue StackPtr;
-  for (unsigned i = 0, j = 0, e = ArgLocs.size(); i != e; ++i) {
-    CCValAssign &VA = ArgLocs[i];
-    SDValue ArgValue = OutVals[i];
-    ISD::ArgFlagsTy Flags = Outs[i].Flags;
-
-    // Handle passing f64 on RV32D with a soft float ABI as a special case.
-    bool IsF64OnRV32DSoftABI =
-        VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64;
-    if (IsF64OnRV32DSoftABI && VA.isRegLoc()) {
-      SDValue SplitF64 = DAG.getNode(
-          RISCVISD::SplitF64, DL, DAG.getVTList(MVT::i32, MVT::i32), ArgValue);
-      SDValue Lo = SplitF64.getValue(0);
-      SDValue Hi = SplitF64.getValue(1);
-
-      unsigned RegLo = VA.getLocReg();
-      RegsToPass.push_back(std::make_pair(RegLo, Lo));
-
-      if (RegLo == RISCV::X17) {
-        // Second half of f64 is passed on the stack.
-        // Work out the address of the stack slot.
-        if (!StackPtr.getNode())
-          StackPtr = DAG.getCopyFromReg(Chain, DL, RISCV::X2, PtrVT);
-        // Emit the store.
-        MemOpChains.push_back(
-            DAG.getStore(Chain, DL, Hi, StackPtr, MachinePointerInfo()));
-      } else {
-        // Second half of f64 is passed in another GPR.
-        unsigned RegHigh = RegLo + 1;
-        RegsToPass.push_back(std::make_pair(RegHigh, Hi));
-      }
-      continue;
-    }
-
-    // IsF64OnRV32DSoftABI && VA.isMemLoc() is handled below in the same way
-    // as any other MemLoc.
-
-    // Promote the value if needed.
-    // For now, only handle fully promoted and indirect arguments.
-    if (VA.getLocInfo() == CCValAssign::Indirect) {
-      // Store the argument in a stack slot and pass its address.
-      SDValue SpillSlot = DAG.CreateStackTemporary(Outs[i].ArgVT);
-      int FI = cast<FrameIndexSDNode>(SpillSlot)->getIndex();
-      MemOpChains.push_back(
-          DAG.getStore(Chain, DL, ArgValue, SpillSlot,
-                       MachinePointerInfo::getFixedStack(MF, FI)));
-      // If the original argument was split (e.g. i128), we need
-      // to store all parts of it here (and pass just one address).
-      unsigned ArgIndex = Outs[i].OrigArgIndex;
-      assert(Outs[i].PartOffset == 0);
-      while (i + 1 != e && Outs[i + 1].OrigArgIndex == ArgIndex) {
-        SDValue PartValue = OutVals[i + 1];
-        unsigned PartOffset = Outs[i + 1].PartOffset;
-        SDValue Address = DAG.getNode(ISD::ADD, DL, PtrVT, SpillSlot,
-                                      DAG.getIntPtrConstant(PartOffset, DL));
-        MemOpChains.push_back(
-            DAG.getStore(Chain, DL, PartValue, Address,
-                         MachinePointerInfo::getFixedStack(MF, FI)));
-        ++i;
-      }
-      ArgValue = SpillSlot;
-    } else {
-      ArgValue = convertValVTToLocVT(DAG, ArgValue, VA, DL);
-    }
-
-    // Use local copy if it is a byval arg.
-    if (Flags.isByVal())
-      ArgValue = ByValArgs[j++];
-
-    if (VA.isRegLoc()) {
-      // Queue up the argument copies and emit them at the end.
-      RegsToPass.push_back(std::make_pair(VA.getLocReg(), ArgValue));
-    } else {
-      assert(VA.isMemLoc() && "Argument not register or memory");
-      assert(!IsTailCall && "Tail call not allowed if stack is used "
-                            "for passing parameters");
-
-      // Work out the address of the stack slot.
-      if (!StackPtr.getNode())
-        StackPtr = DAG.getCopyFromReg(Chain, DL, RISCV::X2, PtrVT);
-      SDValue Address =
-          DAG.getNode(ISD::ADD, DL, PtrVT, StackPtr,
-                      DAG.getIntPtrConstant(VA.getLocMemOffset(), DL));
-
-      // Emit the store.
-      MemOpChains.push_back(
-          DAG.getStore(Chain, DL, ArgValue, Address, MachinePointerInfo()));
-    }
-  }
-
-  // Join the stores, which are independent of one another.
-  if (!MemOpChains.empty())
-    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);
-
-  SDValue Glue;
-
-  // Build a sequence of copy-to-reg nodes, chained and glued together.
-  for (auto &Reg : RegsToPass) {
-    Chain = DAG.getCopyToReg(Chain, DL, Reg.first, Reg.second, Glue);
-    Glue = Chain.getValue(1);
-  }
-
-  // If the callee is a GlobalAddress/ExternalSymbol node, turn it into a
-  // TargetGlobalAddress/TargetExternalSymbol node so that legalize won't
-  // split it and then direct call can be matched by PseudoCALL.
-  if (GlobalAddressSDNode *S = dyn_cast<GlobalAddressSDNode>(Callee)) {
-    Callee = DAG.getTargetGlobalAddress(S->getGlobal(), DL, PtrVT, 0, 0);
-  } else if (ExternalSymbolSDNode *S = dyn_cast<ExternalSymbolSDNode>(Callee)) {
-    Callee = DAG.getTargetExternalSymbol(S->getSymbol(), PtrVT, 0);
-  }
-
-  // The first call operand is the chain and the second is the target address.
-  SmallVector<SDValue, 8> Ops;
-  Ops.push_back(Chain);
-  Ops.push_back(Callee);
-
-  // Add argument registers to the end of the list so that they are
-  // known live into the call.
-  for (auto &Reg : RegsToPass)
-    Ops.push_back(DAG.getRegister(Reg.first, Reg.second.getValueType()));
-
-  if (!IsTailCall) {
-    // Add a register mask operand representing the call-preserved registers.
-    const TargetRegisterInfo *TRI = Subtarget.getRegisterInfo();
-    const uint32_t *Mask = TRI->getCallPreservedMask(MF, CallConv);
-    assert(Mask && "Missing call preserved mask for calling convention");
-    Ops.push_back(DAG.getRegisterMask(Mask));
-  }
-
-  // Glue the call to the argument copies, if any.
-  if (Glue.getNode())
-    Ops.push_back(Glue);
-
-  // Emit the call.
-  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
-
-  if (IsTailCall) {
-    MF.getFrameInfo().setHasTailCall();
-    return DAG.getNode(RISCVISD::TAIL, DL, NodeTys, Ops);
-  }
-
-  Chain = DAG.getNode(RISCVISD::CALL, DL, NodeTys, Ops);
-  Glue = Chain.getValue(1);
-
-  // Mark the end of the call, which is glued to the call itself.
-  Chain = DAG.getCALLSEQ_END(Chain,
-                             DAG.getConstant(NumBytes, DL, PtrVT, true),
-                             DAG.getConstant(0, DL, PtrVT, true),
-                             Glue, DL);
-  Glue = Chain.getValue(1);
-
-  // Assign locations to each value returned by this call.
-  SmallVector<CCValAssign, 16> RVLocs;
-  CCState RetCCInfo(CallConv, IsVarArg, MF, RVLocs, *DAG.getContext());
-  analyzeInputArgs(MF, RetCCInfo, Ins, /*IsRet=*/true);
-
-  // Copy all of the result registers out of their specified physreg.
-  for (auto &VA : RVLocs) {
-    // Copy the value out
-    SDValue RetValue =
-        DAG.getCopyFromReg(Chain, DL, VA.getLocReg(), VA.getLocVT(), Glue);
-    // Glue the RetValue to the end of the call sequence
-    Chain = RetValue.getValue(1);
-    Glue = RetValue.getValue(2);
-
-    if (VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64) {
-      assert(VA.getLocReg() == ArgGPRs[0] && "Unexpected reg assignment");
-      SDValue RetValue2 =
-          DAG.getCopyFromReg(Chain, DL, ArgGPRs[1], MVT::i32, Glue);
-      Chain = RetValue2.getValue(1);
-      Glue = RetValue2.getValue(2);
-      RetValue = DAG.getNode(RISCVISD::BuildPairF64, DL, MVT::f64, RetValue,
-                             RetValue2);
-    }
-
-    RetValue = convertLocVTToValVT(DAG, RetValue, VA, DL);
-
-    InVals.push_back(RetValue);
-  }
-
-  return Chain;
-}
-
-bool RISCVTargetLowering::CanLowerReturn(
-    CallingConv::ID CallConv, MachineFunction &MF, bool IsVarArg,
-    const SmallVectorImpl<ISD::OutputArg> &Outs, LLVMContext &Context) const {
-  SmallVector<CCValAssign, 16> RVLocs;
-  CCState CCInfo(CallConv, IsVarArg, MF, RVLocs, Context);
-  for (unsigned i = 0, e = Outs.size(); i != e; ++i) {
-    MVT VT = Outs[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Outs[i].Flags;
-    if (CC_RISCV(MF.getDataLayout(), i, VT, VT, CCValAssign::Full, ArgFlags,
-                 CCInfo, /*IsFixed=*/true, /*IsRet=*/true, nullptr))
-      return false;
-  }
-  return true;
-}
-
-SDValue
-RISCVTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv,
-                                 bool IsVarArg,
-                                 const SmallVectorImpl<ISD::OutputArg> &Outs,
-                                 const SmallVectorImpl<SDValue> &OutVals,
-                                 const SDLoc &DL, SelectionDAG &DAG) const {
-  // Stores the assignment of the return value to a location.
-  SmallVector<CCValAssign, 16> RVLocs;
-
-  // Info about the registers and stack slot.
-  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(), RVLocs,
-                 *DAG.getContext());
-
-  analyzeOutputArgs(DAG.getMachineFunction(), CCInfo, Outs, /*IsRet=*/true,
-                    nullptr);
-
-  SDValue Glue;
-  SmallVector<SDValue, 4> RetOps(1, Chain);
-
-  // Copy the result values into the output registers.
-  for (unsigned i = 0, e = RVLocs.size(); i < e; ++i) {
-    SDValue Val = OutVals[i];
-    CCValAssign &VA = RVLocs[i];
-    assert(VA.isRegLoc() && "Can only return in registers!");
-
-    if (VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64) {
-      // Handle returning f64 on RV32D with a soft float ABI.
-      assert(VA.isRegLoc() && "Expected return via registers");
-      SDValue SplitF64 = DAG.getNode(RISCVISD::SplitF64, DL,
-                                     DAG.getVTList(MVT::i32, MVT::i32), Val);
-      SDValue Lo = SplitF64.getValue(0);
-      SDValue Hi = SplitF64.getValue(1);
-      unsigned RegLo = VA.getLocReg();
-      unsigned RegHi = RegLo + 1;
-      Chain = DAG.getCopyToReg(Chain, DL, RegLo, Lo, Glue);
-      Glue = Chain.getValue(1);
-      RetOps.push_back(DAG.getRegister(RegLo, MVT::i32));
-      Chain = DAG.getCopyToReg(Chain, DL, RegHi, Hi, Glue);
-      Glue = Chain.getValue(1);
-      RetOps.push_back(DAG.getRegister(RegHi, MVT::i32));
-    } else {
-      // Handle a 'normal' return.
-      Val = convertValVTToLocVT(DAG, Val, VA, DL);
-      Chain = DAG.getCopyToReg(Chain, DL, VA.getLocReg(), Val, Glue);
-
-      // Guarantee that all emitted copies are stuck together.
-      Glue = Chain.getValue(1);
-      RetOps.push_back(DAG.getRegister(VA.getLocReg(), VA.getLocVT()));
-    }
-  }
-
-  RetOps[0] = Chain; // Update chain.
-
-  // Add the glue node if we have it.
-  if (Glue.getNode()) {
-    RetOps.push_back(Glue);
-  }
-
-  // Interrupt service routines use different return instructions.
-  const Function &Func = DAG.getMachineFunction().getFunction();
-  if (Func.hasFnAttribute("interrupt")) {
-    if (!Func.getReturnType()->isVoidTy())
-      report_fatal_error(
-          "Functions with the interrupt attribute must have void return type!");
-
-    MachineFunction &MF = DAG.getMachineFunction();
-    StringRef Kind =
-      MF.getFunction().getFnAttribute("interrupt").getValueAsString();
-
-    unsigned RetOpc;
-    if (Kind == "user")
-      RetOpc = RISCVISD::URET_FLAG;
-    else if (Kind == "supervisor")
-      RetOpc = RISCVISD::SRET_FLAG;
-    else
-      RetOpc = RISCVISD::MRET_FLAG;
-
-    return DAG.getNode(RetOpc, DL, MVT::Other, RetOps);
-  }
-
-  return DAG.getNode(RISCVISD::RET_FLAG, DL, MVT::Other, RetOps);
-}
-
-const char *RISCVTargetLowering::getTargetNodeName(unsigned Opcode) const {
-  switch ((RISCVISD::NodeType)Opcode) {
-  case RISCVISD::FIRST_NUMBER:
-    break;
-  case RISCVISD::RET_FLAG:
-    return "RISCVISD::RET_FLAG";
-  case RISCVISD::URET_FLAG:
-    return "RISCVISD::URET_FLAG";
-  case RISCVISD::SRET_FLAG:
-    return "RISCVISD::SRET_FLAG";
-  case RISCVISD::MRET_FLAG:
-    return "RISCVISD::MRET_FLAG";
-  case RISCVISD::CALL:
-    return "RISCVISD::CALL";
-  case RISCVISD::SELECT_CC:
-    return "RISCVISD::SELECT_CC";
-  case RISCVISD::BuildPairF64:
-    return "RISCVISD::BuildPairF64";
-  case RISCVISD::SplitF64:
-    return "RISCVISD::SplitF64";
-  case RISCVISD::TAIL:
-    return "RISCVISD::TAIL";
-  }
-  return nullptr;
-}
-
-std::pair<unsigned, const TargetRegisterClass *>
-RISCVTargetLowering::getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
-                                                  StringRef Constraint,
-                                                  MVT VT) const {
-  // First, see if this is a constraint that directly corresponds to a
-  // RISCV register class.
-  if (Constraint.size() == 1) {
-    switch (Constraint[0]) {
-    case 'r':
-      return std::make_pair(0U, &RISCV::GPRRegClass);
-    default:
-      break;
-    }
-  }
-
-  return TargetLowering::getRegForInlineAsmConstraint(TRI, Constraint, VT);
-}
-
-Instruction *RISCVTargetLowering::emitLeadingFence(IRBuilder<> &Builder,
-                                                   Instruction *Inst,
-                                                   AtomicOrdering Ord) const {
-  if (isa<LoadInst>(Inst) && Ord == AtomicOrdering::SequentiallyConsistent)
-    return Builder.CreateFence(Ord);
-  if (isa<StoreInst>(Inst) && isReleaseOrStronger(Ord))
-    return Builder.CreateFence(AtomicOrdering::Release);
-  return nullptr;
-}
-
-Instruction *RISCVTargetLowering::emitTrailingFence(IRBuilder<> &Builder,
-                                                    Instruction *Inst,
-                                                    AtomicOrdering Ord) const {
-  if (isa<LoadInst>(Inst) && isAcquireOrStronger(Ord))
-    return Builder.CreateFence(AtomicOrdering::Acquire);
-  return nullptr;
-}
-
-TargetLowering::AtomicExpansionKind
-RISCVTargetLowering::shouldExpandAtomicRMWInIR(AtomicRMWInst *AI) const {
-  unsigned Size = AI->getType()->getPrimitiveSizeInBits();
-  if (Size == 8 || Size == 16)
-    return AtomicExpansionKind::MaskedIntrinsic;
-  return AtomicExpansionKind::None;
-}
-
-static Intrinsic::ID
-getIntrinsicForMaskedAtomicRMWBinOp32(AtomicRMWInst::BinOp BinOp) {
-  switch (BinOp) {
-  default:
-    llvm_unreachable("Unexpected AtomicRMW BinOp");
-  case AtomicRMWInst::Xchg:
-    return Intrinsic::riscv_masked_atomicrmw_xchg_i32;
-  case AtomicRMWInst::Add:
-    return Intrinsic::riscv_masked_atomicrmw_add_i32;
-  case AtomicRMWInst::Sub:
-    return Intrinsic::riscv_masked_atomicrmw_sub_i32;
-  case AtomicRMWInst::Nand:
-    return Intrinsic::riscv_masked_atomicrmw_nand_i32;
-  case AtomicRMWInst::Max:
-    return Intrinsic::riscv_masked_atomicrmw_max_i32;
-  case AtomicRMWInst::Min:
-    return Intrinsic::riscv_masked_atomicrmw_min_i32;
-  case AtomicRMWInst::UMax:
-    return Intrinsic::riscv_masked_atomicrmw_umax_i32;
-  case AtomicRMWInst::UMin:
-    return Intrinsic::riscv_masked_atomicrmw_umin_i32;
-  }
-}
-
-Value *RISCVTargetLowering::emitMaskedAtomicRMWIntrinsic(
-    IRBuilder<> &Builder, AtomicRMWInst *AI, Value *AlignedAddr, Value *Incr,
-    Value *Mask, Value *ShiftAmt, AtomicOrdering Ord) const {
-  Value *Ordering = Builder.getInt32(static_cast<uint32_t>(AI->getOrdering()));
-  Type *Tys[] = {AlignedAddr->getType()};
-  Function *LrwOpScwLoop = Intrinsic::getDeclaration(
-      AI->getModule(),
-      getIntrinsicForMaskedAtomicRMWBinOp32(AI->getOperation()), Tys);
-
-  // Must pass the shift amount needed to sign extend the loaded value prior
-  // to performing a signed comparison for min/max. ShiftAmt is the number of
-  // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which
-  // is the number of bits to left+right shift the value in order to
-  // sign-extend.
-  if (AI->getOperation() == AtomicRMWInst::Min ||
-      AI->getOperation() == AtomicRMWInst::Max) {
-    const DataLayout &DL = AI->getModule()->getDataLayout();
-    unsigned ValWidth =
-        DL.getTypeStoreSizeInBits(AI->getValOperand()->getType());
-    Value *SextShamt = Builder.CreateSub(
-        Builder.getInt32(Subtarget.getXLen() - ValWidth), ShiftAmt);
-    return Builder.CreateCall(LrwOpScwLoop,
-                              {AlignedAddr, Incr, Mask, SextShamt, Ordering});
-  }
-
-  return Builder.CreateCall(LrwOpScwLoop, {AlignedAddr, Incr, Mask, Ordering});
-}
-
-TargetLowering::AtomicExpansionKind
-RISCVTargetLowering::shouldExpandAtomicCmpXchgInIR(
-    AtomicCmpXchgInst *CI) const {
-  unsigned Size = CI->getCompareOperand()->getType()->getPrimitiveSizeInBits();
-  if (Size == 8 || Size == 16)
-    return AtomicExpansionKind::MaskedIntrinsic;
-  return AtomicExpansionKind::None;
-}
-
-Value *RISCVTargetLowering::emitMaskedAtomicCmpXchgIntrinsic(
-    IRBuilder<> &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,
-    Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {
-  Value *Ordering = Builder.getInt32(static_cast<uint32_t>(Ord));
-  Type *Tys[] = {AlignedAddr->getType()};
-  Function *MaskedCmpXchg = Intrinsic::getDeclaration(
-      CI->getModule(), Intrinsic::riscv_masked_cmpxchg_i32, Tys);
-  return Builder.CreateCall(MaskedCmpXchg,
-                            {AlignedAddr, CmpVal, NewVal, Mask, Ordering});
-}
diff --git a/lib/Target/RISCV/RISCVISelLowering.h b/lib/Target/RISCV/RISCVISelLowering.h
deleted file mode 100644
index 6970900bb06..00000000000
--- a/lib/Target/RISCV/RISCVISelLowering.h
+++ /dev/null
@@ -1,140 +0,0 @@
-//===-- RISCVISelLowering.h - RISCV DAG Lowering Interface ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the interfaces that RISCV uses to lower LLVM code into a
-// selection DAG.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVISELLOWERING_H
-#define LLVM_LIB_TARGET_RISCV_RISCVISELLOWERING_H
-
-#include "RISCV.h"
-#include "llvm/CodeGen/SelectionDAG.h"
-#include "llvm/CodeGen/TargetLowering.h"
-
-namespace llvm {
-class RISCVSubtarget;
-namespace RISCVISD {
-enum NodeType : unsigned {
-  FIRST_NUMBER = ISD::BUILTIN_OP_END,
-  RET_FLAG,
-  URET_FLAG,
-  SRET_FLAG,
-  MRET_FLAG,
-  CALL,
-  SELECT_CC,
-  BuildPairF64,
-  SplitF64,
-  TAIL
-};
-}
-
-class RISCVTargetLowering : public TargetLowering {
-  const RISCVSubtarget &Subtarget;
-
-public:
-  explicit RISCVTargetLowering(const TargetMachine &TM,
-                               const RISCVSubtarget &STI);
-
-  bool getTgtMemIntrinsic(IntrinsicInfo &Info, const CallInst &I,
-                          MachineFunction &MF,
-                          unsigned Intrinsic) const override;
-  bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM, Type *Ty,
-                             unsigned AS,
-                             Instruction *I = nullptr) const override;
-  bool isLegalICmpImmediate(int64_t Imm) const override;
-  bool isLegalAddImmediate(int64_t Imm) const override;
-  bool isTruncateFree(Type *SrcTy, Type *DstTy) const override;
-  bool isTruncateFree(EVT SrcVT, EVT DstVT) const override;
-  bool isZExtFree(SDValue Val, EVT VT2) const override;
-  bool isSExtCheaperThanZExt(EVT SrcVT, EVT DstVT) const override;
-
-  // Provide custom lowering hooks for some operations.
-  SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const override;
-
-  SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const override;
-
-  // This method returns the name of a target specific DAG node.
-  const char *getTargetNodeName(unsigned Opcode) const override;
-
-  std::pair<unsigned, const TargetRegisterClass *>
-  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
-                               StringRef Constraint, MVT VT) const override;
-
-  MachineBasicBlock *
-  EmitInstrWithCustomInserter(MachineInstr &MI,
-                              MachineBasicBlock *BB) const override;
-
-  EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,
-                         EVT VT) const override;
-
-  bool shouldInsertFencesForAtomic(const Instruction *I) const override {
-    return isa<LoadInst>(I) || isa<StoreInst>(I);
-  }
-  Instruction *emitLeadingFence(IRBuilder<> &Builder, Instruction *Inst,
-                                AtomicOrdering Ord) const override;
-  Instruction *emitTrailingFence(IRBuilder<> &Builder, Instruction *Inst,
-                                 AtomicOrdering Ord) const override;
-
-private:
-  void analyzeInputArgs(MachineFunction &MF, CCState &CCInfo,
-                        const SmallVectorImpl<ISD::InputArg> &Ins,
-                        bool IsRet) const;
-  void analyzeOutputArgs(MachineFunction &MF, CCState &CCInfo,
-                         const SmallVectorImpl<ISD::OutputArg> &Outs,
-                         bool IsRet, CallLoweringInfo *CLI) const;
-  // Lower incoming arguments, copy physregs into vregs
-  SDValue LowerFormalArguments(SDValue Chain, CallingConv::ID CallConv,
-                               bool IsVarArg,
-                               const SmallVectorImpl<ISD::InputArg> &Ins,
-                               const SDLoc &DL, SelectionDAG &DAG,
-                               SmallVectorImpl<SDValue> &InVals) const override;
-  bool CanLowerReturn(CallingConv::ID CallConv, MachineFunction &MF,
-                      bool IsVarArg,
-                      const SmallVectorImpl<ISD::OutputArg> &Outs,
-                      LLVMContext &Context) const override;
-  SDValue LowerReturn(SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
-                      const SmallVectorImpl<ISD::OutputArg> &Outs,
-                      const SmallVectorImpl<SDValue> &OutVals, const SDLoc &DL,
-                      SelectionDAG &DAG) const override;
-  SDValue LowerCall(TargetLowering::CallLoweringInfo &CLI,
-                    SmallVectorImpl<SDValue> &InVals) const override;
-  bool shouldConvertConstantLoadToIntImm(const APInt &Imm,
-                                         Type *Ty) const override {
-    return true;
-  }
-  SDValue lowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerBlockAddress(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerConstantPool(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerSELECT(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerVASTART(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerFRAMEADDR(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerRETURNADDR(SDValue Op, SelectionDAG &DAG) const;
-
-  bool IsEligibleForTailCallOptimization(CCState &CCInfo,
-    CallLoweringInfo &CLI, MachineFunction &MF,
-    const SmallVector<CCValAssign, 16> &ArgLocs) const;
-
-  TargetLowering::AtomicExpansionKind
-  shouldExpandAtomicRMWInIR(AtomicRMWInst *AI) const override;
-  virtual Value *emitMaskedAtomicRMWIntrinsic(
-      IRBuilder<> &Builder, AtomicRMWInst *AI, Value *AlignedAddr, Value *Incr,
-      Value *Mask, Value *ShiftAmt, AtomicOrdering Ord) const override;
-  TargetLowering::AtomicExpansionKind
-  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *CI) const override;
-  virtual Value *
-  emitMaskedAtomicCmpXchgIntrinsic(IRBuilder<> &Builder, AtomicCmpXchgInst *CI,
-                                   Value *AlignedAddr, Value *CmpVal,
-                                   Value *NewVal, Value *Mask,
-                                   AtomicOrdering Ord) const override;
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCVInstrFormats.td b/lib/Target/RISCV/RISCVInstrFormats.td
deleted file mode 100644
index ebd676a6056..00000000000
--- a/lib/Target/RISCV/RISCVInstrFormats.td
+++ /dev/null
@@ -1,286 +0,0 @@
-//===-- RISCVInstrFormats.td - RISCV Instruction Formats ---*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-//
-//  These instruction format definitions are structured to match the
-//  description in the RISC-V User-Level ISA specification as closely as
-//  possible. For instance, the specification describes instructions with the
-//  MSB (31st bit) on the left and the LSB (0th bit) on the right. This is
-//  reflected in the order of parameters to each instruction class.
-//
-//  One area of divergence is in the description of immediates. The
-//  specification describes immediate encoding in terms of bit-slicing
-//  operations on the logical value represented. The immediate argument to
-//  these instruction formats instead represents the bit sequence that will be
-//  inserted into the instruction. e.g. although JAL's immediate is logically
-//  a 21-bit value (where the LSB is always zero), we describe it as an imm20
-//  to match how it is encoded.
-//
-//===----------------------------------------------------------------------===//
-
-// Format specifies the encoding used by the instruction. This is used by
-// RISCVMCCodeEmitter to determine which form of fixup to use. These
-// definitions must be kept in-sync with RISCVBaseInfo.h.
-class InstFormat<bits<5> val> {
-  bits<5> Value = val;
-}
-def InstFormatPseudo : InstFormat<0>;
-def InstFormatR      : InstFormat<1>;
-def InstFormatR4     : InstFormat<2>;
-def InstFormatI      : InstFormat<3>;
-def InstFormatS      : InstFormat<4>;
-def InstFormatB      : InstFormat<5>;
-def InstFormatU      : InstFormat<6>;
-def InstFormatJ      : InstFormat<7>;
-def InstFormatCR     : InstFormat<8>;
-def InstFormatCI     : InstFormat<9>;
-def InstFormatCSS    : InstFormat<10>;
-def InstFormatCIW    : InstFormat<11>;
-def InstFormatCL     : InstFormat<12>;
-def InstFormatCS     : InstFormat<13>;
-def InstFormatCA     : InstFormat<14>;
-def InstFormatCB     : InstFormat<15>;
-def InstFormatCJ     : InstFormat<16>;
-def InstFormatOther  : InstFormat<17>;
-
-// The following opcode names match those given in Table 19.1 in the
-// RISC-V User-level ISA specification ("RISC-V base opcode map").
-class RISCVOpcode<bits<7> val> {
-  bits<7> Value = val;
-}
-def OPC_LOAD      : RISCVOpcode<0b0000011>;
-def OPC_LOAD_FP   : RISCVOpcode<0b0000111>;
-def OPC_MISC_MEM  : RISCVOpcode<0b0001111>;
-def OPC_OP_IMM    : RISCVOpcode<0b0010011>;
-def OPC_AUIPC     : RISCVOpcode<0b0010111>;
-def OPC_OP_IMM_32 : RISCVOpcode<0b0011011>;
-def OPC_STORE     : RISCVOpcode<0b0100011>;
-def OPC_STORE_FP  : RISCVOpcode<0b0100111>;
-def OPC_AMO       : RISCVOpcode<0b0101111>;
-def OPC_OP        : RISCVOpcode<0b0110011>;
-def OPC_LUI       : RISCVOpcode<0b0110111>;
-def OPC_OP_32     : RISCVOpcode<0b0111011>;
-def OPC_MADD      : RISCVOpcode<0b1000011>;
-def OPC_MSUB      : RISCVOpcode<0b1000111>;
-def OPC_NMSUB     : RISCVOpcode<0b1001011>;
-def OPC_NMADD     : RISCVOpcode<0b1001111>;
-def OPC_OP_FP     : RISCVOpcode<0b1010011>;
-def OPC_BRANCH    : RISCVOpcode<0b1100011>;
-def OPC_JALR      : RISCVOpcode<0b1100111>;
-def OPC_JAL       : RISCVOpcode<0b1101111>;
-def OPC_SYSTEM    : RISCVOpcode<0b1110011>;
-
-class RVInst<dag outs, dag ins, string opcodestr, string argstr,
-             list<dag> pattern, InstFormat format>
-    : Instruction {
-  field bits<32> Inst;
-  // SoftFail is a field the disassembler can use to provide a way for
-  // instructions to not match without killing the whole decode process. It is
-  // mainly used for ARM, but Tablegen expects this field to exist or it fails
-  // to build the decode table.
-  field bits<32> SoftFail = 0;
-  let Size = 4;
-
-  bits<7> Opcode = 0;
-
-  let Inst{6-0} = Opcode;
-
-  let Namespace = "RISCV";
-
-  dag OutOperandList = outs;
-  dag InOperandList = ins;
-  let AsmString = opcodestr # "\t" # argstr;
-  let Pattern = pattern;
-
-  let TSFlags{4-0} = format.Value;
-}
-
-// Pseudo instructions
-class Pseudo<dag outs, dag ins, list<dag> pattern, string opcodestr = "", string argstr = "">
-    : RVInst<outs, ins, opcodestr, argstr, pattern, InstFormatPseudo> {
-  let isPseudo = 1;
-  let isCodeGenOnly = 1;
-}
-
-// Instruction formats are listed in the order they appear in the RISC-V
-// instruction set manual (R, I, S, B, U, J) with sub-formats (e.g. RVInstR4,
-// RVInstRAtomic) sorted alphabetically.
-
-class RVInstR<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, dag outs,
-              dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-25} = funct7;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstR4<bits<2> funct2, RISCVOpcode opcode, dag outs, dag ins,
-               string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR4> {
-  bits<5> rs3;
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<3> funct3;
-  bits<5> rd;
-
-  let Inst{31-27} = rs3;
-  let Inst{26-25} = funct2;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstRAtomic<bits<5> funct5, bit aq, bit rl, bits<3> funct3,
-                    RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-                    string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-27} = funct5;
-  let Inst{26} = aq;
-  let Inst{25} = rl;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstRFrm<bits<7> funct7, RISCVOpcode opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<3> funct3;
-  bits<5> rd;
-
-  let Inst{31-25} = funct7;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstI<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<12> imm12;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-20} = imm12;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstIShift<bit arithshift, bits<3> funct3, RISCVOpcode opcode,
-                   dag outs, dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<6> shamt;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31} = 0;
-  let Inst{30} = arithshift;
-  let Inst{29-26} = 0;
-  let Inst{25-20} = shamt;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstIShiftW<bit arithshift, bits<3> funct3, RISCVOpcode opcode,
-                    dag outs, dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<5> shamt;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31} = 0;
-  let Inst{30} = arithshift;
-  let Inst{29-25} = 0;
-  let Inst{24-20} = shamt;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstS<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatS> {
-  bits<12> imm12;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{31-25} = imm12{11-5};
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = imm12{4-0};
-  let Opcode = opcode.Value;
-}
-
-class RVInstB<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatB> {
-  bits<12> imm12;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{31} = imm12{11};
-  let Inst{30-25} = imm12{9-4};
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-8} = imm12{3-0};
-  let Inst{7} = imm12{10};
-  let Opcode = opcode.Value;
-}
-
-class RVInstU<RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-              string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatU> {
-  bits<20> imm20;
-  bits<5> rd;
-
-  let Inst{31-12} = imm20;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstJ<RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-              string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatJ> {
-  bits<20> imm20;
-  bits<5> rd;
-
-  let Inst{31} = imm20{19};
-  let Inst{30-21} = imm20{9-0};
-  let Inst{20} = imm20{10};
-  let Inst{19-12} = imm20{18-11};
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
diff --git a/lib/Target/RISCV/RISCVInstrFormatsC.td b/lib/Target/RISCV/RISCVInstrFormatsC.td
deleted file mode 100644
index bda8bbb558e..00000000000
--- a/lib/Target/RISCV/RISCVInstrFormatsC.td
+++ /dev/null
@@ -1,160 +0,0 @@
-//===-- RISCVInstrFormatsC.td - RISCV C Instruction Formats --*- tablegen -*-=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-//  This file describes the RISC-V C extension instruction formats.
-//
-//===----------------------------------------------------------------------===//
-
-class RVInst16<dag outs, dag ins, string opcodestr, string argstr,
-               list<dag> pattern, InstFormat format>
-    : Instruction {
-  field bits<16> Inst;
-  // SoftFail is a field the disassembler can use to provide a way for
-  // instructions to not match without killing the whole decode process. It is
-  // mainly used for ARM, but Tablegen expects this field to exist or it fails
-  // to build the decode table.
-  field bits<16> SoftFail = 0;
-  let Size = 2;
-
-  bits<2> Opcode = 0;
-
-  let Namespace = "RISCV";
-
-  dag OutOperandList = outs;
-  dag InOperandList = ins;
-  let AsmString = opcodestr # "\t" # argstr;
-  let Pattern = pattern;
-
-  let TSFlags{4-0} = format.Value;
-}
-
-class RVInst16CR<bits<4> funct4, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCR> {
-  bits<5> rs1;
-  bits<5> rs2;
-
-  let Inst{15-12} = funct4;
-  let Inst{11-7} = rs1;
-  let Inst{6-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{6-2} must be set for each instruction.
-class RVInst16CI<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCI> {
-  bits<10> imm;
-  bits<5> rd;
-  bits<5> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{12} = imm{5};
-  let Inst{11-7} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-7} must be set for each instruction.
-class RVInst16CSS<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                  string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCSS> {
-  bits<10> imm;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{6-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CIW<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                  string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCIW> {
-  bits<10> imm;
-  bits<3> rd;
-
-  let Inst{15-13} = funct3;
-  let Inst{4-2} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-10} and Inst{6-5} must be set for each instruction.
-class RVInst16CL<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCL> {
-  bits<3> rd;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{4-2} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-10} and Inst{6-5} must be set for each instruction.
-class RVInst16CS<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCS> {
-  bits<3> rs2;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{4-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CA<bits<6> funct6, bits<2> funct2, bits<2> opcode, dag outs,
-                 dag ins, string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCA> {
-  bits<3> rs2;
-  bits<3> rs1;
-
-  let Inst{15-10} = funct6;
-  let Inst{9-7} = rs1;
-  let Inst{6-5} = funct2;
-  let Inst{4-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CB<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCB> {
-  bits<9> imm;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CJ<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCJ> {
-  bits<11> offset;
-
-  let Inst{15-13} = funct3;
-  let Inst{12} = offset{10};
-  let Inst{11} = offset{3};
-  let Inst{10-9} = offset{8-7};
-  let Inst{8} = offset{9};
-  let Inst{7} = offset{5};
-  let Inst{6} = offset{6};
-  let Inst{5-3} = offset{2-0};
-  let Inst{2} = offset{4};
-  let Inst{1-0} = opcode;
-}
diff --git a/lib/Target/RISCV/RISCVInstrInfo.cpp b/lib/Target/RISCV/RISCVInstrInfo.cpp
deleted file mode 100644
index 76c74368ca1..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.cpp
+++ /dev/null
@@ -1,450 +0,0 @@
-//===-- RISCVInstrInfo.cpp - RISCV Instruction Information ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetInstrInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVInstrInfo.h"
-#include "RISCV.h"
-#include "RISCVSubtarget.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/TargetRegistry.h"
-
-#define GET_INSTRINFO_CTOR_DTOR
-#include "RISCVGenInstrInfo.inc"
-
-using namespace llvm;
-
-RISCVInstrInfo::RISCVInstrInfo()
-    : RISCVGenInstrInfo(RISCV::ADJCALLSTACKDOWN, RISCV::ADJCALLSTACKUP) {}
-
-unsigned RISCVInstrInfo::isLoadFromStackSlot(const MachineInstr &MI,
-                                             int &FrameIndex) const {
-  switch (MI.getOpcode()) {
-  default:
-    return 0;
-  case RISCV::LB:
-  case RISCV::LBU:
-  case RISCV::LH:
-  case RISCV::LHU:
-  case RISCV::LW:
-  case RISCV::FLW:
-  case RISCV::LWU:
-  case RISCV::LD:
-  case RISCV::FLD:
-    break;
-  }
-
-  if (MI.getOperand(1).isFI() && MI.getOperand(2).isImm() &&
-      MI.getOperand(2).getImm() == 0) {
-    FrameIndex = MI.getOperand(1).getIndex();
-    return MI.getOperand(0).getReg();
-  }
-
-  return 0;
-}
-
-unsigned RISCVInstrInfo::isStoreToStackSlot(const MachineInstr &MI,
-                                            int &FrameIndex) const {
-  switch (MI.getOpcode()) {
-  default:
-    return 0;
-  case RISCV::SB:
-  case RISCV::SH:
-  case RISCV::SW:
-  case RISCV::FSW:
-  case RISCV::SD:
-  case RISCV::FSD:
-    break;
-  }
-
-  if (MI.getOperand(0).isFI() && MI.getOperand(1).isImm() &&
-      MI.getOperand(1).getImm() == 0) {
-    FrameIndex = MI.getOperand(0).getIndex();
-    return MI.getOperand(2).getReg();
-  }
-
-  return 0;
-}
-
-void RISCVInstrInfo::copyPhysReg(MachineBasicBlock &MBB,
-                                 MachineBasicBlock::iterator MBBI,
-                                 const DebugLoc &DL, unsigned DstReg,
-                                 unsigned SrcReg, bool KillSrc) const {
-  if (RISCV::GPRRegClass.contains(DstReg, SrcReg)) {
-    BuildMI(MBB, MBBI, DL, get(RISCV::ADDI), DstReg)
-        .addReg(SrcReg, getKillRegState(KillSrc))
-        .addImm(0);
-    return;
-  }
-
-  // FPR->FPR copies
-  unsigned Opc;
-  if (RISCV::FPR32RegClass.contains(DstReg, SrcReg))
-    Opc = RISCV::FSGNJ_S;
-  else if (RISCV::FPR64RegClass.contains(DstReg, SrcReg))
-    Opc = RISCV::FSGNJ_D;
-  else
-    llvm_unreachable("Impossible reg-to-reg copy");
-
-  BuildMI(MBB, MBBI, DL, get(Opc), DstReg)
-      .addReg(SrcReg, getKillRegState(KillSrc))
-      .addReg(SrcReg, getKillRegState(KillSrc));
-}
-
-void RISCVInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
-                                         MachineBasicBlock::iterator I,
-                                         unsigned SrcReg, bool IsKill, int FI,
-                                         const TargetRegisterClass *RC,
-                                         const TargetRegisterInfo *TRI) const {
-  DebugLoc DL;
-  if (I != MBB.end())
-    DL = I->getDebugLoc();
-
-  unsigned Opcode;
-
-  if (RISCV::GPRRegClass.hasSubClassEq(RC))
-    Opcode = TRI->getRegSizeInBits(RISCV::GPRRegClass) == 32 ?
-             RISCV::SW : RISCV::SD;
-  else if (RISCV::FPR32RegClass.hasSubClassEq(RC))
-    Opcode = RISCV::FSW;
-  else if (RISCV::FPR64RegClass.hasSubClassEq(RC))
-    Opcode = RISCV::FSD;
-  else
-    llvm_unreachable("Can't store this register to stack slot");
-
-  BuildMI(MBB, I, DL, get(Opcode))
-      .addReg(SrcReg, getKillRegState(IsKill))
-      .addFrameIndex(FI)
-      .addImm(0);
-}
-
-void RISCVInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
-                                          MachineBasicBlock::iterator I,
-                                          unsigned DstReg, int FI,
-                                          const TargetRegisterClass *RC,
-                                          const TargetRegisterInfo *TRI) const {
-  DebugLoc DL;
-  if (I != MBB.end())
-    DL = I->getDebugLoc();
-
-  unsigned Opcode;
-
-  if (RISCV::GPRRegClass.hasSubClassEq(RC))
-    Opcode = TRI->getRegSizeInBits(RISCV::GPRRegClass) == 32 ?
-             RISCV::LW : RISCV::LD;
-  else if (RISCV::FPR32RegClass.hasSubClassEq(RC))
-    Opcode = RISCV::FLW;
-  else if (RISCV::FPR64RegClass.hasSubClassEq(RC))
-    Opcode = RISCV::FLD;
-  else
-    llvm_unreachable("Can't load this register from stack slot");
-
-  BuildMI(MBB, I, DL, get(Opcode), DstReg).addFrameIndex(FI).addImm(0);
-}
-
-void RISCVInstrInfo::movImm32(MachineBasicBlock &MBB,
-                              MachineBasicBlock::iterator MBBI,
-                              const DebugLoc &DL, unsigned DstReg, uint64_t Val,
-                              MachineInstr::MIFlag Flag) const {
-  assert(isInt<32>(Val) && "Can only materialize 32-bit constants");
-
-  // TODO: If the value can be materialized using only one instruction, only
-  // insert a single instruction.
-
-  uint64_t Hi20 = ((Val + 0x800) >> 12) & 0xfffff;
-  uint64_t Lo12 = SignExtend64<12>(Val);
-  BuildMI(MBB, MBBI, DL, get(RISCV::LUI), DstReg)
-      .addImm(Hi20)
-      .setMIFlag(Flag);
-  BuildMI(MBB, MBBI, DL, get(RISCV::ADDI), DstReg)
-      .addReg(DstReg, RegState::Kill)
-      .addImm(Lo12)
-      .setMIFlag(Flag);
-}
-
-// The contents of values added to Cond are not examined outside of
-// RISCVInstrInfo, giving us flexibility in what to push to it. For RISCV, we
-// push BranchOpcode, Reg1, Reg2.
-static void parseCondBranch(MachineInstr &LastInst, MachineBasicBlock *&Target,
-                            SmallVectorImpl<MachineOperand> &Cond) {
-  // Block ends with fall-through condbranch.
-  assert(LastInst.getDesc().isConditionalBranch() &&
-         "Unknown conditional branch");
-  Target = LastInst.getOperand(2).getMBB();
-  Cond.push_back(MachineOperand::CreateImm(LastInst.getOpcode()));
-  Cond.push_back(LastInst.getOperand(0));
-  Cond.push_back(LastInst.getOperand(1));
-}
-
-static unsigned getOppositeBranchOpcode(int Opc) {
-  switch (Opc) {
-  default:
-    llvm_unreachable("Unrecognized conditional branch");
-  case RISCV::BEQ:
-    return RISCV::BNE;
-  case RISCV::BNE:
-    return RISCV::BEQ;
-  case RISCV::BLT:
-    return RISCV::BGE;
-  case RISCV::BGE:
-    return RISCV::BLT;
-  case RISCV::BLTU:
-    return RISCV::BGEU;
-  case RISCV::BGEU:
-    return RISCV::BLTU;
-  }
-}
-
-bool RISCVInstrInfo::analyzeBranch(MachineBasicBlock &MBB,
-                                   MachineBasicBlock *&TBB,
-                                   MachineBasicBlock *&FBB,
-                                   SmallVectorImpl<MachineOperand> &Cond,
-                                   bool AllowModify) const {
-  TBB = FBB = nullptr;
-  Cond.clear();
-
-  // If the block has no terminators, it just falls into the block after it.
-  MachineBasicBlock::iterator I = MBB.getLastNonDebugInstr();
-  if (I == MBB.end() || !isUnpredicatedTerminator(*I))
-    return false;
-
-  // Count the number of terminators and find the first unconditional or
-  // indirect branch.
-  MachineBasicBlock::iterator FirstUncondOrIndirectBr = MBB.end();
-  int NumTerminators = 0;
-  for (auto J = I.getReverse(); J != MBB.rend() && isUnpredicatedTerminator(*J);
-       J++) {
-    NumTerminators++;
-    if (J->getDesc().isUnconditionalBranch() ||
-        J->getDesc().isIndirectBranch()) {
-      FirstUncondOrIndirectBr = J.getReverse();
-    }
-  }
-
-  // If AllowModify is true, we can erase any terminators after
-  // FirstUncondOrIndirectBR.
-  if (AllowModify && FirstUncondOrIndirectBr != MBB.end()) {
-    while (std::next(FirstUncondOrIndirectBr) != MBB.end()) {
-      std::next(FirstUncondOrIndirectBr)->eraseFromParent();
-      NumTerminators--;
-    }
-    I = FirstUncondOrIndirectBr;
-  }
-
-  // We can't handle blocks that end in an indirect branch.
-  if (I->getDesc().isIndirectBranch())
-    return true;
-
-  // We can't handle blocks with more than 2 terminators.
-  if (NumTerminators > 2)
-    return true;
-
-  // Handle a single unconditional branch.
-  if (NumTerminators == 1 && I->getDesc().isUnconditionalBranch()) {
-    TBB = I->getOperand(0).getMBB();
-    return false;
-  }
-
-  // Handle a single conditional branch.
-  if (NumTerminators == 1 && I->getDesc().isConditionalBranch()) {
-    parseCondBranch(*I, TBB, Cond);
-    return false;
-  }
-
-  // Handle a conditional branch followed by an unconditional branch.
-  if (NumTerminators == 2 && std::prev(I)->getDesc().isConditionalBranch() &&
-      I->getDesc().isUnconditionalBranch()) {
-    parseCondBranch(*std::prev(I), TBB, Cond);
-    FBB = I->getOperand(0).getMBB();
-    return false;
-  }
-
-  // Otherwise, we can't handle this.
-  return true;
-}
-
-unsigned RISCVInstrInfo::removeBranch(MachineBasicBlock &MBB,
-                                      int *BytesRemoved) const {
-  if (BytesRemoved)
-    *BytesRemoved = 0;
-  MachineBasicBlock::iterator I = MBB.getLastNonDebugInstr();
-  if (I == MBB.end())
-    return 0;
-
-  if (!I->getDesc().isUnconditionalBranch() &&
-      !I->getDesc().isConditionalBranch())
-    return 0;
-
-  // Remove the branch.
-  I->eraseFromParent();
-  if (BytesRemoved)
-    *BytesRemoved += getInstSizeInBytes(*I);
-
-  I = MBB.end();
-
-  if (I == MBB.begin())
-    return 1;
-  --I;
-  if (!I->getDesc().isConditionalBranch())
-    return 1;
-
-  // Remove the branch.
-  I->eraseFromParent();
-  if (BytesRemoved)
-    *BytesRemoved += getInstSizeInBytes(*I);
-  return 2;
-}
-
-// Inserts a branch into the end of the specific MachineBasicBlock, returning
-// the number of instructions inserted.
-unsigned RISCVInstrInfo::insertBranch(
-    MachineBasicBlock &MBB, MachineBasicBlock *TBB, MachineBasicBlock *FBB,
-    ArrayRef<MachineOperand> Cond, const DebugLoc &DL, int *BytesAdded) const {
-  if (BytesAdded)
-    *BytesAdded = 0;
-
-  // Shouldn't be a fall through.
-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");
-  assert((Cond.size() == 3 || Cond.size() == 0) &&
-         "RISCV branch conditions have two components!");
-
-  // Unconditional branch.
-  if (Cond.empty()) {
-    MachineInstr &MI = *BuildMI(&MBB, DL, get(RISCV::PseudoBR)).addMBB(TBB);
-    if (BytesAdded)
-      *BytesAdded += getInstSizeInBytes(MI);
-    return 1;
-  }
-
-  // Either a one or two-way conditional branch.
-  unsigned Opc = Cond[0].getImm();
-  MachineInstr &CondMI =
-      *BuildMI(&MBB, DL, get(Opc)).add(Cond[1]).add(Cond[2]).addMBB(TBB);
-  if (BytesAdded)
-    *BytesAdded += getInstSizeInBytes(CondMI);
-
-  // One-way conditional branch.
-  if (!FBB)
-    return 1;
-
-  // Two-way conditional branch.
-  MachineInstr &MI = *BuildMI(&MBB, DL, get(RISCV::PseudoBR)).addMBB(FBB);
-  if (BytesAdded)
-    *BytesAdded += getInstSizeInBytes(MI);
-  return 2;
-}
-
-unsigned RISCVInstrInfo::insertIndirectBranch(MachineBasicBlock &MBB,
-                                              MachineBasicBlock &DestBB,
-                                              const DebugLoc &DL,
-                                              int64_t BrOffset,
-                                              RegScavenger *RS) const {
-  assert(RS && "RegScavenger required for long branching");
-  assert(MBB.empty() &&
-         "new block should be inserted for expanding unconditional branch");
-  assert(MBB.pred_size() == 1);
-
-  MachineFunction *MF = MBB.getParent();
-  MachineRegisterInfo &MRI = MF->getRegInfo();
-  const auto &TM = static_cast<const RISCVTargetMachine &>(MF->getTarget());
-
-  if (TM.isPositionIndependent())
-    report_fatal_error("Unable to insert indirect branch");
-
-  if (!isInt<32>(BrOffset))
-    report_fatal_error(
-        "Branch offsets outside of the signed 32-bit range not supported");
-
-  // FIXME: A virtual register must be used initially, as the register
-  // scavenger won't work with empty blocks (SIInstrInfo::insertIndirectBranch
-  // uses the same workaround).
-  unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-  auto II = MBB.end();
-
-  MachineInstr &LuiMI = *BuildMI(MBB, II, DL, get(RISCV::LUI), ScratchReg)
-                             .addMBB(&DestBB, RISCVII::MO_HI);
-  BuildMI(MBB, II, DL, get(RISCV::PseudoBRIND))
-      .addReg(ScratchReg, RegState::Kill)
-      .addMBB(&DestBB, RISCVII::MO_LO);
-
-  RS->enterBasicBlockEnd(MBB);
-  unsigned Scav = RS->scavengeRegisterBackwards(
-      RISCV::GPRRegClass, MachineBasicBlock::iterator(LuiMI), false, 0);
-  MRI.replaceRegWith(ScratchReg, Scav);
-  MRI.clearVirtRegs();
-  RS->setRegUsed(Scav);
-  return 8;
-}
-
-bool RISCVInstrInfo::reverseBranchCondition(
-    SmallVectorImpl<MachineOperand> &Cond) const {
-  assert((Cond.size() == 3) && "Invalid branch condition!");
-  Cond[0].setImm(getOppositeBranchOpcode(Cond[0].getImm()));
-  return false;
-}
-
-MachineBasicBlock *
-RISCVInstrInfo::getBranchDestBlock(const MachineInstr &MI) const {
-  assert(MI.getDesc().isBranch() && "Unexpected opcode!");
-  // The branch target is always the last operand.
-  int NumOp = MI.getNumExplicitOperands();
-  return MI.getOperand(NumOp - 1).getMBB();
-}
-
-bool RISCVInstrInfo::isBranchOffsetInRange(unsigned BranchOp,
-                                           int64_t BrOffset) const {
-  // Ideally we could determine the supported branch offset from the
-  // RISCVII::FormMask, but this can't be used for Pseudo instructions like
-  // PseudoBR.
-  switch (BranchOp) {
-  default:
-    llvm_unreachable("Unexpected opcode!");
-  case RISCV::BEQ:
-  case RISCV::BNE:
-  case RISCV::BLT:
-  case RISCV::BGE:
-  case RISCV::BLTU:
-  case RISCV::BGEU:
-    return isIntN(13, BrOffset);
-  case RISCV::JAL:
-  case RISCV::PseudoBR:
-    return isIntN(21, BrOffset);
-  }
-}
-
-unsigned RISCVInstrInfo::getInstSizeInBytes(const MachineInstr &MI) const {
-  unsigned Opcode = MI.getOpcode();
-
-  switch (Opcode) {
-  default: { return get(Opcode).getSize(); }
-  case TargetOpcode::EH_LABEL:
-  case TargetOpcode::IMPLICIT_DEF:
-  case TargetOpcode::KILL:
-  case TargetOpcode::DBG_VALUE:
-    return 0;
-  case RISCV::PseudoCALL:
-  case RISCV::PseudoTAIL:
-    return 8;
-  case TargetOpcode::INLINEASM: {
-    const MachineFunction &MF = *MI.getParent()->getParent();
-    const auto &TM = static_cast<const RISCVTargetMachine &>(MF.getTarget());
-    return getInlineAsmLength(MI.getOperand(0).getSymbolName(),
-                              *TM.getMCAsmInfo());
-  }
-  }
-}
diff --git a/lib/Target/RISCV/RISCVInstrInfo.h b/lib/Target/RISCV/RISCVInstrInfo.h
deleted file mode 100644
index 1d3279c3d31..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.h
+++ /dev/null
@@ -1,84 +0,0 @@
-//===-- RISCVInstrInfo.h - RISCV Instruction Information --------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetInstrInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVINSTRINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVINSTRINFO_H
-
-#include "RISCVRegisterInfo.h"
-#include "llvm/CodeGen/TargetInstrInfo.h"
-
-#define GET_INSTRINFO_HEADER
-#include "RISCVGenInstrInfo.inc"
-
-namespace llvm {
-
-class RISCVInstrInfo : public RISCVGenInstrInfo {
-
-public:
-  RISCVInstrInfo();
-
-  unsigned isLoadFromStackSlot(const MachineInstr &MI,
-                               int &FrameIndex) const override;
-  unsigned isStoreToStackSlot(const MachineInstr &MI,
-                              int &FrameIndex) const override;
-
-  void copyPhysReg(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                   const DebugLoc &DL, unsigned DstReg, unsigned SrcReg,
-                   bool KillSrc) const override;
-
-  void storeRegToStackSlot(MachineBasicBlock &MBB,
-                           MachineBasicBlock::iterator MBBI, unsigned SrcReg,
-                           bool IsKill, int FrameIndex,
-                           const TargetRegisterClass *RC,
-                           const TargetRegisterInfo *TRI) const override;
-
-  void loadRegFromStackSlot(MachineBasicBlock &MBB,
-                            MachineBasicBlock::iterator MBBI, unsigned DstReg,
-                            int FrameIndex, const TargetRegisterClass *RC,
-                            const TargetRegisterInfo *TRI) const override;
-
-  // Materializes the given int32 Val into DstReg.
-  void movImm32(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                const DebugLoc &DL, unsigned DstReg, uint64_t Val,
-                MachineInstr::MIFlag Flag = MachineInstr::NoFlags) const;
-
-  unsigned getInstSizeInBytes(const MachineInstr &MI) const override;
-
-  bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,
-                     MachineBasicBlock *&FBB,
-                     SmallVectorImpl<MachineOperand> &Cond,
-                     bool AllowModify) const override;
-
-  unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,
-                        MachineBasicBlock *FBB, ArrayRef<MachineOperand> Cond,
-                        const DebugLoc &dl,
-                        int *BytesAdded = nullptr) const override;
-
-  unsigned insertIndirectBranch(MachineBasicBlock &MBB,
-                                MachineBasicBlock &NewDestBB,
-                                const DebugLoc &DL, int64_t BrOffset,
-                                RegScavenger *RS = nullptr) const override;
-
-  unsigned removeBranch(MachineBasicBlock &MBB,
-                        int *BytesRemoved = nullptr) const override;
-
-  bool
-  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const override;
-
-  MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const override;
-
-  bool isBranchOffsetInRange(unsigned BranchOpc,
-                             int64_t BrOffset) const override;
-};
-}
-#endif
diff --git a/lib/Target/RISCV/RISCVInstrInfo.td b/lib/Target/RISCV/RISCVInstrInfo.td
deleted file mode 100644
index 60c0f0b96a6..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.td
+++ /dev/null
@@ -1,935 +0,0 @@
-//===-- RISCVInstrInfo.td - Target Description for RISCV ---*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions in TableGen format.
-//
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrFormats.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V specific DAG Nodes.
-//===----------------------------------------------------------------------===//
-
-def SDT_RISCVCall         : SDTypeProfile<0, -1, [SDTCisVT<0, XLenVT>]>;
-def SDT_RISCVCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
-                                            SDTCisVT<1, i32>]>;
-def SDT_RISCVCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>,
-                                          SDTCisVT<1, i32>]>;
-def SDT_RISCVSelectCC     : SDTypeProfile<1, 5, [SDTCisSameAs<1, 2>,
-                                                 SDTCisSameAs<0, 4>,
-                                                 SDTCisSameAs<4, 5>]>;
-
-
-def Call         : SDNode<"RISCVISD::CALL", SDT_RISCVCall,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
-                           SDNPVariadic]>;
-def CallSeqStart : SDNode<"ISD::CALLSEQ_START", SDT_RISCVCallSeqStart,
-                          [SDNPHasChain, SDNPOutGlue]>;
-def CallSeqEnd   : SDNode<"ISD::CALLSEQ_END", SDT_RISCVCallSeqEnd,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
-def RetFlag      : SDNode<"RISCVISD::RET_FLAG", SDTNone,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
-def URetFlag     : SDNode<"RISCVISD::URET_FLAG", SDTNone,
-                          [SDNPHasChain, SDNPOptInGlue]>;
-def SRetFlag     : SDNode<"RISCVISD::SRET_FLAG", SDTNone,
-                          [SDNPHasChain, SDNPOptInGlue]>;
-def MRetFlag     : SDNode<"RISCVISD::MRET_FLAG", SDTNone,
-                          [SDNPHasChain, SDNPOptInGlue]>;
-def SelectCC     : SDNode<"RISCVISD::SELECT_CC", SDT_RISCVSelectCC,
-                          [SDNPInGlue]>;
-def Tail         : SDNode<"RISCVISD::TAIL", SDT_RISCVCall,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
-                           SDNPVariadic]>;
-
-//===----------------------------------------------------------------------===//
-// Operand and SDNode transformation definitions.
-//===----------------------------------------------------------------------===//
-
-class ImmXLenAsmOperand<string prefix, string suffix = ""> : AsmOperandClass {
-  let Name = prefix # "ImmXLen" # suffix;
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = !strconcat("Invalid", Name);
-}
-
-class ImmAsmOperand<string prefix, int width, string suffix> : AsmOperandClass {
-  let Name = prefix # "Imm" # width # suffix;
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = !strconcat("Invalid", Name);
-}
-
-class SImmAsmOperand<int width, string suffix = "">
-    : ImmAsmOperand<"S", width, suffix> {
-}
-
-class UImmAsmOperand<int width, string suffix = "">
-    : ImmAsmOperand<"U", width, suffix> {
-}
-
-def FenceArg : AsmOperandClass {
-  let Name = "FenceArg";
-  let RenderMethod = "addFenceArgOperands";
-  let DiagnosticType = "InvalidFenceArg";
-}
-
-def fencearg : Operand<XLenVT> {
-  let ParserMatchClass = FenceArg;
-  let PrintMethod = "printFenceArg";
-  let DecoderMethod = "decodeUImmOperand<4>";
-}
-
-def UImmLog2XLenAsmOperand : AsmOperandClass {
-  let Name = "UImmLog2XLen";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = "InvalidUImmLog2XLen";
-}
-
-def uimmlog2xlen : Operand<XLenVT>, ImmLeaf<XLenVT, [{
-  if (Subtarget->is64Bit())
-    return isUInt<6>(Imm);
-  return isUInt<5>(Imm);
-}]> {
-  let ParserMatchClass = UImmLog2XLenAsmOperand;
-  // TODO: should ensure invalid shamt is rejected when decoding.
-  let DecoderMethod = "decodeUImmOperand<6>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    if (STI.getTargetTriple().isArch64Bit())
-      return  isUInt<6>(Imm);
-    return isUInt<5>(Imm);
-  }];
-}
-
-def uimm5 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<5>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<5>;
-  let DecoderMethod = "decodeUImmOperand<5>";
-}
-
-def simm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<12>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<12>;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<12>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isInt<12>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-// A 13-bit signed immediate where the least significant bit is zero.
-def simm13_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<13, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<13>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isShiftedInt<12, 1>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-class UImm20Operand : Operand<XLenVT> {
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<20>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isUInt<20>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-def uimm20_lui : UImm20Operand {
-  let ParserMatchClass = UImmAsmOperand<20, "LUI">;
-}
-def uimm20_auipc : UImm20Operand {
-  let ParserMatchClass = UImmAsmOperand<20, "AUIPC">;
-}
-
-def Simm21Lsb0JALAsmOperand : SImmAsmOperand<21, "Lsb0JAL"> {
-  let ParserMethod = "parseJALOffset";
-}
-
-// A 21-bit signed immediate where the least significant bit is zero.
-def simm21_lsb0_jal : Operand<OtherVT> {
-  let ParserMatchClass = Simm21Lsb0JALAsmOperand;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isShiftedInt<20, 1>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-def BareSymbol : AsmOperandClass {
-  let Name = "BareSymbol";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = "InvalidBareSymbol";
-  let ParserMethod = "parseBareSymbol";
-}
-
-// A bare symbol.
-def bare_symbol : Operand<XLenVT> {
-  let ParserMatchClass = BareSymbol;
-}
-
-def CSRSystemRegister : AsmOperandClass {
-  let Name = "CSRSystemRegister";
-  let ParserMethod = "parseCSRSystemRegister";
-  let DiagnosticType = "InvalidCSRSystemRegister";
-}
-
-def csr_sysreg : Operand<XLenVT> {
-  let ParserMatchClass = CSRSystemRegister;
-  let PrintMethod = "printCSRSystemRegister";
-  let DecoderMethod = "decodeUImmOperand<12>";
-}
-
-// A parameterized register class alternative to i32imm/i64imm from Target.td.
-def ixlenimm : Operand<XLenVT> {
-  let ParserMatchClass = ImmXLenAsmOperand<"">;
-}
-
-// Standalone (codegen-only) immleaf patterns.
-def simm32     : ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;
-def simm32hi20 : ImmLeaf<XLenVT, [{return isShiftedInt<20, 12>(Imm);}]>;
-// A mask value that won't affect significant shift bits.
-def immbottomxlenset : ImmLeaf<XLenVT, [{
-  if (Subtarget->is64Bit())
-    return countTrailingOnes<uint64_t>(Imm) >= 6;
-  return countTrailingOnes<uint64_t>(Imm) >= 5;
-}]>;
-
-// Addressing modes.
-// Necessary because a frameindex can't be matched directly in a pattern.
-def AddrFI : ComplexPattern<iPTR, 1, "SelectAddrFI", [frameindex], []>;
-
-// Extract least significant 12 bits from an immediate value and sign extend
-// them.
-def LO12Sext : SDNodeXForm<imm, [{
-  return CurDAG->getTargetConstant(SignExtend64<12>(N->getZExtValue()),
-                                   SDLoc(N), N->getValueType(0));
-}]>;
-
-// Extract the most significant 20 bits from an immediate value. Add 1 if bit
-// 11 is 1, to compensate for the low 12 bits in the matching immediate addi
-// or ld/st being negative.
-def HI20 : SDNodeXForm<imm, [{
-  return CurDAG->getTargetConstant(((N->getZExtValue()+0x800) >> 12) & 0xfffff,
-                                   SDLoc(N), N->getValueType(0));
-}]>;
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class BranchCC_rri<bits<3> funct3, string opcodestr>
-    : RVInstB<funct3, OPC_BRANCH, (outs),
-              (ins GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12),
-              opcodestr, "$rs1, $rs2, $imm12"> {
-  let isBranch = 1;
-  let isTerminator = 1;
-}
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class Load_ri<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_LOAD, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class Store_rri<bits<3> funct3, string opcodestr>
-    : RVInstS<funct3, OPC_STORE, (outs),
-              (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rs2, ${imm12}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALU_ri<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_OP_IMM, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rd, $rs1, $imm12">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Shift_ri<bit arithshift, bits<3> funct3, string opcodestr>
-    : RVInstIShift<arithshift, funct3, OPC_OP_IMM, (outs GPR:$rd),
-                   (ins GPR:$rs1, uimmlog2xlen:$shamt), opcodestr,
-                   "$rd, $rs1, $shamt">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALU_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
-              opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class CSR_ir<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd), (ins csr_sysreg:$imm12, GPR:$rs1),
-              opcodestr, "$rd, $imm12, $rs1">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class CSR_ii<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd),
-              (ins csr_sysreg:$imm12, uimm5:$rs1),
-              opcodestr, "$rd, $imm12, $rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ShiftW_ri<bit arithshift, bits<3> funct3, string opcodestr>
-    : RVInstIShiftW<arithshift, funct3, OPC_OP_IMM_32, (outs GPR:$rd),
-                    (ins GPR:$rs1, uimm5:$shamt), opcodestr,
-                    "$rd, $rs1, $shamt">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALUW_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_32, (outs GPR:$rd),
-              (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class Priv<string opcodestr, bits<7> funct7>
-    : RVInstR<funct7, 0b000, OPC_SYSTEM, (outs), (ins GPR:$rs1, GPR:$rs2),
-              opcodestr, "">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, isReMaterializable = 1, mayLoad = 0, mayStore = 0 in {
-def LUI : RVInstU<OPC_LUI, (outs GPR:$rd), (ins uimm20_lui:$imm20),
-                  "lui", "$rd, $imm20">;
-
-def AUIPC : RVInstU<OPC_AUIPC, (outs GPR:$rd), (ins uimm20_auipc:$imm20),
-                    "auipc", "$rd, $imm20">;
-
-let isCall = 1 in
-def JAL : RVInstJ<OPC_JAL, (outs GPR:$rd), (ins simm21_lsb0_jal:$imm20),
-                  "jal", "$rd, $imm20">;
-
-let isCall = 1 in
-def JALR : RVInstI<0b000, OPC_JALR, (outs GPR:$rd),
-                   (ins GPR:$rs1, simm12:$imm12),
-                   "jalr", "$rd, $rs1, $imm12">;
-} // hasSideEffects = 0, mayLoad = 0, mayStore = 0
-
-def BEQ  : BranchCC_rri<0b000, "beq">;
-def BNE  : BranchCC_rri<0b001, "bne">;
-def BLT  : BranchCC_rri<0b100, "blt">;
-def BGE  : BranchCC_rri<0b101, "bge">;
-def BLTU : BranchCC_rri<0b110, "bltu">;
-def BGEU : BranchCC_rri<0b111, "bgeu">;
-
-def LB  : Load_ri<0b000, "lb">;
-def LH  : Load_ri<0b001, "lh">;
-def LW  : Load_ri<0b010, "lw">;
-def LBU : Load_ri<0b100, "lbu">;
-def LHU : Load_ri<0b101, "lhu">;
-
-def SB : Store_rri<0b000, "sb">;
-def SH : Store_rri<0b001, "sh">;
-def SW : Store_rri<0b010, "sw">;
-
-// ADDI isn't always rematerializable, but isReMaterializable will be used as
-// a hint which is verified in isReallyTriviallyReMaterializable.
-let isReMaterializable = 1 in
-def ADDI  : ALU_ri<0b000, "addi">;
-
-def SLTI  : ALU_ri<0b010, "slti">;
-def SLTIU : ALU_ri<0b011, "sltiu">;
-def XORI  : ALU_ri<0b100, "xori">;
-def ORI   : ALU_ri<0b110, "ori">;
-def ANDI  : ALU_ri<0b111, "andi">;
-
-def SLLI : Shift_ri<0, 0b001, "slli">;
-def SRLI : Shift_ri<0, 0b101, "srli">;
-def SRAI : Shift_ri<1, 0b101, "srai">;
-
-def ADD  : ALU_rr<0b0000000, 0b000, "add">;
-def SUB  : ALU_rr<0b0100000, 0b000, "sub">;
-def SLL  : ALU_rr<0b0000000, 0b001, "sll">;
-def SLT  : ALU_rr<0b0000000, 0b010, "slt">;
-def SLTU : ALU_rr<0b0000000, 0b011, "sltu">;
-def XOR  : ALU_rr<0b0000000, 0b100, "xor">;
-def SRL  : ALU_rr<0b0000000, 0b101, "srl">;
-def SRA  : ALU_rr<0b0100000, 0b101, "sra">;
-def OR   : ALU_rr<0b0000000, 0b110, "or">;
-def AND  : ALU_rr<0b0000000, 0b111, "and">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
-def FENCE : RVInstI<0b000, OPC_MISC_MEM, (outs),
-                    (ins fencearg:$pred, fencearg:$succ),
-                    "fence", "$pred, $succ"> {
-  bits<4> pred;
-  bits<4> succ;
-
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = {0b0000,pred,succ};
-}
-
-def FENCE_TSO : RVInstI<0b000, OPC_MISC_MEM, (outs), (ins), "fence.tso", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = {0b1000,0b0011,0b0011};
-}
-
-def FENCE_I : RVInstI<0b001, OPC_MISC_MEM, (outs), (ins), "fence.i", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 0;
-}
-
-def ECALL : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ecall", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 0;
-}
-
-def EBREAK : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ebreak", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 1;
-}
-
-// This is a de facto standard (as set by GNU binutils) 32-bit unimplemented
-// instruction (i.e., it should always trap, if your implementation has invalid
-// instruction traps).
-def UNIMP : RVInstI<0b001, OPC_SYSTEM, (outs), (ins), "unimp", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 0b110000000000;
-}
-} // hasSideEffects = 1, mayLoad = 0, mayStore = 0
-
-def CSRRW : CSR_ir<0b001, "csrrw">;
-def CSRRS : CSR_ir<0b010, "csrrs">;
-def CSRRC : CSR_ir<0b011, "csrrc">;
-
-def CSRRWI : CSR_ii<0b101, "csrrwi">;
-def CSRRSI : CSR_ii<0b110, "csrrsi">;
-def CSRRCI : CSR_ii<0b111, "csrrci">;
-
-/// RV64I instructions
-
-let Predicates = [IsRV64] in {
-def LWU   : Load_ri<0b110, "lwu">;
-def LD    : Load_ri<0b011, "ld">;
-def SD    : Store_rri<0b011, "sd">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def ADDIW : RVInstI<0b000, OPC_OP_IMM_32, (outs GPR:$rd),
-                    (ins GPR:$rs1, simm12:$imm12),
-                    "addiw", "$rd, $rs1, $imm12">;
-
-def SLLIW : ShiftW_ri<0, 0b001, "slliw">;
-def SRLIW : ShiftW_ri<0, 0b101, "srliw">;
-def SRAIW : ShiftW_ri<1, 0b101, "sraiw">;
-
-def ADDW  : ALUW_rr<0b0000000, 0b000, "addw">;
-def SUBW  : ALUW_rr<0b0100000, 0b000, "subw">;
-def SLLW  : ALUW_rr<0b0000000, 0b001, "sllw">;
-def SRLW  : ALUW_rr<0b0000000, 0b101, "srlw">;
-def SRAW  : ALUW_rr<0b0100000, 0b101, "sraw">;
-} // Predicates = [IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Privileged instructions
-//===----------------------------------------------------------------------===//
-
-let isBarrier = 1, isReturn = 1, isTerminator = 1 in {
-def URET : Priv<"uret", 0b0000000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-
-def SRET : Priv<"sret", 0b0001000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-
-def MRET : Priv<"mret", 0b0011000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-} // isBarrier = 1, isReturn = 1, isTerminator = 1
-
-def WFI : Priv<"wfi", 0b0001000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00101;
-}
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-def SFENCE_VMA : RVInstR<0b0001001, 0b000, OPC_SYSTEM, (outs),
-                         (ins GPR:$rs1, GPR:$rs2),
-                         "sfence.vma", "$rs1, $rs2"> {
-  let rd = 0;
-}
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-// TODO la
-// TODO lb lh lw
-// TODO RV64I: ld
-// TODO sb sh sw
-// TODO RV64I: sd
-
-def : InstAlias<"nop",           (ADDI      X0,      X0,       0)>;
-
-// Note that the size is 32 because up to 8 32-bit instructions are needed to
-// generate an arbitrary 64-bit immediate. However, the size does not really
-// matter since PseudoLI is currently only used in the AsmParser where it gets
-// expanded to real instructions immediately.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Size = 32,
-    isCodeGenOnly = 0, isAsmParserOnly = 1 in
-def PseudoLI : Pseudo<(outs GPR:$rd), (ins ixlenimm:$imm), [],
-                      "li", "$rd, $imm">;
-
-def : InstAlias<"mv $rd, $rs",   (ADDI GPR:$rd, GPR:$rs,       0)>;
-def : InstAlias<"not $rd, $rs",  (XORI GPR:$rd, GPR:$rs,      -1)>;
-def : InstAlias<"neg $rd, $rs",  (SUB  GPR:$rd,      X0, GPR:$rs)>;
-
-let Predicates = [IsRV64] in {
-def : InstAlias<"negw $rd, $rs",   (SUBW  GPR:$rd,      X0, GPR:$rs)>;
-def : InstAlias<"sext.w $rd, $rs", (ADDIW GPR:$rd, GPR:$rs,       0)>;
-} // Predicates = [IsRV64]
-
-def : InstAlias<"seqz $rd, $rs", (SLTIU GPR:$rd, GPR:$rs,       1)>;
-def : InstAlias<"snez $rd, $rs", (SLTU  GPR:$rd,      X0, GPR:$rs)>;
-def : InstAlias<"sltz $rd, $rs", (SLT   GPR:$rd, GPR:$rs,      X0)>;
-def : InstAlias<"sgtz $rd, $rs", (SLT   GPR:$rd,      X0, GPR:$rs)>;
-
-// sgt/sgtu are recognised by the GNU assembler but the canonical slt/sltu
-// form will always be printed. Therefore, set a zero weight.
-def : InstAlias<"sgt $rd, $rs, $rt", (SLT GPR:$rd, GPR:$rt, GPR:$rs), 0>;
-def : InstAlias<"sgtu $rd, $rs, $rt", (SLTU GPR:$rd, GPR:$rt, GPR:$rs), 0>;
-
-def : InstAlias<"beqz $rs, $offset",
-                (BEQ GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bnez $rs, $offset",
-                (BNE GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"blez $rs, $offset",
-                (BGE      X0, GPR:$rs, simm13_lsb0:$offset)>;
-def : InstAlias<"bgez $rs, $offset",
-                (BGE GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bltz $rs, $offset",
-                (BLT GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bgtz $rs, $offset",
-                (BLT      X0, GPR:$rs, simm13_lsb0:$offset)>;
-
-// Always output the canonical mnemonic for the pseudo branch instructions.
-// The GNU tools emit the canonical mnemonic for the branch pseudo instructions
-// as well (e.g. "bgt" will be recognised by the assembler but never printed by
-// objdump). Match this behaviour by setting a zero weight.
-def : InstAlias<"bgt $rs, $rt, $offset",
-                (BLT  GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"ble $rs, $rt, $offset",
-                (BGE  GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"bgtu $rs, $rt, $offset",
-                (BLTU GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"bleu $rs, $rt, $offset",
-                (BGEU GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-
-// "ret" has more weight since "ret" and "jr" alias the same "jalr" instruction.
-def : InstAlias<"j $offset",   (JAL  X0, simm21_lsb0_jal:$offset)>;
-def : InstAlias<"jal $offset", (JAL  X1, simm21_lsb0_jal:$offset)>;
-def : InstAlias<"jr $rs",      (JALR X0, GPR:$rs, 0)>;
-def : InstAlias<"jalr $rs",    (JALR X1, GPR:$rs, 0)>;
-def : InstAlias<"ret",         (JALR X0,      X1, 0), 2>;
-// TODO call
-// TODO tail
-
-def : InstAlias<"fence", (FENCE 0xF, 0xF)>; // 0xF == iorw
-
-// CSR Addresses: 0xC00 == cycle,  0xC01 == time,  0xC02 == instret
-//                0xC80 == cycleh, 0xC81 == timeh, 0xC82 == instreth
-def : InstAlias<"rdinstret $rd", (CSRRS GPR:$rd, 0xC02, X0)>;
-def : InstAlias<"rdcycle $rd",   (CSRRS GPR:$rd, 0xC00, X0)>;
-def : InstAlias<"rdtime $rd",    (CSRRS GPR:$rd, 0xC01, X0)>;
-
-let Predicates = [IsRV32] in {
-def : InstAlias<"rdinstreth $rd", (CSRRS GPR:$rd, 0xC82, X0)>;
-def : InstAlias<"rdcycleh $rd",   (CSRRS GPR:$rd, 0xC80, X0)>;
-def : InstAlias<"rdtimeh $rd",    (CSRRS GPR:$rd, 0xC81, X0)>;
-} // Predicates = [IsRV32]
-
-def : InstAlias<"csrr $rd, $csr", (CSRRS GPR:$rd, csr_sysreg:$csr,      X0)>;
-def : InstAlias<"csrw $csr, $rs", (CSRRW      X0, csr_sysreg:$csr, GPR:$rs)>;
-def : InstAlias<"csrs $csr, $rs", (CSRRS      X0, csr_sysreg:$csr, GPR:$rs)>;
-def : InstAlias<"csrc $csr, $rs", (CSRRC      X0, csr_sysreg:$csr, GPR:$rs)>;
-
-def : InstAlias<"csrwi $csr, $imm", (CSRRWI X0, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrsi $csr, $imm", (CSRRSI X0, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrci $csr, $imm", (CSRRCI X0, csr_sysreg:$csr, uimm5:$imm)>;
-
-let EmitPriority = 0 in {
-def : InstAlias<"csrw $csr, $imm", (CSRRWI X0, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrs $csr, $imm", (CSRRSI X0, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrc $csr, $imm", (CSRRCI X0, csr_sysreg:$csr, uimm5:$imm)>;
-
-def : InstAlias<"csrrw $rd, $csr, $imm", (CSRRWI GPR:$rd, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrrs $rd, $csr, $imm", (CSRRSI GPR:$rd, csr_sysreg:$csr, uimm5:$imm)>;
-def : InstAlias<"csrrc $rd, $csr, $imm", (CSRRCI GPR:$rd, csr_sysreg:$csr, uimm5:$imm)>;
-}
-
-def : InstAlias<"sfence.vma",     (SFENCE_VMA      X0, X0)>;
-def : InstAlias<"sfence.vma $rs", (SFENCE_VMA GPR:$rs, X0)>;
-
-let EmitPriority = 0 in {
-def : InstAlias<"add $rd, $rs1, $imm12",
-                (ADDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"and $rd, $rs1, $imm12",
-                (ANDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"xor $rd, $rs1, $imm12",
-                (XORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"or $rd, $rs1, $imm12",
-                (ORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"sll $rd, $rs1, $shamt",
-                (SLLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt)>;
-def : InstAlias<"srl $rd, $rs1, $shamt",
-                (SRLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt)>;
-def : InstAlias<"sra $rd, $rs1, $shamt",
-                (SRAI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt)>;
-let Predicates = [IsRV64] in {
-def : InstAlias<"addw $rd, $rs1, $imm12",
-                (ADDIW  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"sllw $rd, $rs1, $shamt",
-                (SLLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
-def : InstAlias<"srlw $rd, $rs1, $shamt",
-                (SRLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
-def : InstAlias<"sraw $rd, $rs1, $shamt",
-                (SRAIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
-} // Predicates = [IsRV64]
-def : InstAlias<"slt $rd, $rs1, $imm12",
-                (SLTI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-def : InstAlias<"sltu $rd, $rs1, $imm12",
-                (SLTIU  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
-}
-
-def : MnemonicAlias<"move", "mv">;
-
-// The SCALL and SBREAK instructions wererenamed to ECALL and EBREAK in
-// version 2.1 of the user-level ISA. Like the GNU toolchain, we still accept
-// the old name for backwards compatibility.
-def : MnemonicAlias<"scall", "ecall">;
-def : MnemonicAlias<"sbreak", "ebreak">;
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//
-// Naming convention: For 'generic' pattern classes, we use the naming
-// convention PatTy1Ty2. For pattern classes which offer a more complex
-// expension, prefix the class name, e.g. BccPat.
-//===----------------------------------------------------------------------===//
-
-/// Generic pattern classes
-
-class PatGprGpr<SDPatternOperator OpNode, RVInst Inst>
-    : Pat<(OpNode GPR:$rs1, GPR:$rs2), (Inst GPR:$rs1, GPR:$rs2)>;
-class PatGprSimm12<SDPatternOperator OpNode, RVInstI Inst>
-    : Pat<(OpNode GPR:$rs1, simm12:$imm12), (Inst GPR:$rs1, simm12:$imm12)>;
-class PatGprUimmLog2XLen<SDPatternOperator OpNode, RVInstIShift Inst>
-    : Pat<(OpNode GPR:$rs1, uimmlog2xlen:$shamt),
-          (Inst GPR:$rs1, uimmlog2xlen:$shamt)>;
-
-/// Predicates
-
-def IsOrAdd: PatFrag<(ops node:$A, node:$B), (or node:$A, node:$B), [{
-  return isOrEquivalentToAdd(N);
-}]>;
-
-/// Immediates
-
-def : Pat<(simm12:$imm), (ADDI X0, simm12:$imm)>;
-def : Pat<(simm32hi20:$imm), (LUI (HI20 imm:$imm))>;
-def : Pat<(simm32:$imm), (ADDI (LUI (HI20 imm:$imm)), (LO12Sext imm:$imm))>,
-      Requires<[IsRV32]>;
-
-/// Simple arithmetic operations
-
-def : PatGprGpr<add, ADD>;
-def : PatGprSimm12<add, ADDI>;
-def : PatGprGpr<sub, SUB>;
-def : PatGprGpr<or, OR>;
-def : PatGprSimm12<or, ORI>;
-def : PatGprGpr<and, AND>;
-def : PatGprSimm12<and, ANDI>;
-def : PatGprGpr<xor, XOR>;
-def : PatGprSimm12<xor, XORI>;
-def : PatGprUimmLog2XLen<shl, SLLI>;
-def : PatGprUimmLog2XLen<srl, SRLI>;
-def : PatGprUimmLog2XLen<sra, SRAI>;
-
-// Match both a plain shift and one where the shift amount is masked (this is
-// typically introduced when the legalizer promotes the shift amount and
-// zero-extends it). For RISC-V, the mask is unnecessary as shifts in the base
-// ISA only read the least significant 5 bits (RV32I) or 6 bits (RV64I).
-class shiftop<SDPatternOperator operator>
-    : PatFrags<(ops node:$val, node:$count),
-               [(operator node:$val, node:$count),
-                (operator node:$val, (and node:$count, immbottomxlenset))]>;
-
-def : PatGprGpr<shiftop<shl>, SLL>;
-def : PatGprGpr<shiftop<srl>, SRL>;
-def : PatGprGpr<shiftop<sra>, SRA>;
-
-/// FrameIndex calculations
-
-def : Pat<(add (i32 AddrFI:$Rs), simm12:$imm12),
-          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;
-def : Pat<(IsOrAdd (i32 AddrFI:$Rs), simm12:$imm12),
-          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;
-
-/// Setcc
-
-def : PatGprGpr<setlt, SLT>;
-def : PatGprSimm12<setlt, SLTI>;
-def : PatGprGpr<setult, SLTU>;
-def : PatGprSimm12<setult, SLTIU>;
-
-// Define pattern expansions for setcc operations that aren't directly
-// handled by a RISC-V instruction.
-def : Pat<(seteq GPR:$rs1, 0), (SLTIU GPR:$rs1, 1)>;
-def : Pat<(seteq GPR:$rs1, GPR:$rs2), (SLTIU (XOR GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setne GPR:$rs1, 0), (SLTU X0, GPR:$rs1)>;
-def : Pat<(setne GPR:$rs1, GPR:$rs2), (SLTU X0, (XOR GPR:$rs1, GPR:$rs2))>;
-def : Pat<(setugt GPR:$rs1, GPR:$rs2), (SLTU GPR:$rs2, GPR:$rs1)>;
-def : Pat<(setuge GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setule GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs2, GPR:$rs1), 1)>;
-def : Pat<(setgt GPR:$rs1, GPR:$rs2), (SLT GPR:$rs2, GPR:$rs1)>;
-def : Pat<(setge GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setle GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs2, GPR:$rs1), 1)>;
-
-let usesCustomInserter = 1 in
-class SelectCC_rrirr<RegisterClass valty, RegisterClass cmpty>
-    : Pseudo<(outs valty:$dst),
-             (ins cmpty:$lhs, cmpty:$rhs, ixlenimm:$imm,
-              valty:$truev, valty:$falsev),
-             [(set valty:$dst, (SelectCC cmpty:$lhs, cmpty:$rhs,
-              (XLenVT imm:$imm), valty:$truev, valty:$falsev))]>;
-
-def Select_GPR_Using_CC_GPR : SelectCC_rrirr<GPR, GPR>;
-
-/// Branches and jumps
-
-// Match `(brcond (CondOp ..), ..)` and lower to the appropriate RISC-V branch
-// instruction.
-class BccPat<PatFrag CondOp, RVInstB Inst>
-    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$imm12),
-          (Inst GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12)>;
-
-def : BccPat<seteq, BEQ>;
-def : BccPat<setne, BNE>;
-def : BccPat<setlt, BLT>;
-def : BccPat<setge, BGE>;
-def : BccPat<setult, BLTU>;
-def : BccPat<setuge, BGEU>;
-
-class BccSwapPat<PatFrag CondOp, RVInst InstBcc>
-    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$imm12),
-          (InstBcc GPR:$rs2, GPR:$rs1, bb:$imm12)>;
-
-// Condition codes that don't have matching RISC-V branch instructions, but
-// are trivially supported by swapping the two input operands
-def : BccSwapPat<setgt, BLT>;
-def : BccSwapPat<setle, BGE>;
-def : BccSwapPat<setugt, BLTU>;
-def : BccSwapPat<setule, BGEU>;
-
-// An extra pattern is needed for a brcond without a setcc (i.e. where the
-// condition was calculated elsewhere).
-def : Pat<(brcond GPR:$cond, bb:$imm12), (BNE GPR:$cond, X0, bb:$imm12)>;
-
-let isBarrier = 1, isBranch = 1, isTerminator = 1 in
-def PseudoBR : Pseudo<(outs), (ins simm21_lsb0_jal:$imm20), [(br bb:$imm20)]>,
-               PseudoInstExpansion<(JAL X0, simm21_lsb0_jal:$imm20)>;
-
-let isCall = 1, Defs=[X1] in
-let isBarrier = 1, isBranch = 1, isIndirectBranch = 1, isTerminator = 1 in
-def PseudoBRIND : Pseudo<(outs), (ins GPR:$rs1, simm12:$imm12), []>,
-                  PseudoInstExpansion<(JALR X0, GPR:$rs1, simm12:$imm12)>;
-
-def : Pat<(brind GPR:$rs1), (PseudoBRIND GPR:$rs1, 0)>;
-def : Pat<(brind (add GPR:$rs1, simm12:$imm12)),
-          (PseudoBRIND GPR:$rs1, simm12:$imm12)>;
-
-// PseudoCALL is a pseudo instruction which will eventually expand to auipc
-// and jalr while encoding. This is desirable, as an auipc+jalr pair with
-// R_RISCV_CALL and R_RISCV_RELAX relocations can be be relaxed by the linker
-// if the offset fits in a signed 21-bit immediate.
-// Define AsmString to print "call" when compile with -S flag.
-// Define isCodeGenOnly = 0 to support parsing assembly "call" instruction.
-let isCall = 1, Defs = [X1], isCodeGenOnly = 0 in
-def PseudoCALL : Pseudo<(outs), (ins bare_symbol:$func),
-                        [(Call tglobaladdr:$func)]> {
-  let AsmString = "call\t$func";
-}
-
-def : Pat<(Call texternalsym:$func), (PseudoCALL texternalsym:$func)>;
-
-def : Pat<(URetFlag), (URET X0, X0)>;
-def : Pat<(SRetFlag), (SRET X0, X0)>;
-def : Pat<(MRetFlag), (MRET X0, X0)>;
-
-let isCall = 1, Defs = [X1] in
-def PseudoCALLIndirect : Pseudo<(outs), (ins GPR:$rs1), [(Call GPR:$rs1)]>,
-                         PseudoInstExpansion<(JALR X1, GPR:$rs1, 0)>;
-
-let isBarrier = 1, isReturn = 1, isTerminator = 1 in
-def PseudoRET : Pseudo<(outs), (ins), [(RetFlag)]>,
-                PseudoInstExpansion<(JALR X0, X1, 0)>;
-
-// PseudoTAIL is a pseudo instruction similar to PseudoCALL and will eventually
-// expand to auipc and jalr while encoding.
-// Define AsmString to print "tail" when compile with -S flag.
-let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [X2],
-    isCodeGenOnly = 0 in
-def PseudoTAIL : Pseudo<(outs), (ins bare_symbol:$dst), []> {
-  let AsmString = "tail\t$dst";
-}
-
-let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [X2] in
-def PseudoTAILIndirect : Pseudo<(outs), (ins GPRTC:$rs1), [(Tail GPRTC:$rs1)]>,
-                         PseudoInstExpansion<(JALR X0, GPR:$rs1, 0)>;
-
-def : Pat<(Tail (iPTR tglobaladdr:$dst)),
-          (PseudoTAIL texternalsym:$dst)>;
-def : Pat<(Tail (iPTR texternalsym:$dst)),
-          (PseudoTAIL texternalsym:$dst)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, isCodeGenOnly = 0,
-    isAsmParserOnly = 1 in
-def PseudoLLA : Pseudo<(outs GPR:$dst), (ins bare_symbol:$src), [],
-                       "lla", "$dst, $src">;
-
-/// Loads
-
-multiclass LdPat<PatFrag LoadOp, RVInst Inst> {
-  def : Pat<(LoadOp GPR:$rs1), (Inst GPR:$rs1, 0)>;
-  def : Pat<(LoadOp AddrFI:$rs1), (Inst AddrFI:$rs1, 0)>;
-  def : Pat<(LoadOp (add GPR:$rs1, simm12:$imm12)),
-            (Inst GPR:$rs1, simm12:$imm12)>;
-  def : Pat<(LoadOp (add AddrFI:$rs1, simm12:$imm12)),
-            (Inst AddrFI:$rs1, simm12:$imm12)>;
-  def : Pat<(LoadOp (IsOrAdd AddrFI:$rs1, simm12:$imm12)),
-            (Inst AddrFI:$rs1, simm12:$imm12)>;
-}
-
-defm : LdPat<sextloadi8, LB>;
-defm : LdPat<extloadi8, LB>;
-defm : LdPat<sextloadi16, LH>;
-defm : LdPat<extloadi16, LH>;
-defm : LdPat<load, LW>, Requires<[IsRV32]>;
-defm : LdPat<zextloadi8, LBU>;
-defm : LdPat<zextloadi16, LHU>;
-
-/// Stores
-
-multiclass StPat<PatFrag StoreOp, RVInst Inst, RegisterClass StTy> {
-  def : Pat<(StoreOp StTy:$rs2, GPR:$rs1), (Inst StTy:$rs2, GPR:$rs1, 0)>;
-  def : Pat<(StoreOp StTy:$rs2, AddrFI:$rs1), (Inst StTy:$rs2, AddrFI:$rs1, 0)>;
-  def : Pat<(StoreOp StTy:$rs2, (add GPR:$rs1, simm12:$imm12)),
-            (Inst StTy:$rs2, GPR:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp StTy:$rs2, (add AddrFI:$rs1, simm12:$imm12)),
-            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp StTy:$rs2, (IsOrAdd AddrFI:$rs1, simm12:$imm12)),
-            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-}
-
-defm : StPat<truncstorei8, SB, GPR>;
-defm : StPat<truncstorei16, SH, GPR>;
-defm : StPat<store, SW, GPR>, Requires<[IsRV32]>;
-
-/// Fences
-
-// Refer to Table A.6 in the version 2.3 draft of the RISC-V Instruction Set
-// Manual: Volume I.
-
-// fence acquire -> fence r, rw
-def : Pat<(atomic_fence (XLenVT 4), (imm)), (FENCE 0b10, 0b11)>;
-// fence release -> fence rw, w
-def : Pat<(atomic_fence (XLenVT 5), (imm)), (FENCE 0b11, 0b1)>;
-// fence acq_rel -> fence.tso
-def : Pat<(atomic_fence (XLenVT 6), (imm)), (FENCE_TSO)>;
-// fence seq_cst -> fence rw, rw
-def : Pat<(atomic_fence (XLenVT 7), (imm)), (FENCE 0b11, 0b11)>;
-
-// Lowering for atomic load and store is defined in RISCVInstrInfoA.td.
-// Although these are lowered to fence+load/store instructions defined in the
-// base RV32I/RV64I ISA, this lowering is only used when the A extension is
-// present. This is necessary as it isn't valid to mix __atomic_* libcalls
-// with inline atomic operations for the same object.
-
-/// Other pseudo-instructions
-
-// Pessimistically assume the stack pointer will be clobbered
-let Defs = [X2], Uses = [X2] in {
-def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-                              [(CallSeqStart timm:$amt1, timm:$amt2)]>;
-def ADJCALLSTACKUP   : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-                              [(CallSeqEnd timm:$amt1, timm:$amt2)]>;
-} // Defs = [X2], Uses = [X2]
-
-/// RV64 patterns
-
-let Predicates = [IsRV64] in {
-
-/// sext and zext
-
-def : Pat<(sext_inreg GPR:$rs1, i32), (ADDIW GPR:$rs1, 0)>;
-def : Pat<(and GPR:$rs1, 0xffffffff), (SRLI (SLLI GPR:$rs1, 32), 32)>;
-
-/// ALU operations
-
-def : Pat<(sext_inreg (add GPR:$rs1, GPR:$rs2), i32),
-          (ADDW GPR:$rs1, GPR:$rs2)>;
-def : Pat<(sext_inreg (add GPR:$rs1, simm12:$imm12), i32),
-          (ADDIW GPR:$rs1, simm12:$imm12)>;
-def : Pat<(sext_inreg (sub GPR:$rs1, GPR:$rs2), i32),
-          (SUBW GPR:$rs1, GPR:$rs2)>;
-def : Pat<(sext_inreg (shl GPR:$rs1, uimm5:$shamt), i32),
-          (SLLIW GPR:$rs1, uimm5:$shamt)>;
-// (srl (zexti32 ...), uimm5:$shamt) is matched with custom code due to the
-// need to undo manipulation of the mask value performed by DAGCombine.
-def : Pat<(sra (sext_inreg GPR:$rs1, i32), uimm5:$shamt),
-          (SRAIW GPR:$rs1, uimm5:$shamt)>;
-
-// TODO: patterns for SLLW/SRLW/SRAW.
-
-/// Loads
-
-defm : LdPat<sextloadi32, LW>;
-defm : LdPat<extloadi32, LW>;
-defm : LdPat<zextloadi32, LWU>;
-defm : LdPat<load, LD>;
-
-/// Stores
-
-defm : StPat<truncstorei32, SW, GPR>;
-defm : StPat<store, SD, GPR>;
-} // Predicates = [IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Standard extensions
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrInfoM.td"
-include "RISCVInstrInfoA.td"
-include "RISCVInstrInfoF.td"
-include "RISCVInstrInfoD.td"
-include "RISCVInstrInfoC.td"
diff --git a/lib/Target/RISCV/RISCVInstrInfoA.td b/lib/Target/RISCV/RISCVInstrInfoA.td
deleted file mode 100644
index 9cb1d2f0b62..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoA.td
+++ /dev/null
@@ -1,278 +0,0 @@
-//===-- RISCVInstrInfoA.td - RISC-V 'A' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'A', Atomic
-// Instructions extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Instruction class templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class LR_r<bit aq, bit rl, bits<3> funct3, string opcodestr>
-    : RVInstRAtomic<0b00010, aq, rl, funct3, OPC_AMO,
-                    (outs GPR:$rd), (ins GPR:$rs1),
-                    opcodestr, "$rd, (${rs1})"> {
-  let rs2 = 0;
-}
-
-multiclass LR_r_aq_rl<bits<3> funct3, string opcodestr> {
-  def ""     : LR_r<0, 0, funct3, opcodestr>;
-  def _AQ    : LR_r<1, 0, funct3, opcodestr # ".aq">;
-  def _RL    : LR_r<0, 1, funct3, opcodestr # ".rl">;
-  def _AQ_RL : LR_r<1, 1, funct3, opcodestr # ".aqrl">;
-}
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 1 in
-class AMO_rr<bits<5> funct5, bit aq, bit rl, bits<3> funct3, string opcodestr>
-    : RVInstRAtomic<funct5, aq, rl, funct3, OPC_AMO,
-                    (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
-                    opcodestr, "$rd, $rs2, (${rs1})">;
-
-multiclass AMO_rr_aq_rl<bits<5> funct5, bits<3> funct3, string opcodestr> {
-  def ""     : AMO_rr<funct5, 0, 0, funct3, opcodestr>;
-  def _AQ    : AMO_rr<funct5, 1, 0, funct3, opcodestr # ".aq">;
-  def _RL    : AMO_rr<funct5, 0, 1, funct3, opcodestr # ".rl">;
-  def _AQ_RL : AMO_rr<funct5, 1, 1, funct3, opcodestr # ".aqrl">;
-}
-
-multiclass AtomicStPat<PatFrag StoreOp, RVInst Inst, RegisterClass StTy> {
-  def : Pat<(StoreOp GPR:$rs1, StTy:$rs2), (Inst StTy:$rs2, GPR:$rs1, 0)>;
-  def : Pat<(StoreOp AddrFI:$rs1, StTy:$rs2), (Inst StTy:$rs2, AddrFI:$rs1, 0)>;
-  def : Pat<(StoreOp (add GPR:$rs1, simm12:$imm12), StTy:$rs2),
-            (Inst StTy:$rs2, GPR:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp (add AddrFI:$rs1, simm12:$imm12), StTy:$rs2),
-            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp (IsOrAdd AddrFI:$rs1, simm12:$imm12), StTy:$rs2),
-            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-}
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtA] in {
-defm LR_W       : LR_r_aq_rl<0b010, "lr.w">;
-defm SC_W       : AMO_rr_aq_rl<0b00011, 0b010, "sc.w">;
-defm AMOSWAP_W  : AMO_rr_aq_rl<0b00001, 0b010, "amoswap.w">;
-defm AMOADD_W   : AMO_rr_aq_rl<0b00000, 0b010, "amoadd.w">;
-defm AMOXOR_W   : AMO_rr_aq_rl<0b00100, 0b010, "amoxor.w">;
-defm AMOAND_W   : AMO_rr_aq_rl<0b01100, 0b010, "amoand.w">;
-defm AMOOR_W    : AMO_rr_aq_rl<0b01000, 0b010, "amoor.w">;
-defm AMOMIN_W   : AMO_rr_aq_rl<0b10000, 0b010, "amomin.w">;
-defm AMOMAX_W   : AMO_rr_aq_rl<0b10100, 0b010, "amomax.w">;
-defm AMOMINU_W  : AMO_rr_aq_rl<0b11000, 0b010, "amominu.w">;
-defm AMOMAXU_W  : AMO_rr_aq_rl<0b11100, 0b010, "amomaxu.w">;
-} // Predicates = [HasStdExtA]
-
-let Predicates = [HasStdExtA, IsRV64] in {
-defm LR_D       : LR_r_aq_rl<0b011, "lr.d">;
-defm SC_D       : AMO_rr_aq_rl<0b00011, 0b011, "sc.d">;
-defm AMOSWAP_D  : AMO_rr_aq_rl<0b00001, 0b011, "amoswap.d">;
-defm AMOADD_D   : AMO_rr_aq_rl<0b00000, 0b011, "amoadd.d">;
-defm AMOXOR_D   : AMO_rr_aq_rl<0b00100, 0b011, "amoxor.d">;
-defm AMOAND_D   : AMO_rr_aq_rl<0b01100, 0b011, "amoand.d">;
-defm AMOOR_D    : AMO_rr_aq_rl<0b01000, 0b011, "amoor.d">;
-defm AMOMIN_D   : AMO_rr_aq_rl<0b10000, 0b011, "amomin.d">;
-defm AMOMAX_D   : AMO_rr_aq_rl<0b10100, 0b011, "amomax.d">;
-defm AMOMINU_D  : AMO_rr_aq_rl<0b11000, 0b011, "amominu.d">;
-defm AMOMAXU_D  : AMO_rr_aq_rl<0b11100, 0b011, "amomaxu.d">;
-} // Predicates = [HasStedExtA, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtA] in {
-
-/// Atomic loads and stores
-
-// Fences will be inserted for atomic load/stores according to the logic in
-// RISCVTargetLowering::{emitLeadingFence,emitTrailingFence}.
-
-defm : LdPat<atomic_load_8,  LB>;
-defm : LdPat<atomic_load_16, LH>;
-defm : LdPat<atomic_load_32, LW>;
-
-defm : AtomicStPat<atomic_store_8,  SB, GPR>;
-defm : AtomicStPat<atomic_store_16, SH, GPR>;
-defm : AtomicStPat<atomic_store_32, SW, GPR>;
-
-/// AMOs
-
-multiclass AMOPat<string AtomicOp, string BaseInst> {
-  def : PatGprGpr<!cast<PatFrag>(AtomicOp#"_monotonic"),
-                  !cast<RVInst>(BaseInst)>;
-  def : PatGprGpr<!cast<PatFrag>(AtomicOp#"_acquire"),
-                  !cast<RVInst>(BaseInst#"_AQ")>;
-  def : PatGprGpr<!cast<PatFrag>(AtomicOp#"_release"),
-                  !cast<RVInst>(BaseInst#"_RL")>;
-  def : PatGprGpr<!cast<PatFrag>(AtomicOp#"_acq_rel"),
-                  !cast<RVInst>(BaseInst#"_AQ_RL")>;
-  def : PatGprGpr<!cast<PatFrag>(AtomicOp#"_seq_cst"),
-                  !cast<RVInst>(BaseInst#"_AQ_RL")>;
-}
-
-defm : AMOPat<"atomic_swap_32", "AMOSWAP_W">;
-defm : AMOPat<"atomic_load_add_32", "AMOADD_W">;
-defm : AMOPat<"atomic_load_and_32", "AMOAND_W">;
-defm : AMOPat<"atomic_load_or_32", "AMOOR_W">;
-defm : AMOPat<"atomic_load_xor_32", "AMOXOR_W">;
-defm : AMOPat<"atomic_load_max_32", "AMOMAX_W">;
-defm : AMOPat<"atomic_load_min_32", "AMOMIN_W">;
-defm : AMOPat<"atomic_load_umax_32", "AMOMAXU_W">;
-defm : AMOPat<"atomic_load_umin_32", "AMOMINU_W">;
-
-def : Pat<(atomic_load_sub_32_monotonic GPR:$addr, GPR:$incr),
-          (AMOADD_W GPR:$addr, (SUB X0, GPR:$incr))>;
-def : Pat<(atomic_load_sub_32_acquire GPR:$addr, GPR:$incr),
-          (AMOADD_W_AQ GPR:$addr, (SUB X0, GPR:$incr))>;
-def : Pat<(atomic_load_sub_32_release GPR:$addr, GPR:$incr),
-          (AMOADD_W_RL GPR:$addr, (SUB X0, GPR:$incr))>;
-def : Pat<(atomic_load_sub_32_acq_rel GPR:$addr, GPR:$incr),
-          (AMOADD_W_AQ_RL GPR:$addr, (SUB X0, GPR:$incr))>;
-def : Pat<(atomic_load_sub_32_seq_cst GPR:$addr, GPR:$incr),
-          (AMOADD_W_AQ_RL GPR:$addr, (SUB X0, GPR:$incr))>;
-
-/// Pseudo AMOs
-
-class PseudoAMO : Pseudo<(outs GPR:$res, GPR:$scratch),
-                         (ins GPR:$addr, GPR:$incr, ixlenimm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-def PseudoAtomicLoadNand32 : PseudoAMO;
-// Ordering constants must be kept in sync with the AtomicOrdering enum in
-// AtomicOrdering.h.
-def : Pat<(atomic_load_nand_32_monotonic GPR:$addr, GPR:$incr),
-          (PseudoAtomicLoadNand32 GPR:$addr, GPR:$incr, 2)>;
-def : Pat<(atomic_load_nand_32_acquire GPR:$addr, GPR:$incr),
-          (PseudoAtomicLoadNand32 GPR:$addr, GPR:$incr, 4)>;
-def : Pat<(atomic_load_nand_32_release GPR:$addr, GPR:$incr),
-          (PseudoAtomicLoadNand32 GPR:$addr, GPR:$incr, 5)>;
-def : Pat<(atomic_load_nand_32_acq_rel GPR:$addr, GPR:$incr),
-          (PseudoAtomicLoadNand32 GPR:$addr, GPR:$incr, 6)>;
-def : Pat<(atomic_load_nand_32_seq_cst GPR:$addr, GPR:$incr),
-          (PseudoAtomicLoadNand32 GPR:$addr, GPR:$incr, 7)>;
-
-class PseudoMaskedAMO
-    : Pseudo<(outs GPR:$res, GPR:$scratch),
-             (ins GPR:$addr, GPR:$incr, GPR:$mask, ixlenimm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-class PseudoMaskedAMOMinMax
-    : Pseudo<(outs GPR:$res, GPR:$scratch1, GPR:$scratch2),
-             (ins GPR:$addr, GPR:$incr, GPR:$mask, ixlenimm:$sextshamt,
-              ixlenimm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch1,"
-                    "@earlyclobber $scratch2";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-class PseudoMaskedAMOUMinUMax
-    : Pseudo<(outs GPR:$res, GPR:$scratch1, GPR:$scratch2),
-             (ins GPR:$addr, GPR:$incr, GPR:$mask, ixlenimm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch1,"
-                    "@earlyclobber $scratch2";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-class PseudoMaskedAMOPat<Intrinsic intrin, Pseudo AMOInst>
-    : Pat<(intrin GPR:$addr, GPR:$incr, GPR:$mask, imm:$ordering),
-          (AMOInst GPR:$addr, GPR:$incr, GPR:$mask, imm:$ordering)>;
-
-class PseudoMaskedAMOMinMaxPat<Intrinsic intrin, Pseudo AMOInst>
-    : Pat<(intrin GPR:$addr, GPR:$incr, GPR:$mask, GPR:$shiftamt,
-           imm:$ordering),
-          (AMOInst GPR:$addr, GPR:$incr, GPR:$mask, GPR:$shiftamt,
-           imm:$ordering)>;
-
-def PseudoMaskedAtomicSwap32 : PseudoMaskedAMO;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_xchg_i32,
-                         PseudoMaskedAtomicSwap32>;
-def PseudoMaskedAtomicLoadAdd32 : PseudoMaskedAMO;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_add_i32,
-                         PseudoMaskedAtomicLoadAdd32>;
-def PseudoMaskedAtomicLoadSub32 : PseudoMaskedAMO;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_sub_i32,
-                         PseudoMaskedAtomicLoadSub32>;
-def PseudoMaskedAtomicLoadNand32 : PseudoMaskedAMO;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_nand_i32,
-                         PseudoMaskedAtomicLoadNand32>;
-def PseudoMaskedAtomicLoadMax32 : PseudoMaskedAMOMinMax;
-def : PseudoMaskedAMOMinMaxPat<int_riscv_masked_atomicrmw_max_i32,
-                               PseudoMaskedAtomicLoadMax32>;
-def PseudoMaskedAtomicLoadMin32 : PseudoMaskedAMOMinMax;
-def : PseudoMaskedAMOMinMaxPat<int_riscv_masked_atomicrmw_min_i32,
-                               PseudoMaskedAtomicLoadMin32>;
-def PseudoMaskedAtomicLoadUMax32 : PseudoMaskedAMOUMinUMax;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_umax_i32,
-                         PseudoMaskedAtomicLoadUMax32>;
-def PseudoMaskedAtomicLoadUMin32 : PseudoMaskedAMOUMinUMax;
-def : PseudoMaskedAMOPat<int_riscv_masked_atomicrmw_umin_i32,
-                         PseudoMaskedAtomicLoadUMin32>;
-
-/// Compare and exchange
-
-class PseudoCmpXchg
-    : Pseudo<(outs GPR:$res, GPR:$scratch),
-             (ins GPR:$addr, GPR:$cmpval, GPR:$newval, i32imm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-// Ordering constants must be kept in sync with the AtomicOrdering enum in
-// AtomicOrdering.h.
-multiclass PseudoCmpXchgPat<string Op, Pseudo CmpXchgInst> {
-  def : Pat<(!cast<PatFrag>(Op#"_monotonic") GPR:$addr, GPR:$cmp, GPR:$new),
-            (CmpXchgInst GPR:$addr, GPR:$cmp, GPR:$new, 2)>;
-  def : Pat<(!cast<PatFrag>(Op#"_acquire") GPR:$addr, GPR:$cmp, GPR:$new),
-            (CmpXchgInst GPR:$addr, GPR:$cmp, GPR:$new, 4)>;
-  def : Pat<(!cast<PatFrag>(Op#"_release") GPR:$addr, GPR:$cmp, GPR:$new),
-            (CmpXchgInst GPR:$addr, GPR:$cmp, GPR:$new, 5)>;
-  def : Pat<(!cast<PatFrag>(Op#"_acq_rel") GPR:$addr, GPR:$cmp, GPR:$new),
-            (CmpXchgInst GPR:$addr, GPR:$cmp, GPR:$new, 6)>;
-  def : Pat<(!cast<PatFrag>(Op#"_seq_cst") GPR:$addr, GPR:$cmp, GPR:$new),
-            (CmpXchgInst GPR:$addr, GPR:$cmp, GPR:$new, 7)>;
-}
-
-def PseudoCmpXchg32 : PseudoCmpXchg;
-defm : PseudoCmpXchgPat<"atomic_cmp_swap_32", PseudoCmpXchg32>;
-
-def PseudoMaskedCmpXchg32
-    : Pseudo<(outs GPR:$res, GPR:$scratch),
-             (ins GPR:$addr, GPR:$cmpval, GPR:$newval, GPR:$mask,
-              i32imm:$ordering), []> {
-  let Constraints = "@earlyclobber $res,@earlyclobber $scratch";
-  let mayLoad = 1;
-  let mayStore = 1;
-  let hasSideEffects = 0;
-}
-
-def : Pat<(int_riscv_masked_cmpxchg_i32
-            GPR:$addr, GPR:$cmpval, GPR:$newval, GPR:$mask, imm:$ordering),
-          (PseudoMaskedCmpXchg32
-            GPR:$addr, GPR:$cmpval, GPR:$newval, GPR:$mask, imm:$ordering)>;
-
-} // Predicates = [HasStdExtA]
diff --git a/lib/Target/RISCV/RISCVInstrInfoC.td b/lib/Target/RISCV/RISCVInstrInfoC.td
deleted file mode 100644
index ad68b5a7dc9..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoC.td
+++ /dev/null
@@ -1,714 +0,0 @@
-//===- RISCVInstrInfoC.td - Compressed RISCV instructions -*- tblgen-*-----===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrFormatsC.td"
-
-//===----------------------------------------------------------------------===//
-// Operand definitions.
-//===----------------------------------------------------------------------===//
-
-def UImmLog2XLenNonZeroAsmOperand : AsmOperandClass {
-  let Name = "UImmLog2XLenNonZero";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = "InvalidUImmLog2XLenNonZero";
-}
-
-def uimmlog2xlennonzero : Operand<XLenVT>, ImmLeaf<XLenVT, [{
-  if (Subtarget->is64Bit())
-    return isUInt<6>(Imm) && (Imm != 0);
-  return isUInt<5>(Imm) && (Imm != 0);
-}]> {
-  let ParserMatchClass = UImmLog2XLenNonZeroAsmOperand;
-  // TODO: should ensure invalid shamt is rejected when decoding.
-  let DecoderMethod = "decodeUImmOperand<6>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    if (STI.getTargetTriple().isArch64Bit())
-      return  isUInt<6>(Imm) && (Imm != 0);
-    return isUInt<5>(Imm) && (Imm != 0);
-  }];
-}
-
-def simm6 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<6>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<6>;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<6>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isInt<6>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-def simm6nonzero : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return (Imm != 0) && isInt<6>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<6, "NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<6>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return (Imm != 0) && isInt<6>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-def CLUIImmAsmOperand : AsmOperandClass {
-  let Name = "CLUIImm";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = !strconcat("Invalid", Name);
-}
-
-
-// c_lui_imm checks the immediate range is in [1, 31] or [0xfffe0, 0xfffff].
-// The RISC-V ISA describes the constraint as [1, 63], with that value being
-// loaded in to bits 17-12 of the destination register and sign extended from
-// bit 17. Therefore, this 6-bit immediate can represent values in the ranges
-// [1, 31] and [0xfffe0, 0xfffff].
-def c_lui_imm : Operand<XLenVT>,
-                ImmLeaf<XLenVT, [{return (Imm != 0) &&
-                                 (isUInt<5>(Imm) ||
-                                  (Imm >= 0xfffe0 && Imm <= 0xfffff));}]> {
-  let ParserMatchClass = CLUIImmAsmOperand;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeCLUIImmOperand";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return (Imm != 0) && (isUInt<5>(Imm) ||
-             (Imm >= 0xfffe0 && Imm <= 0xfffff));
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-// A 7-bit unsigned immediate where the least significant two bits are zero.
-def uimm7_lsb00 : Operand<XLenVT>,
-                  ImmLeaf<XLenVT, [{return isShiftedUInt<5, 2>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<7, "Lsb00">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<7>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedUInt<5, 2>(Imm);
-  }];
-}
-
-// A 8-bit unsigned immediate where the least significant two bits are zero.
-def uimm8_lsb00 : Operand<XLenVT>,
-                  ImmLeaf<XLenVT, [{return isShiftedUInt<6, 2>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<8, "Lsb00">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<8>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedUInt<6, 2>(Imm);
-  }];
-}
-
-// A 8-bit unsigned immediate where the least significant three bits are zero.
-def uimm8_lsb000 : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return isShiftedUInt<5, 3>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<8, "Lsb000">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<8>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedUInt<5, 3>(Imm);
-  }];
-}
-
-// A 9-bit signed immediate where the least significant bit is zero.
-def simm9_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<9, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<9>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isShiftedInt<8, 1>(Imm);
-    return MCOp.isBareSymbolRef();
-
-  }];
-}
-
-// A 9-bit unsigned immediate where the least significant three bits are zero.
-def uimm9_lsb000 : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return isShiftedUInt<6, 3>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<9, "Lsb000">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<9>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedUInt<6, 3>(Imm);
-  }];
-}
-
-// A 10-bit unsigned immediate where the least significant two bits are zero
-// and the immediate can't be zero.
-def uimm10_lsb00nonzero : Operand<XLenVT>,
-                          ImmLeaf<XLenVT,
-                          [{return isShiftedUInt<8, 2>(Imm) && (Imm != 0);}]> {
-  let ParserMatchClass = UImmAsmOperand<10, "Lsb00NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmNonZeroOperand<10>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedUInt<8, 2>(Imm) && (Imm != 0);
-  }];
-}
-
-// A 10-bit signed immediate where the least significant four bits are zero.
-def simm10_lsb0000nonzero : Operand<XLenVT>,
-                            ImmLeaf<XLenVT,
-                            [{return (Imm != 0) && isShiftedInt<6, 4>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<10, "Lsb0000NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmNonZeroOperand<10>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (!MCOp.evaluateAsConstantImm(Imm))
-      return false;
-    return isShiftedInt<6, 4>(Imm) && (Imm != 0);
-  }];
-}
-
-// A 12-bit signed immediate where the least significant bit is zero.
-def simm12_lsb0 : Operand<XLenVT> {
-  let ParserMatchClass = SImmAsmOperand<12, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<12>";
-  let MCOperandPredicate = [{
-    int64_t Imm;
-    if (MCOp.evaluateAsConstantImm(Imm))
-      return isShiftedInt<11, 1>(Imm);
-    return MCOp.isBareSymbolRef();
-  }];
-}
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class CStackLoad<bits<3> funct3, string OpcodeStr,
-                 RegisterClass cls, DAGOperand opnd>
-    : RVInst16CI<funct3, 0b10, (outs cls:$rd), (ins SP:$rs1, opnd:$imm),
-                 OpcodeStr, "$rd, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class CStackStore<bits<3> funct3, string OpcodeStr,
-                  RegisterClass cls, DAGOperand opnd>
-    : RVInst16CSS<funct3, 0b10, (outs), (ins cls:$rs2, SP:$rs1, opnd:$imm),
-                  OpcodeStr, "$rs2, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class CLoad_ri<bits<3> funct3, string OpcodeStr,
-               RegisterClass cls, DAGOperand opnd>
-    : RVInst16CL<funct3, 0b00, (outs cls:$rd), (ins GPRC:$rs1, opnd:$imm),
-                 OpcodeStr, "$rd, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class CStore_rri<bits<3> funct3, string OpcodeStr,
-                 RegisterClass cls, DAGOperand opnd>
-    : RVInst16CS<funct3, 0b00, (outs), (ins cls:$rs2, GPRC:$rs1, opnd:$imm),
-                 OpcodeStr, "$rs2, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Bcz<bits<3> funct3, string OpcodeStr, PatFrag CondOp,
-          RegisterClass cls>
-    : RVInst16CB<funct3, 0b01, (outs), (ins cls:$rs1, simm9_lsb0:$imm),
-                 OpcodeStr, "$rs1, $imm"> {
-  let isBranch = 1;
-  let isTerminator = 1;
-  let Inst{12} = imm{7};
-  let Inst{11-10} = imm{3-2};
-  let Inst{6-5} = imm{6-5};
-  let Inst{4-3} = imm{1-0};
-  let Inst{2} = imm{4};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Shift_right<bits<2> funct2, string OpcodeStr, RegisterClass cls,
-                  Operand ImmOpnd>
-    : RVInst16CB<0b100, 0b01, (outs cls:$rs1_wb), (ins cls:$rs1, ImmOpnd:$imm),
-                 OpcodeStr, "$rs1, $imm"> {
-  let Constraints = "$rs1 = $rs1_wb";
-  let Inst{12} = imm{5};
-  let Inst{11-10} = funct2;
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class CS_ALU<bits<6> funct6, bits<2> funct2, string OpcodeStr,
-             RegisterClass cls>
-    : RVInst16CA<funct6, funct2, 0b01, (outs cls:$rd_wb), (ins cls:$rd, cls:$rs2),
-                 OpcodeStr, "$rd, $rs2"> {
-  bits<3> rd;
-  let Constraints = "$rd = $rd_wb";
-  let Inst{9-7} = rd;
-}
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtC] in {
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Uses = [X2] in
-def C_ADDI4SPN : RVInst16CIW<0b000, 0b00, (outs GPRC:$rd),
-                             (ins SP:$rs1, uimm10_lsb00nonzero:$imm),
-                             "c.addi4spn", "$rd, $rs1, $imm"> {
-  bits<5> rs1;
-  let Inst{12-11} = imm{5-4};
-  let Inst{10-7} = imm{9-6};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{3};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FLD  : CLoad_ri<0b001, "c.fld", FPR64C, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-def C_LW : CLoad_ri<0b010, "c.lw", GPRC, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FLW  : CLoad_ri<0b011, "c.flw", FPR32C, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_LD : CLoad_ri<0b011, "c.ld", GPRC, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FSD  : CStore_rri<0b101, "c.fsd", FPR64C, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-def C_SW : CStore_rri<0b110, "c.sw", GPRC, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32]  in
-def C_FSW  : CStore_rri<0b111, "c.fsw", FPR32C, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_SD : CStore_rri<0b111, "c.sd", GPRC, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-let rd = 0, imm = 0, hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_NOP : RVInst16CI<0b000, 0b01, (outs), (ins), "c.nop", "">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADDI : RVInst16CI<0b000, 0b01, (outs GPRNoX0:$rd_wb),
-                        (ins GPRNoX0:$rd, simm6nonzero:$imm),
-                        "c.addi", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, isCall = 1,
-    DecoderNamespace = "RISCV32Only_", Defs = [X1],
-    Predicates = [HasStdExtC, IsRV32]  in
-def C_JAL : RVInst16CJ<0b001, 0b01, (outs), (ins simm12_lsb0:$offset),
-                       "c.jal", "$offset">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0,
-    Predicates = [HasStdExtC, IsRV64] in
-def C_ADDIW : RVInst16CI<0b001, 0b01, (outs GPRNoX0:$rd_wb),
-                         (ins GPRNoX0:$rd, simm6:$imm),
-                         "c.addiw", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_LI : RVInst16CI<0b010, 0b01, (outs GPRNoX0:$rd), (ins simm6:$imm),
-                      "c.li", "$rd, $imm"> {
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADDI16SP : RVInst16CI<0b011, 0b01, (outs SP:$rd_wb),
-                            (ins SP:$rd, simm10_lsb0000nonzero:$imm),
-                            "c.addi16sp", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{12} = imm{9};
-  let Inst{11-7} = 2;
-  let Inst{6} = imm{4};
-  let Inst{5} = imm{6};
-  let Inst{4-3} = imm{8-7};
-  let Inst{2} = imm{5};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_LUI : RVInst16CI<0b011, 0b01, (outs GPRNoX0X2:$rd),
-                       (ins c_lui_imm:$imm),
-                       "c.lui", "$rd, $imm"> {
-  let Inst{6-2} = imm{4-0};
-}
-
-def C_SRLI : Shift_right<0b00, "c.srli", GPRC, uimmlog2xlennonzero>;
-def C_SRAI : Shift_right<0b01, "c.srai", GPRC, uimmlog2xlennonzero>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ANDI : RVInst16CB<0b100, 0b01, (outs GPRC:$rs1_wb), (ins GPRC:$rs1, simm6:$imm),
-                        "c.andi", "$rs1, $imm"> {
-  let Constraints = "$rs1 = $rs1_wb";
-  let Inst{12} = imm{5};
-  let Inst{11-10} = 0b10;
-  let Inst{6-2} = imm{4-0};
-}
-
-def C_SUB  : CS_ALU<0b100011, 0b00, "c.sub", GPRC>;
-def C_XOR  : CS_ALU<0b100011, 0b01, "c.xor", GPRC>;
-def C_OR   : CS_ALU<0b100011, 0b10, "c.or" , GPRC>;
-def C_AND  : CS_ALU<0b100011, 0b11, "c.and", GPRC>;
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def C_SUBW : CS_ALU<0b100111, 0b00, "c.subw", GPRC>;
-def C_ADDW : CS_ALU<0b100111, 0b01, "c.addw", GPRC>;
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_J : RVInst16CJ<0b101, 0b01, (outs), (ins simm12_lsb0:$offset),
-                     "c.j", "$offset"> {
-  let isBranch = 1;
-  let isTerminator=1;
-  let isBarrier=1;
-}
-
-def C_BEQZ : Bcz<0b110, "c.beqz",  seteq, GPRC>;
-def C_BNEZ : Bcz<0b111, "c.bnez",  setne, GPRC>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_SLLI : RVInst16CI<0b000, 0b10, (outs GPRNoX0:$rd_wb),
-                        (ins GPRNoX0:$rd, uimmlog2xlennonzero:$imm),
-                        "c.slli" ,"$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FLDSP  : CStackLoad<0b001, "c.fldsp", FPR64, uimm9_lsb000> {
-  let Inst{6-5} = imm{4-3};
-  let Inst{4-2} = imm{8-6};
-}
-
-def C_LWSP : CStackLoad<0b010, "c.lwsp", GPRNoX0, uimm8_lsb00> {
-  let Inst{6-4} = imm{4-2};
-  let Inst{3-2} = imm{7-6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FLWSP  : CStackLoad<0b011, "c.flwsp", FPR32, uimm8_lsb00> {
-  let Inst{6-4} = imm{4-2};
-  let Inst{3-2} = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_LDSP : CStackLoad<0b011, "c.ldsp", GPRNoX0, uimm9_lsb000> {
-  let Inst{6-5} = imm{4-3};
-  let Inst{4-2} = imm{8-6};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_JR : RVInst16CR<0b1000, 0b10, (outs), (ins GPRNoX0:$rs1),
-                      "c.jr", "$rs1"> {
-  let isBranch = 1;
-  let isBarrier = 1;
-  let isTerminator = 1;
-  let isIndirectBranch = 1;
-  let rs2 = 0;
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_MV : RVInst16CR<0b1000, 0b10, (outs GPRNoX0:$rs1), (ins GPRNoX0:$rs2),
-                      "c.mv", "$rs1, $rs2">;
-
-let rs1 = 0, rs2 = 0, hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-def C_EBREAK : RVInst16CR<0b1001, 0b10, (outs), (ins), "c.ebreak", "">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0,
-    isCall=1, Defs=[X1], rs2 = 0 in
-def C_JALR : RVInst16CR<0b1001, 0b10, (outs), (ins GPRNoX0:$rs1),
-                        "c.jalr", "$rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADD : RVInst16CR<0b1001, 0b10, (outs GPRNoX0:$rs1_wb),
-                       (ins GPRNoX0:$rs1, GPRNoX0:$rs2),
-                       "c.add", "$rs1, $rs2"> {
-  let Constraints = "$rs1 = $rs1_wb";
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FSDSP  : CStackStore<0b101, "c.fsdsp", FPR64, uimm9_lsb000> {
-  let Inst{12-10} = imm{5-3};
-  let Inst{9-7}   = imm{8-6};
-}
-
-def C_SWSP : CStackStore<0b110, "c.swsp", GPR, uimm8_lsb00> {
-  let Inst{12-9} = imm{5-2};
-  let Inst{8-7}  = imm{7-6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FSWSP  : CStackStore<0b111, "c.fswsp", FPR32, uimm8_lsb00> {
-  let Inst{12-9} = imm{5-2};
-  let Inst{8-7}  = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_SDSP : CStackStore<0b111, "c.sdsp", GPR, uimm9_lsb000> {
-  let Inst{12-10} = imm{5-3};
-  let Inst{9-7}   = imm{8-6};
-}
-
-// The all zeros pattern isn't a valid RISC-V instruction. It's used by GNU
-// binutils as 16-bit instruction known to be unimplemented (i.e., trapping).
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-def C_UNIMP : RVInst16<(outs), (ins), "c.unimp", "", [], InstFormatOther> {
-  let Inst{15-0} = 0;
-}
-
-} // Predicates = [HasStdExtC]
-
-//===----------------------------------------------------------------------===//
-// Compress Instruction tablegen backend.
-//===----------------------------------------------------------------------===//
-
-class CompressPat<dag input, dag output> {
-  dag Input  = input;
-  dag Output    = output;
-  list<Predicate> Predicates = [];
-}
-
-// Patterns are defined in the same order the compressed instructions appear
-// on page 82 of the ISA manual.
-
-// Quadrant 0
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(ADDI GPRC:$rd, SP:$rs1, uimm10_lsb00nonzero:$imm),
-                  (C_ADDI4SPN GPRC:$rd, SP:$rs1, uimm10_lsb00nonzero:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtD] in {
-def : CompressPat<(FLD FPR64C:$rd, GPRC:$rs1, uimm8_lsb000:$imm),
-                  (C_FLD FPR64C:$rd, GPRC:$rs1, uimm8_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtD]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(LW GPRC:$rd, GPRC:$rs1, uimm7_lsb00:$imm),
-                  (C_LW GPRC:$rd, GPRC:$rs1, uimm7_lsb00:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtF, IsRV32] in {
-def : CompressPat<(FLW FPR32C:$rd, GPRC:$rs1, uimm7_lsb00:$imm),
-                  (C_FLW FPR32C:$rd, GPRC:$rs1, uimm7_lsb00:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtF, IsRV32]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(LD GPRC:$rd, GPRC:$rs1, uimm8_lsb000:$imm),
-                  (C_LD GPRC:$rd, GPRC:$rs1, uimm8_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, IsRV64]
-
-let Predicates = [HasStdExtC, HasStdExtD] in {
-def : CompressPat<(FSD FPR64C:$rs2, GPRC:$rs1, uimm8_lsb000:$imm),
-                  (C_FSD FPR64C:$rs2, GPRC:$rs1, uimm8_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtD]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(SW GPRC:$rs2, GPRC:$rs1, uimm7_lsb00:$imm),
-                  (C_SW GPRC:$rs2, GPRC:$rs1, uimm7_lsb00:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtF, IsRV32] in {
-def : CompressPat<(FSW FPR32C:$rs2, GPRC:$rs1,uimm7_lsb00:$imm),
-                  (C_FSW FPR32C:$rs2, GPRC:$rs1, uimm7_lsb00:$imm)>;
-} // Predicate = [HasStdExtC, HasStdExtF, IsRV32]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(SD GPRC:$rs2, GPRC:$rs1, uimm8_lsb000:$imm),
-                  (C_SD GPRC:$rs2, GPRC:$rs1, uimm8_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, IsRV64]
-
-// Quadrant 1
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(ADDI X0, X0, 0), (C_NOP)>;
-def : CompressPat<(ADDI GPRNoX0:$rs1, GPRNoX0:$rs1, simm6nonzero:$imm),
-                  (C_ADDI GPRNoX0:$rs1, simm6nonzero:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, IsRV32] in {
-def : CompressPat<(JAL X1, simm12_lsb0:$offset),
-                  (C_JAL simm12_lsb0:$offset)>;
-} // Predicates = [HasStdExtC, IsRV32]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(ADDIW GPRNoX0:$rs1, GPRNoX0:$rs1, simm6:$imm),
-                  (C_ADDIW GPRNoX0:$rs1, simm6:$imm)>;
-} // Predicates = [HasStdExtC, IsRV64]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(ADDI GPRNoX0:$rd, X0, simm6:$imm),
-                  (C_LI GPRNoX0:$rd, simm6:$imm)>;
-def : CompressPat<(ADDI X2, X2, simm10_lsb0000nonzero:$imm),
-                  (C_ADDI16SP X2, simm10_lsb0000nonzero:$imm)>;
-def : CompressPat<(LUI GPRNoX0X2:$rd, c_lui_imm:$imm),
-                  (C_LUI GPRNoX0X2:$rd, c_lui_imm:$imm)>;
-def : CompressPat<(SRLI GPRC:$rs1, GPRC:$rs1, uimmlog2xlennonzero:$imm),
-                  (C_SRLI GPRC:$rs1, uimmlog2xlennonzero:$imm)>;
-def : CompressPat<(SRAI GPRC:$rs1, GPRC:$rs1, uimmlog2xlennonzero:$imm),
-                  (C_SRAI GPRC:$rs1, uimmlog2xlennonzero:$imm)>;
-def : CompressPat<(ANDI GPRC:$rs1, GPRC:$rs1, simm6:$imm),
-                  (C_ANDI GPRC:$rs1, simm6:$imm)>;
-def : CompressPat<(SUB GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                  (C_SUB GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(XOR GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                  (C_XOR GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(XOR GPRC:$rs1, GPRC:$rs2, GPRC:$rs1),
-                  (C_XOR GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(OR GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                  (C_OR GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(OR GPRC:$rs1, GPRC:$rs2, GPRC:$rs1),
-                  (C_OR GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(AND GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                  (C_AND GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(AND GPRC:$rs1, GPRC:$rs2, GPRC:$rs1),
-                  (C_AND GPRC:$rs1, GPRC:$rs2)>;
-} //  Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(ADDIW GPRNoX0:$rd, X0, simm6:$imm),
-                  (C_LI GPRNoX0:$rd, simm6:$imm)>;
-def : CompressPat<(SUBW GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                  (C_SUBW GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(ADDW GPRC:$rs1, GPRC:$rs1, GPRC:$rs2),
-                   (C_ADDW GPRC:$rs1, GPRC:$rs2)>;
-def : CompressPat<(ADDW GPRC:$rs1, GPRC:$rs2, GPRC:$rs1),
-                   (C_ADDW GPRC:$rs1, GPRC:$rs2)>;
-} // Predicates = [HasStdExtC, IsRV64]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(JAL X0, simm12_lsb0:$offset),
-                  (C_J simm12_lsb0:$offset)>;
-def : CompressPat<(BEQ GPRC:$rs1, X0, simm9_lsb0:$imm),
-                  (C_BEQZ GPRC:$rs1, simm9_lsb0:$imm)>;
-def : CompressPat<(BNE GPRC:$rs1, X0, simm9_lsb0:$imm),
-                  (C_BNEZ GPRC:$rs1, simm9_lsb0:$imm)>;
-} //  Predicates = [HasStdExtC]
-
-// Quadrant 2
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(SLLI GPRNoX0:$rs1, GPRNoX0:$rs1, uimmlog2xlennonzero:$imm),
-                  (C_SLLI GPRNoX0:$rs1, uimmlog2xlennonzero:$imm)>;
-} //  Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtD] in {
-def : CompressPat<(FLD FPR64:$rd, SP:$rs1, uimm9_lsb000:$imm),
-                  (C_FLDSP FPR64:$rd, SP:$rs1, uimm9_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtD]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(LW GPRNoX0:$rd, SP:$rs1,  uimm8_lsb00:$imm),
-                  (C_LWSP GPRNoX0:$rd, SP:$rs1, uimm8_lsb00:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtF, IsRV32] in {
-def : CompressPat<(FLW FPR32:$rd, SP:$rs1, uimm8_lsb00:$imm),
-                  (C_FLWSP FPR32:$rd, SP:$rs1, uimm8_lsb00:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtF, IsRV32]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(LD GPRNoX0:$rd, SP:$rs1, uimm9_lsb000:$imm),
-                  (C_LDSP GPRNoX0:$rd, SP:$rs1, uimm9_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, IsRV64]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(JALR X0, GPRNoX0:$rs1, 0),
-                  (C_JR GPRNoX0:$rs1)>;
-def : CompressPat<(ADD GPRNoX0:$rs1, X0, GPRNoX0:$rs2),
-                  (C_MV GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-def : CompressPat<(ADD GPRNoX0:$rs1, GPRNoX0:$rs2, X0),
-                  (C_MV GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-def : CompressPat<(ADDI GPRNoX0:$rs1, GPRNoX0:$rs2, 0),
-                  (C_MV GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-def : CompressPat<(EBREAK), (C_EBREAK)>;
-def : CompressPat<(UNIMP), (C_UNIMP)>;
-def : CompressPat<(JALR X1, GPRNoX0:$rs1, 0),
-                  (C_JALR GPRNoX0:$rs1)>;
-def : CompressPat<(ADD GPRNoX0:$rs1, GPRNoX0:$rs1, GPRNoX0:$rs2),
-                  (C_ADD GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-def : CompressPat<(ADD GPRNoX0:$rs1, GPRNoX0:$rs2, GPRNoX0:$rs1),
-                  (C_ADD GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtD] in {
-def : CompressPat<(FSD FPR64:$rs2, SP:$rs1, uimm9_lsb000:$imm),
-                  (C_FSDSP FPR64:$rs2, SP:$rs1, uimm9_lsb000:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtD]
-
-let Predicates = [HasStdExtC] in {
-def : CompressPat<(SW GPR:$rs2, SP:$rs1, uimm8_lsb00:$imm),
-                  (C_SWSP GPR:$rs2, SP:$rs1, uimm8_lsb00:$imm)>;
-} // Predicates = [HasStdExtC]
-
-let Predicates = [HasStdExtC, HasStdExtF, IsRV32] in {
-def : CompressPat<(FSW FPR32:$rs2, SP:$rs1, uimm8_lsb00:$imm),
-                  (C_FSWSP FPR32:$rs2, SP:$rs1, uimm8_lsb00:$imm)>;
-} // Predicates = [HasStdExtC, HasStdExtF, IsRV32]
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def : CompressPat<(SD GPR:$rs2, SP:$rs1, uimm9_lsb000:$imm),
-                  (C_SDSP GPR:$rs2, SP:$rs1, uimm9_lsb000:$imm)>;
-} //  Predicates = [HasStdExtC, IsRV64]
diff --git a/lib/Target/RISCV/RISCVInstrInfoD.td b/lib/Target/RISCV/RISCVInstrInfoD.td
deleted file mode 100644
index 9f1cd50de59..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoD.td
+++ /dev/null
@@ -1,310 +0,0 @@
-//===-- RISCVInstrInfoD.td - RISC-V 'D' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'D',
-// Double-Precision Floating-Point instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// RISC-V specific DAG Nodes.
-//===----------------------------------------------------------------------===//
-
-def SDT_RISCVBuildPairF64 : SDTypeProfile<1, 2, [SDTCisVT<0, f64>,
-                                                 SDTCisVT<1, i32>,
-                                                 SDTCisSameAs<1, 2>]>;
-def SDT_RISCVSplitF64     : SDTypeProfile<2, 1, [SDTCisVT<0, i32>,
-                                                 SDTCisVT<1, i32>,
-                                                 SDTCisVT<2, f64>]>;
-
-def RISCVBuildPairF64 : SDNode<"RISCVISD::BuildPairF64", SDT_RISCVBuildPairF64>;
-def RISCVSplitF64     : SDNode<"RISCVISD::SplitF64", SDT_RISCVSplitF64>;
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPFMAD_rrr_frm<RISCVOpcode opcode, string opcodestr>
-    : RVInstR4<0b01, opcode, (outs FPR64:$rd),
-               (ins FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, frmarg:$funct3),
-                opcodestr, "$rd, $rs1, $rs2, $rs3, $funct3">;
-
-class FPFMADDynFrmAlias<FPFMAD_rrr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2, $rs3",
-                (Inst FPR64:$rd, FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUD_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs FPR64:$rd),
-              (ins FPR64:$rs1, FPR64:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUD_rr_frm<bits<7> funct7, string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs FPR64:$rd),
-                (ins FPR64:$rs1, FPR64:$rs2, frmarg:$funct3), opcodestr,
-                 "$rd, $rs1, $rs2, $funct3">;
-
-class FPALUDDynFrmAlias<FPALUD_rr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2",
-                (Inst FPR64:$rd, FPR64:$rs1, FPR64:$rs2, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPCmpD_rr<bits<3> funct3, string opcodestr>
-    : RVInstR<0b1010001, funct3, OPC_OP_FP, (outs GPR:$rd),
-              (ins FPR64:$rs1, FPR64:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtD] in {
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-def FLD : RVInstI<0b011, OPC_LOAD_FP, (outs FPR64:$rd),
-                  (ins GPR:$rs1, simm12:$imm12),
-                  "fld", "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-def FSD : RVInstS<0b011, OPC_STORE_FP, (outs),
-                  (ins FPR64:$rs2, GPR:$rs1, simm12:$imm12),
-                   "fsd", "$rs2, ${imm12}(${rs1})">;
-
-def FMADD_D  : FPFMAD_rrr_frm<OPC_MADD, "fmadd.d">;
-def          : FPFMADDynFrmAlias<FMADD_D, "fmadd.d">;
-def FMSUB_D  : FPFMAD_rrr_frm<OPC_MSUB, "fmsub.d">;
-def          : FPFMADDynFrmAlias<FMSUB_D, "fmsub.d">;
-def FNMSUB_D : FPFMAD_rrr_frm<OPC_NMSUB, "fnmsub.d">;
-def          : FPFMADDynFrmAlias<FNMSUB_D, "fnmsub.d">;
-def FNMADD_D : FPFMAD_rrr_frm<OPC_NMADD, "fnmadd.d">;
-def          : FPFMADDynFrmAlias<FNMADD_D, "fnmadd.d">;
-
-def FADD_D : FPALUD_rr_frm<0b0000001, "fadd.d">;
-def        : FPALUDDynFrmAlias<FADD_D, "fadd.d">;
-def FSUB_D : FPALUD_rr_frm<0b0000101, "fsub.d">;
-def        : FPALUDDynFrmAlias<FSUB_D, "fsub.d">;
-def FMUL_D : FPALUD_rr_frm<0b0001001, "fmul.d">;
-def        : FPALUDDynFrmAlias<FMUL_D, "fmul.d">;
-def FDIV_D : FPALUD_rr_frm<0b0001101, "fdiv.d">;
-def        : FPALUDDynFrmAlias<FDIV_D, "fdiv.d">;
-
-def FSQRT_D : FPUnaryOp_r_frm<0b0101101, FPR64, FPR64, "fsqrt.d"> {
-  let rs2 = 0b00000;
-}
-def         : FPUnaryOpDynFrmAlias<FSQRT_D, "fsqrt.d", FPR64, FPR64>;
-
-def FSGNJ_D  : FPALUD_rr<0b0010001, 0b000, "fsgnj.d">;
-def FSGNJN_D : FPALUD_rr<0b0010001, 0b001, "fsgnjn.d">;
-def FSGNJX_D : FPALUD_rr<0b0010001, 0b010, "fsgnjx.d">;
-def FMIN_D   : FPALUD_rr<0b0010101, 0b000, "fmin.d">;
-def FMAX_D   : FPALUD_rr<0b0010101, 0b001, "fmax.d">;
-
-def FCVT_S_D : FPUnaryOp_r_frm<0b0100000, FPR32, FPR64, "fcvt.s.d"> {
-  let rs2 = 0b00001;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_D, "fcvt.s.d", FPR32, FPR64>;
-
-def FCVT_D_S : FPUnaryOp_r<0b0100001, 0b000, FPR64, FPR32, "fcvt.d.s"> {
-  let rs2 = 0b00000;
-}
-
-def FEQ_D : FPCmpD_rr<0b010, "feq.d">;
-def FLT_D : FPCmpD_rr<0b001, "flt.d">;
-def FLE_D : FPCmpD_rr<0b000, "fle.d">;
-
-def FCLASS_D : FPUnaryOp_r<0b1110001, 0b001, GPR, FPR64, "fclass.d"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_W_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.w.d"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_W_D, "fcvt.w.d", GPR, FPR64>;
-
-def FCVT_WU_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.wu.d"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_WU_D, "fcvt.wu.d", GPR, FPR64>;
-
-def FCVT_D_W : FPUnaryOp_r<0b1101001, 0b000, FPR64, GPR, "fcvt.d.w"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_D_WU : FPUnaryOp_r<0b1101001, 0b000, FPR64, GPR, "fcvt.d.wu"> {
-  let rs2 = 0b00001;
-}
-} // Predicates = [HasStdExtD]
-
-let Predicates = [HasStdExtD, IsRV64] in {
-def FCVT_L_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.l.d"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_L_D, "fcvt.l.d", GPR, FPR64>;
-
-def FCVT_LU_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.lu.d"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_LU_D, "fcvt.lu.d", GPR, FPR64>;
-
-def FMV_X_D : FPUnaryOp_r<0b1110001, 0b000, GPR, FPR64, "fmv.x.d"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_D_L : FPUnaryOp_r_frm<0b1101001, FPR64, GPR, "fcvt.d.l"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_D_L, "fcvt.d.l", FPR64, GPR>;
-
-def FCVT_D_LU : FPUnaryOp_r_frm<0b1101001, FPR64, GPR, "fcvt.d.lu"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_D_LU, "fcvt.d.lu", FPR64, GPR>;
-
-def FMV_D_X : FPUnaryOp_r<0b1111001, 0b000, FPR64, GPR, "fmv.d.x"> {
-  let rs2 = 0b00000;
-}
-} // Predicates = [HasStdExtD, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtD] in {
-// TODO fld
-// TODO fsd
-
-def : InstAlias<"fmv.d $rd, $rs",  (FSGNJ_D  FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-def : InstAlias<"fabs.d $rd, $rs", (FSGNJX_D FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-def : InstAlias<"fneg.d $rd, $rs", (FSGNJN_D FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-
-// fgt.d/fge.d are recognised by the GNU assembler but the canonical
-// flt.d/fle.d forms will always be printed. Therefore, set a zero weight.
-def : InstAlias<"fgt.d $rd, $rs, $rt",
-                (FLT_D GPR:$rd, FPR64:$rt, FPR64:$rs), 0>;
-def : InstAlias<"fge.d $rd, $rs, $rt",
-                (FLE_D GPR:$rd, FPR64:$rt, FPR64:$rs), 0>;
-} // Predicates = [HasStdExtD]
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//===----------------------------------------------------------------------===//
-
-class PatFpr64Fpr64<SDPatternOperator OpNode, RVInstR Inst>
-    : Pat<(OpNode FPR64:$rs1, FPR64:$rs2), (Inst $rs1, $rs2)>;
-
-class PatFpr64Fpr64DynFrm<SDPatternOperator OpNode, RVInstRFrm Inst>
-    : Pat<(OpNode FPR64:$rs1, FPR64:$rs2), (Inst $rs1, $rs2, 0b111)>;
-
-let Predicates = [HasStdExtD] in {
-
-/// Float conversion operations
-
-// f64 -> f32, f32 -> f64
-def : Pat<(fpround FPR64:$rs1), (FCVT_S_D FPR64:$rs1, 0b111)>;
-def : Pat<(fpextend FPR32:$rs1), (FCVT_D_S FPR32:$rs1)>;
-
-// [u]int<->double conversion patterns must be gated on IsRV32 or IsRV64, so
-// are defined later.
-
-/// Float arithmetic operations
-
-def : PatFpr64Fpr64DynFrm<fadd, FADD_D>;
-def : PatFpr64Fpr64DynFrm<fsub, FSUB_D>;
-def : PatFpr64Fpr64DynFrm<fmul, FMUL_D>;
-def : PatFpr64Fpr64DynFrm<fdiv, FDIV_D>;
-
-def : Pat<(fsqrt FPR64:$rs1), (FSQRT_D FPR64:$rs1, 0b111)>;
-
-def : Pat<(fneg FPR64:$rs1), (FSGNJN_D $rs1, $rs1)>;
-def : Pat<(fabs FPR64:$rs1), (FSGNJX_D $rs1, $rs1)>;
-
-def : PatFpr64Fpr64<fcopysign, FSGNJ_D>;
-def : Pat<(fcopysign FPR64:$rs1, (fneg FPR64:$rs2)), (FSGNJN_D $rs1, $rs2)>;
-
-// fmadd: rs1 * rs2 + rs3
-def : Pat<(fma FPR64:$rs1, FPR64:$rs2, FPR64:$rs3),
-          (FMADD_D $rs1, $rs2, $rs3, 0b111)>;
-
-// fmsub: rs1 * rs2 - rs3
-def : Pat<(fma FPR64:$rs1, FPR64:$rs2, (fneg FPR64:$rs3)),
-          (FMSUB_D FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, 0b111)>;
-
-// fnmsub: -rs1 * rs2 + rs3
-def : Pat<(fma (fneg FPR64:$rs1), FPR64:$rs2, FPR64:$rs3),
-          (FNMSUB_D FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, 0b111)>;
-
-// fnmadd: -rs1 * rs2 - rs3
-def : Pat<(fma (fneg FPR64:$rs1), FPR64:$rs2, (fneg FPR64:$rs3)),
-          (FNMADD_D FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, 0b111)>;
-
-// The RISC-V 2.2 user-level ISA spec defines fmin and fmax as returning the
-// canonical NaN when giving a signaling NaN. This doesn't match the LLVM
-// behaviour (see https://bugs.llvm.org/show_bug.cgi?id=27363). However, the
-// draft 2.3 ISA spec changes the definition of fmin and fmax in a way that
-// matches LLVM's fminnum and fmaxnum
-// <https://github.com/riscv/riscv-isa-manual/commit/cd20cee7efd9bac7c5aa127ec3b451749d2b3cce>.
-def : PatFpr64Fpr64<fminnum, FMIN_D>;
-def : PatFpr64Fpr64<fmaxnum, FMAX_D>;
-
-/// Setcc
-
-def : PatFpr64Fpr64<seteq, FEQ_D>;
-def : PatFpr64Fpr64<setoeq, FEQ_D>;
-def : PatFpr64Fpr64<setlt, FLT_D>;
-def : PatFpr64Fpr64<setolt, FLT_D>;
-def : PatFpr64Fpr64<setle, FLE_D>;
-def : PatFpr64Fpr64<setole, FLE_D>;
-
-// Define pattern expansions for setcc operations which aren't directly
-// handled by a RISC-V instruction and aren't expanded in the SelectionDAG
-// Legalizer.
-
-def : Pat<(setuo FPR64:$rs1, FPR64:$rs2),
-          (SLTIU (AND (FEQ_D FPR64:$rs1, FPR64:$rs1),
-                      (FEQ_D FPR64:$rs2, FPR64:$rs2)),
-                 1)>;
-
-def Select_FPR64_Using_CC_GPR : SelectCC_rrirr<FPR64, GPR>;
-
-/// Loads
-
-defm : LdPat<load, FLD>;
-
-/// Stores
-
-defm : StPat<store, FSD, FPR64>;
-
-/// Pseudo-instructions needed for the soft-float ABI with RV32D
-
-// Moves two GPRs to an FPR.
-let usesCustomInserter = 1 in
-def BuildPairF64Pseudo
-    : Pseudo<(outs FPR64:$dst), (ins GPR:$src1, GPR:$src2),
-             [(set FPR64:$dst, (RISCVBuildPairF64 GPR:$src1, GPR:$src2))]>;
-
-// Moves an FPR to two GPRs.
-let usesCustomInserter = 1 in
-def SplitF64Pseudo
-    : Pseudo<(outs GPR:$dst1, GPR:$dst2), (ins FPR64:$src),
-             [(set GPR:$dst1, GPR:$dst2, (RISCVSplitF64 FPR64:$src))]>;
-
-} // Predicates = [HasStdExtD]
-
-let Predicates = [HasStdExtD, IsRV32] in {
-// double->[u]int. Round-to-zero must be used.
-def : Pat<(fp_to_sint FPR64:$rs1), (FCVT_W_D FPR64:$rs1, 0b001)>;
-def : Pat<(fp_to_uint FPR64:$rs1), (FCVT_WU_D FPR64:$rs1, 0b001)>;
-
-// [u]int->double.
-def : Pat<(sint_to_fp GPR:$rs1), (FCVT_D_W GPR:$rs1)>;
-def : Pat<(uint_to_fp GPR:$rs1), (FCVT_D_WU GPR:$rs1)>;
-} // Predicates = [HasStdExtD, IsRV32]
diff --git a/lib/Target/RISCV/RISCVInstrInfoF.td b/lib/Target/RISCV/RISCVInstrInfoF.td
deleted file mode 100644
index 03bdac45873..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoF.td
+++ /dev/null
@@ -1,336 +0,0 @@
-//===-- RISCVInstrInfoF.td - RISC-V 'F' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'F',
-// Single-Precision Floating-Point instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Operand and SDNode transformation definitions.
-//===----------------------------------------------------------------------===//
-
-// Floating-point rounding mode
-
-def FRMArg : AsmOperandClass {
-  let Name = "FRMArg";
-  let RenderMethod = "addFRMArgOperands";
-  let DiagnosticType = "InvalidFRMArg";
-}
-
-def frmarg : Operand<XLenVT> {
-  let ParserMatchClass = FRMArg;
-  let PrintMethod = "printFRMArg";
-  let DecoderMethod = "decodeFRMArg";
-}
-
-//===----------------------------------------------------------------------===//
-// Instruction class templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPFMAS_rrr_frm<RISCVOpcode opcode, string opcodestr>
-    : RVInstR4<0b00, opcode, (outs FPR32:$rd),
-               (ins FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, frmarg:$funct3),
-                opcodestr, "$rd, $rs1, $rs2, $rs3, $funct3">;
-
-class FPFMASDynFrmAlias<FPFMAS_rrr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2, $rs3",
-                (Inst FPR32:$rd, FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUS_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs FPR32:$rd),
-              (ins FPR32:$rs1, FPR32:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUS_rr_frm<bits<7> funct7, string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs FPR32:$rd),
-                 (ins FPR32:$rs1, FPR32:$rs2, frmarg:$funct3), opcodestr,
-                  "$rd, $rs1, $rs2, $funct3">;
-
-class FPALUSDynFrmAlias<FPALUS_rr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2",
-                (Inst FPR32:$rd, FPR32:$rs1, FPR32:$rs2, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPUnaryOp_r<bits<7> funct7, bits<3> funct3, RegisterClass rdty,
-                RegisterClass rs1ty, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs rdty:$rd), (ins rs1ty:$rs1),
-              opcodestr, "$rd, $rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPUnaryOp_r_frm<bits<7> funct7, RegisterClass rdty, RegisterClass rs1ty,
-                      string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs rdty:$rd),
-                 (ins rs1ty:$rs1, frmarg:$funct3), opcodestr,
-                  "$rd, $rs1, $funct3">;
-
-class FPUnaryOpDynFrmAlias<FPUnaryOp_r_frm Inst, string OpcodeStr,
-                           RegisterClass rdty, RegisterClass rs1ty>
-    : InstAlias<OpcodeStr#" $rd, $rs1",
-                (Inst rdty:$rd, rs1ty:$rs1, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPCmpS_rr<bits<3> funct3, string opcodestr>
-    : RVInstR<0b1010000, funct3, OPC_OP_FP, (outs GPR:$rd),
-              (ins FPR32:$rs1, FPR32:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtF] in {
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-def FLW : RVInstI<0b010, OPC_LOAD_FP, (outs FPR32:$rd),
-                  (ins GPR:$rs1, simm12:$imm12),
-                   "flw", "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-def FSW : RVInstS<0b010, OPC_STORE_FP, (outs),
-                  (ins FPR32:$rs2, GPR:$rs1, simm12:$imm12),
-                   "fsw", "$rs2, ${imm12}(${rs1})">;
-
-def FMADD_S  : FPFMAS_rrr_frm<OPC_MADD, "fmadd.s">;
-def          : FPFMASDynFrmAlias<FMADD_S, "fmadd.s">;
-def FMSUB_S  : FPFMAS_rrr_frm<OPC_MSUB, "fmsub.s">;
-def          : FPFMASDynFrmAlias<FMSUB_S, "fmsub.s">;
-def FNMSUB_S : FPFMAS_rrr_frm<OPC_NMSUB, "fnmsub.s">;
-def          : FPFMASDynFrmAlias<FNMSUB_S, "fnmsub.s">;
-def FNMADD_S : FPFMAS_rrr_frm<OPC_NMADD, "fnmadd.s">;
-def          : FPFMASDynFrmAlias<FNMADD_S, "fnmadd.s">;
-
-def FADD_S : FPALUS_rr_frm<0b0000000, "fadd.s">;
-def        : FPALUSDynFrmAlias<FADD_S, "fadd.s">;
-def FSUB_S : FPALUS_rr_frm<0b0000100, "fsub.s">;
-def        : FPALUSDynFrmAlias<FSUB_S, "fsub.s">;
-def FMUL_S : FPALUS_rr_frm<0b0001000, "fmul.s">;
-def        : FPALUSDynFrmAlias<FMUL_S, "fmul.s">;
-def FDIV_S : FPALUS_rr_frm<0b0001100, "fdiv.s">;
-def        : FPALUSDynFrmAlias<FDIV_S, "fdiv.s">;
-
-def FSQRT_S : FPUnaryOp_r_frm<0b0101100, FPR32, FPR32, "fsqrt.s"> {
-  let rs2 = 0b00000;
-}
-def         : FPUnaryOpDynFrmAlias<FSQRT_S, "fsqrt.s", FPR32, FPR32>;
-
-def FSGNJ_S  : FPALUS_rr<0b0010000, 0b000, "fsgnj.s">;
-def FSGNJN_S : FPALUS_rr<0b0010000, 0b001, "fsgnjn.s">;
-def FSGNJX_S : FPALUS_rr<0b0010000, 0b010, "fsgnjx.s">;
-def FMIN_S   : FPALUS_rr<0b0010100, 0b000, "fmin.s">;
-def FMAX_S   : FPALUS_rr<0b0010100, 0b001, "fmax.s">;
-
-def FCVT_W_S : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.w.s"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_W_S, "fcvt.w.s", GPR, FPR32>;
-
-def FCVT_WU_S : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.wu.s"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_WU_S, "fcvt.wu.s", GPR, FPR32>;
-
-def FMV_X_W : FPUnaryOp_r<0b1110000, 0b000, GPR, FPR32, "fmv.x.w"> {
-  let rs2 = 0b00000;
-}
-
-def FEQ_S : FPCmpS_rr<0b010, "feq.s">;
-def FLT_S : FPCmpS_rr<0b001, "flt.s">;
-def FLE_S : FPCmpS_rr<0b000, "fle.s">;
-
-def FCLASS_S : FPUnaryOp_r<0b1110000, 0b001, GPR, FPR32, "fclass.s"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_S_W : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.w"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_W, "fcvt.s.w", FPR32, GPR>;
-
-def FCVT_S_WU : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.wu"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_S_WU, "fcvt.s.wu", FPR32, GPR>;
-
-def FMV_W_X : FPUnaryOp_r<0b1111000, 0b000, FPR32, GPR, "fmv.w.x"> {
-  let rs2 = 0b00000;
-}
-} // Predicates = [HasStdExtF]
-
-let Predicates = [HasStdExtF, IsRV64] in {
-def FCVT_L_S  : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.l.s"> {
-  let rs2 = 0b00010;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_L_S, "fcvt.l.s", GPR, FPR32>;
-
-def FCVT_LU_S  : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.lu.s"> {
-  let rs2 = 0b00011;
-}
-def            : FPUnaryOpDynFrmAlias<FCVT_LU_S, "fcvt.lu.s", GPR, FPR32>;
-
-def FCVT_S_L : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.l"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_L, "fcvt.s.l", FPR32, GPR>;
-
-def FCVT_S_LU : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.lu"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_S_LU, "fcvt.s.lu", FPR32, GPR>;
-} // Predicates = [HasStdExtF, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtF] in {
-// TODO flw
-// TODO fsw
-
-def : InstAlias<"fmv.s $rd, $rs",  (FSGNJ_S  FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-def : InstAlias<"fabs.s $rd, $rs", (FSGNJX_S FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-def : InstAlias<"fneg.s $rd, $rs", (FSGNJN_S FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-
-// fgt.s/fge.s are recognised by the GNU assembler but the canonical
-// flt.s/fle.s forms will always be printed. Therefore, set a zero weight.
-def : InstAlias<"fgt.s $rd, $rs, $rt",
-                (FLT_S GPR:$rd, FPR32:$rt, FPR32:$rs), 0>;
-def : InstAlias<"fge.s $rd, $rs, $rt",
-                (FLE_S GPR:$rd, FPR32:$rt, FPR32:$rs), 0>;
-
-// The following csr instructions actually alias instructions from the base ISA.
-// However, it only makes sense to support them when the F extension is enabled.
-// CSR Addresses: 0x003 == fcsr, 0x002 == frm, 0x001 == fflags
-// NOTE: "frcsr", "frrm", and "frflags" are more specialized version of "csrr".
-def : InstAlias<"frcsr $rd",      (CSRRS GPR:$rd, 0x003, X0), 2>;
-def : InstAlias<"fscsr $rd, $rs", (CSRRW GPR:$rd, 0x003, GPR:$rs)>;
-def : InstAlias<"fscsr $rs",      (CSRRW      X0, 0x003, GPR:$rs), 2>;
-
-def : InstAlias<"frrm $rd",        (CSRRS  GPR:$rd, 0x002, X0), 2>;
-def : InstAlias<"fsrm $rd, $rs",   (CSRRW  GPR:$rd, 0x002, GPR:$rs)>;
-def : InstAlias<"fsrm $rs",        (CSRRW       X0, 0x002, GPR:$rs), 2>;
-def : InstAlias<"fsrmi $rd, $imm", (CSRRWI GPR:$rd, 0x002, uimm5:$imm)>;
-def : InstAlias<"fsrmi $imm",      (CSRRWI      X0, 0x002, uimm5:$imm), 2>;
-
-def : InstAlias<"frflags $rd",        (CSRRS  GPR:$rd, 0x001, X0), 2>;
-def : InstAlias<"fsflags $rd, $rs",   (CSRRW  GPR:$rd, 0x001, GPR:$rs)>;
-def : InstAlias<"fsflags $rs",        (CSRRW       X0, 0x001, GPR:$rs), 2>;
-def : InstAlias<"fsflagsi $rd, $imm", (CSRRWI GPR:$rd, 0x001, uimm5:$imm)>;
-def : InstAlias<"fsflagsi $imm",      (CSRRWI      X0, 0x001, uimm5:$imm), 2>;
-
-// fmv.w.x and fmv.x.w were previously known as fmv.s.x and fmv.x.s. Both
-// spellings should be supported by standard tools.
-def : MnemonicAlias<"fmv.s.x", "fmv.w.x">;
-def : MnemonicAlias<"fmv.x.s", "fmv.x.w">;
-} // Predicates = [HasStdExtF]
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//===----------------------------------------------------------------------===//
-
-/// Generic pattern classes
-class PatFpr32Fpr32<SDPatternOperator OpNode, RVInstR Inst>
-    : Pat<(OpNode FPR32:$rs1, FPR32:$rs2), (Inst $rs1, $rs2)>;
-
-class PatFpr32Fpr32DynFrm<SDPatternOperator OpNode, RVInstRFrm Inst>
-    : Pat<(OpNode FPR32:$rs1, FPR32:$rs2), (Inst $rs1, $rs2, 0b111)>;
-
-let Predicates = [HasStdExtF] in {
-
-/// Float conversion operations
-
-// Moves (no conversion)
-def : Pat<(bitconvert GPR:$rs1), (FMV_W_X GPR:$rs1)>;
-def : Pat<(bitconvert FPR32:$rs1), (FMV_X_W FPR32:$rs1)>;
-
-// [u]int32<->float conversion patterns must be gated on IsRV32 or IsRV64, so
-// are defined later.
-
-/// Float arithmetic operations
-
-def : PatFpr32Fpr32DynFrm<fadd, FADD_S>;
-def : PatFpr32Fpr32DynFrm<fsub, FSUB_S>;
-def : PatFpr32Fpr32DynFrm<fmul, FMUL_S>;
-def : PatFpr32Fpr32DynFrm<fdiv, FDIV_S>;
-
-def : Pat<(fsqrt FPR32:$rs1), (FSQRT_S FPR32:$rs1, 0b111)>;
-
-def : Pat<(fneg FPR32:$rs1), (FSGNJN_S $rs1, $rs1)>;
-def : Pat<(fabs FPR32:$rs1), (FSGNJX_S $rs1, $rs1)>;
-
-def : PatFpr32Fpr32<fcopysign, FSGNJ_S>;
-def : Pat<(fcopysign FPR32:$rs1, (fneg FPR32:$rs2)), (FSGNJN_S $rs1, $rs2)>;
-
-// fmadd: rs1 * rs2 + rs3
-def : Pat<(fma FPR32:$rs1, FPR32:$rs2, FPR32:$rs3),
-          (FMADD_S $rs1, $rs2, $rs3, 0b111)>;
-
-// fmsub: rs1 * rs2 - rs3
-def : Pat<(fma FPR32:$rs1, FPR32:$rs2, (fneg FPR32:$rs3)),
-          (FMSUB_S FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, 0b111)>;
-
-// fnmsub: -rs1 * rs2 + rs3
-def : Pat<(fma (fneg FPR32:$rs1), FPR32:$rs2, FPR32:$rs3),
-          (FNMSUB_S FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, 0b111)>;
-
-// fnmadd: -rs1 * rs2 - rs3
-def : Pat<(fma (fneg FPR32:$rs1), FPR32:$rs2, (fneg FPR32:$rs3)),
-          (FNMADD_S FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, 0b111)>;
-
-// The RISC-V 2.2 user-level ISA spec defines fmin and fmax as returning the
-// canonical NaN when given a signaling NaN. This doesn't match the LLVM
-// behaviour (see https://bugs.llvm.org/show_bug.cgi?id=27363). However, the
-// draft 2.3 ISA spec changes the definition of fmin and fmax in a way that
-// matches LLVM's fminnum and fmaxnum
-// <https://github.com/riscv/riscv-isa-manual/commit/cd20cee7efd9bac7c5aa127ec3b451749d2b3cce>.
-def : PatFpr32Fpr32<fminnum, FMIN_S>;
-def : PatFpr32Fpr32<fmaxnum, FMAX_S>;
-
-/// Setcc
-
-def : PatFpr32Fpr32<seteq, FEQ_S>;
-def : PatFpr32Fpr32<setoeq, FEQ_S>;
-def : PatFpr32Fpr32<setlt, FLT_S>;
-def : PatFpr32Fpr32<setolt, FLT_S>;
-def : PatFpr32Fpr32<setle, FLE_S>;
-def : PatFpr32Fpr32<setole, FLE_S>;
-
-// Define pattern expansions for setcc operations which aren't directly
-// handled by a RISC-V instruction and aren't expanded in the SelectionDAG
-// Legalizer.
-
-def : Pat<(setuo FPR32:$rs1, FPR32:$rs2),
-          (SLTIU (AND (FEQ_S FPR32:$rs1, FPR32:$rs1),
-                      (FEQ_S FPR32:$rs2, FPR32:$rs2)),
-                 1)>;
-
-def Select_FPR32_Using_CC_GPR : SelectCC_rrirr<FPR32, GPR>;
-
-/// Loads
-
-defm : LdPat<load, FLW>;
-
-/// Stores
-
-defm : StPat<store, FSW, FPR32>;
-
-} // Predicates = [HasStdExtF]
-
-let Predicates = [HasStdExtF, IsRV32] in {
-// float->[u]int. Round-to-zero must be used.
-def : Pat<(fp_to_sint FPR32:$rs1), (FCVT_W_S $rs1, 0b001)>;
-def : Pat<(fp_to_uint FPR32:$rs1), (FCVT_WU_S $rs1, 0b001)>;
-
-// [u]int->float. Match GCC and default to using dynamic rounding mode.
-def : Pat<(sint_to_fp GPR:$rs1), (FCVT_S_W $rs1, 0b111)>;
-def : Pat<(uint_to_fp GPR:$rs1), (FCVT_S_WU $rs1, 0b111)>;
-} // Predicates = [HasStdExtF, IsRV32]
diff --git a/lib/Target/RISCV/RISCVInstrInfoM.td b/lib/Target/RISCV/RISCVInstrInfoM.td
deleted file mode 100644
index 2dd10ada400..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoM.td
+++ /dev/null
@@ -1,51 +0,0 @@
-//===-- RISCVInstrInfoM.td - RISC-V 'M' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'M', Integer
-// Multiplication and Division instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtM] in {
-def MUL     : ALU_rr<0b0000001, 0b000, "mul">;
-def MULH    : ALU_rr<0b0000001, 0b001, "mulh">;
-def MULHSU  : ALU_rr<0b0000001, 0b010, "mulhsu">;
-def MULHU   : ALU_rr<0b0000001, 0b011, "mulhu">;
-def DIV     : ALU_rr<0b0000001, 0b100, "div">;
-def DIVU    : ALU_rr<0b0000001, 0b101, "divu">;
-def REM     : ALU_rr<0b0000001, 0b110, "rem">;
-def REMU    : ALU_rr<0b0000001, 0b111, "remu">;
-} // Predicates = [HasStdExtM]
-
-let Predicates = [HasStdExtM, IsRV64] in {
-def MULW    : ALUW_rr<0b0000001, 0b000, "mulw">;
-def DIVW    : ALUW_rr<0b0000001, 0b100, "divw">;
-def DIVUW   : ALUW_rr<0b0000001, 0b101, "divuw">;
-def REMW    : ALUW_rr<0b0000001, 0b110, "remw">;
-def REMUW   : ALUW_rr<0b0000001, 0b111, "remuw">;
-} // Predicates = [HasStdExtM, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtM] in {
-def : PatGprGpr<mul, MUL>;
-def : PatGprGpr<mulhs, MULH>;
-def : PatGprGpr<mulhu, MULHU>;
-// No ISDOpcode for mulhsu
-def : PatGprGpr<sdiv, DIV>;
-def : PatGprGpr<udiv, DIVU>;
-def : PatGprGpr<srem, REM>;
-def : PatGprGpr<urem, REMU>;
-} // Predicates = [HasStdExtM]
diff --git a/lib/Target/RISCV/RISCVMCInstLower.cpp b/lib/Target/RISCV/RISCVMCInstLower.cpp
deleted file mode 100644
index e0100b1679b..00000000000
--- a/lib/Target/RISCV/RISCVMCInstLower.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-//===-- RISCVMCInstLower.cpp - Convert RISCV MachineInstr to an MCInst ------=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains code to lower RISCV MachineInstrs to their corresponding
-// MCInst records.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "llvm/CodeGen/AsmPrinter.h"
-#include "llvm/CodeGen/MachineBasicBlock.h"
-#include "llvm/CodeGen/MachineInstr.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-static MCOperand lowerSymbolOperand(const MachineOperand &MO, MCSymbol *Sym,
-                                    const AsmPrinter &AP) {
-  MCContext &Ctx = AP.OutContext;
-  RISCVMCExpr::VariantKind Kind;
-
-  switch (MO.getTargetFlags()) {
-  default:
-    llvm_unreachable("Unknown target flag on GV operand");
-  case RISCVII::MO_None:
-    Kind = RISCVMCExpr::VK_RISCV_None;
-    break;
-  case RISCVII::MO_LO:
-    Kind = RISCVMCExpr::VK_RISCV_LO;
-    break;
-  case RISCVII::MO_HI:
-    Kind = RISCVMCExpr::VK_RISCV_HI;
-    break;
-  }
-
-  const MCExpr *ME =
-      MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, Ctx);
-
-  if (!MO.isJTI() && !MO.isMBB() && MO.getOffset())
-    ME = MCBinaryExpr::createAdd(
-        ME, MCConstantExpr::create(MO.getOffset(), Ctx), Ctx);
-
-  if (Kind != RISCVMCExpr::VK_RISCV_None)
-    ME = RISCVMCExpr::create(ME, Kind, Ctx);
-  return MCOperand::createExpr(ME);
-}
-
-bool llvm::LowerRISCVMachineOperandToMCOperand(const MachineOperand &MO,
-                                               MCOperand &MCOp,
-                                               const AsmPrinter &AP) {
-  switch (MO.getType()) {
-  default:
-    report_fatal_error("LowerRISCVMachineInstrToMCInst: unknown operand type");
-  case MachineOperand::MO_Register:
-    // Ignore all implicit register operands.
-    if (MO.isImplicit())
-      return false;
-    MCOp = MCOperand::createReg(MO.getReg());
-    break;
-  case MachineOperand::MO_RegisterMask:
-    // Regmasks are like implicit defs.
-    return false;
-  case MachineOperand::MO_Immediate:
-    MCOp = MCOperand::createImm(MO.getImm());
-    break;
-  case MachineOperand::MO_MachineBasicBlock:
-    MCOp = lowerSymbolOperand(MO, MO.getMBB()->getSymbol(), AP);
-    break;
-  case MachineOperand::MO_GlobalAddress:
-    MCOp = lowerSymbolOperand(MO, AP.getSymbol(MO.getGlobal()), AP);
-    break;
-  case MachineOperand::MO_BlockAddress:
-    MCOp = lowerSymbolOperand(
-        MO, AP.GetBlockAddressSymbol(MO.getBlockAddress()), AP);
-    break;
-  case MachineOperand::MO_ExternalSymbol:
-    MCOp = lowerSymbolOperand(
-        MO, AP.GetExternalSymbolSymbol(MO.getSymbolName()), AP);
-    break;
-  case MachineOperand::MO_ConstantPoolIndex:
-    MCOp = lowerSymbolOperand(MO, AP.GetCPISymbol(MO.getIndex()), AP);
-    break;
-  }
-  return true;
-}
-
-void llvm::LowerRISCVMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
-                                          const AsmPrinter &AP) {
-  OutMI.setOpcode(MI->getOpcode());
-
-  for (const MachineOperand &MO : MI->operands()) {
-    MCOperand MCOp;
-    if (LowerRISCVMachineOperandToMCOperand(MO, MCOp, AP))
-      OutMI.addOperand(MCOp);
-  }
-}
diff --git a/lib/Target/RISCV/RISCVMachineFunctionInfo.h b/lib/Target/RISCV/RISCVMachineFunctionInfo.h
deleted file mode 100644
index 2fea3a1bdd2..00000000000
--- a/lib/Target/RISCV/RISCVMachineFunctionInfo.h
+++ /dev/null
@@ -1,55 +0,0 @@
-//=- RISCVMachineFunctionInfo.h - RISCV machine function info -----*- C++ -*-=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares RISCV-specific per-machine-function information.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
-
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-
-namespace llvm {
-
-/// RISCVMachineFunctionInfo - This class is derived from MachineFunctionInfo
-/// and contains private RISCV-specific information for each MachineFunction.
-class RISCVMachineFunctionInfo : public MachineFunctionInfo {
-private:
-  MachineFunction &MF;
-  /// FrameIndex for start of varargs area
-  int VarArgsFrameIndex = 0;
-  /// Size of the save area used for varargs
-  int VarArgsSaveSize = 0;
-  /// FrameIndex used for transferring values between 64-bit FPRs and a pair
-  /// of 32-bit GPRs via the stack.
-  int MoveF64FrameIndex = -1;
-
-public:
-  //  RISCVMachineFunctionInfo() = default;
-
-  RISCVMachineFunctionInfo(MachineFunction &MF) : MF(MF) {}
-
-  int getVarArgsFrameIndex() const { return VarArgsFrameIndex; }
-  void setVarArgsFrameIndex(int Index) { VarArgsFrameIndex = Index; }
-
-  unsigned getVarArgsSaveSize() const { return VarArgsSaveSize; }
-  void setVarArgsSaveSize(int Size) { VarArgsSaveSize = Size; }
-
-  int getMoveF64FrameIndex() {
-    if (MoveF64FrameIndex == -1)
-      MoveF64FrameIndex = MF.getFrameInfo().CreateStackObject(8, 8, false);
-    return MoveF64FrameIndex;
-  }
-};
-
-} // end namespace llvm
-
-#endif // LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
diff --git a/lib/Target/RISCV/RISCVMergeBaseOffset.cpp b/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
deleted file mode 100644
index cea009c5447..00000000000
--- a/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
+++ /dev/null
@@ -1,286 +0,0 @@
-//===----- RISCVMergeBaseOffset.cpp - Optimise address calculations  ------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Merge the offset of address calculation into the offset field
-// of instructions in a global address lowering sequence. This pass transforms:
-//   lui  vreg1, %hi(s)
-//   addi vreg2, vreg1, %lo(s)
-//   addi vreg3, verg2, Offset
-//
-//   Into:
-//   lui  vreg1, %hi(s+Offset)
-//   addi vreg2, vreg1, %lo(s+Offset)
-//
-// The transformation is carried out under certain conditions:
-// 1) The offset field in the base of global address lowering sequence is zero.
-// 2) The lowered global address has only one use.
-//
-// The offset field can be in a different form. This pass handles all of them.
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/CodeGen/Passes.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/TargetRegistry.h"
-#include "llvm/Target/TargetOptions.h"
-#include <set>
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-merge-base-offset"
-#define RISCV_MERGE_BASE_OFFSET_NAME "RISCV Merge Base Offset"
-namespace {
-
-struct RISCVMergeBaseOffsetOpt : public MachineFunctionPass {
-  static char ID;
-  const MachineFunction *MF;
-  bool runOnMachineFunction(MachineFunction &Fn) override;
-  bool detectLuiAddiGlobal(MachineInstr &LUI, MachineInstr *&ADDI);
-
-  bool detectAndFoldOffset(MachineInstr &HiLUI, MachineInstr &LoADDI);
-  void foldOffset(MachineInstr &HiLUI, MachineInstr &LoADDI, MachineInstr &Tail,
-                  int64_t Offset);
-  bool matchLargeOffset(MachineInstr &TailAdd, unsigned GSReg, int64_t &Offset);
-  RISCVMergeBaseOffsetOpt() : MachineFunctionPass(ID) {}
-
-  MachineFunctionProperties getRequiredProperties() const override {
-    return MachineFunctionProperties().set(
-        MachineFunctionProperties::Property::IsSSA);
-  }
-
-  StringRef getPassName() const override {
-    return RISCV_MERGE_BASE_OFFSET_NAME;
-  }
-
-private:
-  MachineRegisterInfo *MRI;
-  std::set<MachineInstr *> DeadInstrs;
-};
-} // end anonymous namespace
-
-char RISCVMergeBaseOffsetOpt::ID = 0;
-INITIALIZE_PASS(RISCVMergeBaseOffsetOpt, "riscv-merge-base-offset",
-                RISCV_MERGE_BASE_OFFSET_NAME, false, false)
-
-// Detect the pattern:
-//   lui   vreg1, %hi(s)
-//   addi  vreg2, vreg1, %lo(s)
-//
-//   Pattern only accepted if:
-//     1) ADDI has only one use.
-//     2) LUI has only one use; which is the ADDI.
-//     3) Both ADDI and LUI have GlobalAddress type which indicates that these
-//        are generated from global address lowering.
-//     4) Offset value in the Global Address is 0.
-bool RISCVMergeBaseOffsetOpt::detectLuiAddiGlobal(MachineInstr &HiLUI,
-                                                  MachineInstr *&LoADDI) {
-  if (HiLUI.getOpcode() != RISCV::LUI ||
-      HiLUI.getOperand(1).getTargetFlags() != RISCVII::MO_HI ||
-      HiLUI.getOperand(1).getType() != MachineOperand::MO_GlobalAddress ||
-      HiLUI.getOperand(1).getOffset() != 0 ||
-      !MRI->hasOneUse(HiLUI.getOperand(0).getReg()))
-    return false;
-  unsigned HiLuiDestReg = HiLUI.getOperand(0).getReg();
-  LoADDI = MRI->use_begin(HiLuiDestReg)->getParent();
-  if (LoADDI->getOpcode() != RISCV::ADDI ||
-      LoADDI->getOperand(2).getTargetFlags() != RISCVII::MO_LO ||
-      LoADDI->getOperand(2).getType() != MachineOperand::MO_GlobalAddress ||
-      LoADDI->getOperand(2).getOffset() != 0 ||
-      !MRI->hasOneUse(LoADDI->getOperand(0).getReg()))
-    return false;
-  return true;
-}
-
-// Update the offset in HiLUI and LoADDI instructions.
-// Delete the tail instruction and update all the uses to use the
-// output from LoADDI.
-void RISCVMergeBaseOffsetOpt::foldOffset(MachineInstr &HiLUI,
-                                         MachineInstr &LoADDI,
-                                         MachineInstr &Tail, int64_t Offset) {
-  // Put the offset back in HiLUI and the LoADDI
-  HiLUI.getOperand(1).setOffset(Offset);
-  LoADDI.getOperand(2).setOffset(Offset);
-  // Delete the tail instruction.
-  DeadInstrs.insert(&Tail);
-  MRI->replaceRegWith(Tail.getOperand(0).getReg(),
-                      LoADDI.getOperand(0).getReg());
-  LLVM_DEBUG(dbgs() << "  Merged offset " << Offset << " into base.\n"
-                    << "     " << HiLUI << "     " << LoADDI;);
-}
-
-// Detect patterns for large offsets that are passed into an ADD instruction.
-//
-//                     Base address lowering is of the form:
-//                        HiLUI:  lui   vreg1, %hi(s)
-//                       LoADDI:  addi  vreg2, vreg1, %lo(s)
-//                       /                                  \
-//                      /                                    \
-//                     /                                      \
-//                    /  The large offset can be of two forms: \
-//  1) Offset that has non zero bits in lower      2) Offset that has non zero
-//     12 bits and upper 20 bits                      bits in upper 20 bits only
-//   OffseLUI: lui   vreg3, 4
-// OffsetTail: addi  voff, vreg3, 188                OffsetTail: lui  voff, 128
-//                    \                                        /
-//                     \                                      /
-//                      \                                    /
-//                       \                                  /
-//                         TailAdd: add  vreg4, vreg2, voff
-bool RISCVMergeBaseOffsetOpt::matchLargeOffset(MachineInstr &TailAdd,
-                                               unsigned GAReg,
-                                               int64_t &Offset) {
-  assert((TailAdd.getOpcode() == RISCV::ADD) && "Expected ADD instruction!");
-  unsigned Rs = TailAdd.getOperand(1).getReg();
-  unsigned Rt = TailAdd.getOperand(2).getReg();
-  unsigned Reg = Rs == GAReg ? Rt : Rs;
-
-  // Can't fold if the register has more than one use.
-  if (!MRI->hasOneUse(Reg))
-    return false;
-  // This can point to an ADDI or a LUI:
-  MachineInstr &OffsetTail = *MRI->getVRegDef(Reg);
-  if (OffsetTail.getOpcode() == RISCV::ADDI) {
-    // The offset value has non zero bits in both %hi and %lo parts.
-    // Detect an ADDI that feeds from a LUI instruction.
-    MachineOperand &AddiImmOp = OffsetTail.getOperand(2);
-    if (AddiImmOp.getTargetFlags() != RISCVII::MO_None)
-      return false;
-    int64_t OffLo = AddiImmOp.getImm();
-    MachineInstr &OffsetLui =
-        *MRI->getVRegDef(OffsetTail.getOperand(1).getReg());
-    MachineOperand &LuiImmOp = OffsetLui.getOperand(1);
-    if (OffsetLui.getOpcode() != RISCV::LUI ||
-        LuiImmOp.getTargetFlags() != RISCVII::MO_None ||
-        !MRI->hasOneUse(OffsetLui.getOperand(0).getReg()))
-      return false;
-    int64_t OffHi = OffsetLui.getOperand(1).getImm();
-    Offset = (OffHi << 12) + OffLo;
-    LLVM_DEBUG(dbgs() << "  Offset Instrs: " << OffsetTail
-                      << "                 " << OffsetLui);
-    DeadInstrs.insert(&OffsetTail);
-    DeadInstrs.insert(&OffsetLui);
-    return true;
-  } else if (OffsetTail.getOpcode() == RISCV::LUI) {
-    // The offset value has all zero bits in the lower 12 bits. Only LUI
-    // exists.
-    LLVM_DEBUG(dbgs() << "  Offset Instr: " << OffsetTail);
-    Offset = OffsetTail.getOperand(1).getImm() << 12;
-    DeadInstrs.insert(&OffsetTail);
-    return true;
-  }
-  return false;
-}
-
-bool RISCVMergeBaseOffsetOpt::detectAndFoldOffset(MachineInstr &HiLUI,
-                                                  MachineInstr &LoADDI) {
-  unsigned DestReg = LoADDI.getOperand(0).getReg();
-  assert(MRI->hasOneUse(DestReg) && "expected one use for LoADDI");
-  // LoADDI has only one use.
-  MachineInstr &Tail = *MRI->use_begin(DestReg)->getParent();
-  switch (Tail.getOpcode()) {
-  default:
-    LLVM_DEBUG(dbgs() << "Don't know how to get offset from this instr:"
-                      << Tail);
-    return false;
-  case RISCV::ADDI: {
-    // Offset is simply an immediate operand.
-    int64_t Offset = Tail.getOperand(2).getImm();
-    LLVM_DEBUG(dbgs() << "  Offset Instr: " << Tail);
-    foldOffset(HiLUI, LoADDI, Tail, Offset);
-    return true;
-  } break;
-  case RISCV::ADD: {
-    // The offset is too large to fit in the immediate field of ADDI.
-    // This can be in two forms:
-    // 1) LUI hi_Offset followed by:
-    //    ADDI lo_offset
-    //    This happens in case the offset has non zero bits in
-    //    both hi 20 and lo 12 bits.
-    // 2) LUI (offset20)
-    //    This happens in case the lower 12 bits of the offset are zeros.
-    int64_t Offset;
-    if (!matchLargeOffset(Tail, DestReg, Offset))
-      return false;
-    foldOffset(HiLUI, LoADDI, Tail, Offset);
-    return true;
-  } break;
-  case RISCV::LB:
-  case RISCV::LH:
-  case RISCV::LW:
-  case RISCV::LBU:
-  case RISCV::LHU:
-  case RISCV::LWU:
-  case RISCV::LD:
-  case RISCV::FLW:
-  case RISCV::FLD:
-  case RISCV::SB:
-  case RISCV::SH:
-  case RISCV::SW:
-  case RISCV::SD:
-  case RISCV::FSW:
-  case RISCV::FSD: {
-    // Transforms the sequence:            Into:
-    // HiLUI:  lui vreg1, %hi(foo)          --->  lui vreg1, %hi(foo+8)
-    // LoADDI: addi vreg2, vreg1, %lo(foo)  --->  lw vreg3, lo(foo+8)(vreg1)
-    // Tail:   lw vreg3, 8(vreg2)
-    if (Tail.getOperand(1).isFI())
-      return false;
-    // Register defined by LoADDI should be used in the base part of the
-    // load\store instruction. Otherwise, no folding possible.
-    unsigned BaseAddrReg = Tail.getOperand(1).getReg();
-    if (DestReg != BaseAddrReg)
-      return false;
-    MachineOperand &TailImmOp = Tail.getOperand(2);
-    int64_t Offset = TailImmOp.getImm();
-    // Update the offsets in global address lowering.
-    HiLUI.getOperand(1).setOffset(Offset);
-    // Update the immediate in the Tail instruction to add the offset.
-    Tail.RemoveOperand(2);
-    MachineOperand &ImmOp = LoADDI.getOperand(2);
-    ImmOp.setOffset(Offset);
-    Tail.addOperand(ImmOp);
-    // Update the base reg in the Tail instruction to feed from LUI.
-    // Output of HiLUI is only used in LoADDI, no need to use
-    // MRI->replaceRegWith().
-    Tail.getOperand(1).setReg(HiLUI.getOperand(0).getReg());
-    DeadInstrs.insert(&LoADDI);
-    return true;
-  } break;
-  }
-  return false;
-}
-
-bool RISCVMergeBaseOffsetOpt::runOnMachineFunction(MachineFunction &Fn) {
-  if (skipFunction(Fn.getFunction()))
-    return false;
-
-  DeadInstrs.clear();
-  MRI = &Fn.getRegInfo();
-  for (MachineBasicBlock &MBB : Fn) {
-    LLVM_DEBUG(dbgs() << "MBB: " << MBB.getName() << "\n");
-    for (MachineInstr &HiLUI : MBB) {
-      MachineInstr *LoADDI = nullptr;
-      if (!detectLuiAddiGlobal(HiLUI, LoADDI))
-        continue;
-      LLVM_DEBUG(dbgs() << "  Found lowered global address with one use: "
-                        << *LoADDI->getOperand(2).getGlobal() << "\n");
-      // If the use count is only one, merge the offset
-      detectAndFoldOffset(HiLUI, *LoADDI);
-    }
-  }
-  // Delete dead instructions.
-  for (auto *MI : DeadInstrs)
-    MI->eraseFromParent();
-  return true;
-}
-
-/// Returns an instance of the Merge Base Offset Optimization pass.
-FunctionPass *llvm::createRISCVMergeBaseOffsetOptPass() {
-  return new RISCVMergeBaseOffsetOpt();
-}
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.cpp b/lib/Target/RISCV/RISCVRegisterInfo.cpp
deleted file mode 100644
index 3ed1dec434c..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ /dev/null
@@ -1,128 +0,0 @@
-//===-- RISCVRegisterInfo.cpp - RISCV Register Information ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetRegisterInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVRegisterInfo.h"
-#include "RISCV.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-#include "llvm/CodeGen/TargetFrameLowering.h"
-#include "llvm/CodeGen/TargetInstrInfo.h"
-#include "llvm/Support/ErrorHandling.h"
-
-#define GET_REGINFO_TARGET_DESC
-#include "RISCVGenRegisterInfo.inc"
-
-using namespace llvm;
-
-RISCVRegisterInfo::RISCVRegisterInfo(unsigned HwMode)
-    : RISCVGenRegisterInfo(RISCV::X1, /*DwarfFlavour*/0, /*EHFlavor*/0,
-                           /*PC*/0, HwMode) {}
-
-const MCPhysReg *
-RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
-  if (MF->getFunction().hasFnAttribute("interrupt")) {
-    if (MF->getSubtarget<RISCVSubtarget>().hasStdExtD())
-      return CSR_XLEN_F64_Interrupt_SaveList;
-    if (MF->getSubtarget<RISCVSubtarget>().hasStdExtF())
-      return CSR_XLEN_F32_Interrupt_SaveList;
-    return CSR_Interrupt_SaveList;
-  }
-  return CSR_SaveList;
-}
-
-BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
-  BitVector Reserved(getNumRegs());
-
-  // Use markSuperRegs to ensure any register aliases are also reserved
-  markSuperRegs(Reserved, RISCV::X0); // zero
-  markSuperRegs(Reserved, RISCV::X1); // ra
-  markSuperRegs(Reserved, RISCV::X2); // sp
-  markSuperRegs(Reserved, RISCV::X3); // gp
-  markSuperRegs(Reserved, RISCV::X4); // tp
-  markSuperRegs(Reserved, RISCV::X8); // fp
-  assert(checkAllSuperRegsMarked(Reserved));
-  return Reserved;
-}
-
-bool RISCVRegisterInfo::isConstantPhysReg(unsigned PhysReg) const {
-  return PhysReg == RISCV::X0;
-}
-
-const uint32_t *RISCVRegisterInfo::getNoPreservedMask() const {
-  return CSR_NoRegs_RegMask;
-}
-
-void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
-                                            int SPAdj, unsigned FIOperandNum,
-                                            RegScavenger *RS) const {
-  assert(SPAdj == 0 && "Unexpected non-zero SPAdj value");
-
-  MachineInstr &MI = *II;
-  MachineFunction &MF = *MI.getParent()->getParent();
-  MachineRegisterInfo &MRI = MF.getRegInfo();
-  const RISCVInstrInfo *TII = MF.getSubtarget<RISCVSubtarget>().getInstrInfo();
-  DebugLoc DL = MI.getDebugLoc();
-
-  int FrameIndex = MI.getOperand(FIOperandNum).getIndex();
-  unsigned FrameReg;
-  int Offset =
-      getFrameLowering(MF)->getFrameIndexReference(MF, FrameIndex, FrameReg) +
-      MI.getOperand(FIOperandNum + 1).getImm();
-
-  if (!isInt<32>(Offset)) {
-    report_fatal_error(
-        "Frame offsets outside of the signed 32-bit range not supported");
-  }
-
-  MachineBasicBlock &MBB = *MI.getParent();
-  bool FrameRegIsKill = false;
-
-  if (!isInt<12>(Offset)) {
-    assert(isInt<32>(Offset) && "Int32 expected");
-    // The offset won't fit in an immediate, so use a scratch register instead
-    // Modify Offset and FrameReg appropriately
-    unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-    TII->movImm32(MBB, II, DL, ScratchReg, Offset);
-    BuildMI(MBB, II, DL, TII->get(RISCV::ADD), ScratchReg)
-        .addReg(FrameReg)
-        .addReg(ScratchReg, RegState::Kill);
-    Offset = 0;
-    FrameReg = ScratchReg;
-    FrameRegIsKill = true;
-  }
-
-  MI.getOperand(FIOperandNum)
-      .ChangeToRegister(FrameReg, false, false, FrameRegIsKill);
-  MI.getOperand(FIOperandNum + 1).ChangeToImmediate(Offset);
-}
-
-unsigned RISCVRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
-  const TargetFrameLowering *TFI = getFrameLowering(MF);
-  return TFI->hasFP(MF) ? RISCV::X8 : RISCV::X2;
-}
-
-const uint32_t *
-RISCVRegisterInfo::getCallPreservedMask(const MachineFunction & MF,
-                                        CallingConv::ID /*CC*/) const {
-  if (MF.getFunction().hasFnAttribute("interrupt")) {
-    if (MF.getSubtarget<RISCVSubtarget>().hasStdExtD())
-      return CSR_XLEN_F64_Interrupt_RegMask;
-    if (MF.getSubtarget<RISCVSubtarget>().hasStdExtF())
-      return CSR_XLEN_F32_Interrupt_RegMask;
-    return CSR_Interrupt_RegMask;
-  }
-  return CSR_RegMask;
-}
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.h b/lib/Target/RISCV/RISCVRegisterInfo.h
deleted file mode 100644
index cbbb70079dd..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.h
+++ /dev/null
@@ -1,59 +0,0 @@
-//===-- RISCVRegisterInfo.h - RISCV Register Information Impl ---*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetRegisterInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVREGISTERINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVREGISTERINFO_H
-
-#include "llvm/CodeGen/TargetRegisterInfo.h"
-
-#define GET_REGINFO_HEADER
-#include "RISCVGenRegisterInfo.inc"
-
-namespace llvm {
-
-struct RISCVRegisterInfo : public RISCVGenRegisterInfo {
-
-  RISCVRegisterInfo(unsigned HwMode);
-
-  const uint32_t *getCallPreservedMask(const MachineFunction &MF,
-                                       CallingConv::ID) const override;
-
-  const MCPhysReg *getCalleeSavedRegs(const MachineFunction *MF) const override;
-
-  BitVector getReservedRegs(const MachineFunction &MF) const override;
-
-  bool isConstantPhysReg(unsigned PhysReg) const override;
-
-  const uint32_t *getNoPreservedMask() const override;
-
-  void eliminateFrameIndex(MachineBasicBlock::iterator MI, int SPAdj,
-                           unsigned FIOperandNum,
-                           RegScavenger *RS = nullptr) const override;
-
-  unsigned getFrameRegister(const MachineFunction &MF) const override;
-
-  bool requiresRegisterScavenging(const MachineFunction &MF) const override {
-    return true;
-  }
-
-  bool requiresFrameIndexScavenging(const MachineFunction &MF) const override {
-    return true;
-  }
-
-  bool trackLivenessAfterRegAlloc(const MachineFunction &) const override {
-    return true;
-  }
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.td b/lib/Target/RISCV/RISCVRegisterInfo.td
deleted file mode 100644
index 4be8ff9200e..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.td
+++ /dev/null
@@ -1,230 +0,0 @@
-//===-- RISCVRegisterInfo.td - RISC-V Register defs --------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-//  Declarations that describe the RISC-V register files
-//===----------------------------------------------------------------------===//
-
-let Namespace = "RISCV" in {
-class RISCVReg<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
-  let HWEncoding{4-0} = Enc;
-  let AltNames = alt;
-}
-
-class RISCVReg32<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
-  let HWEncoding{4-0} = Enc;
-  let AltNames = alt;
-}
-
-// Because RISCVReg64 register have AsmName and AltNames that alias with their
-// 32-bit sub-register, RISCVAsmParser will need to coerce a register number
-// from a RISCVReg32 to the equivalent RISCVReg64 when appropriate.
-def sub_32 : SubRegIndex<32>;
-class RISCVReg64<RISCVReg32 subreg> : Register<""> {
-  let HWEncoding{4-0} = subreg.HWEncoding{4-0};
-  let SubRegs = [subreg];
-  let SubRegIndices = [sub_32];
-  let AsmName = subreg.AsmName;
-  let AltNames = subreg.AltNames;
-}
-
-def ABIRegAltName : RegAltNameIndex;
-} // Namespace = "RISCV"
-
-// Integer registers
-// CostPerUse is set higher for registers that may not be compressible as they
-// are not part of GPRC, the most restrictive register class used by the
-// compressed instruction set. This will influence the greedy register
-// allocator to reduce the use of registers that can't be encoded in 16 bit
-// instructions. This affects register allocation even when compressed
-// instruction isn't targeted, we see no major negative codegen impact.
-
-let RegAltNameIndices = [ABIRegAltName] in {
-  def X0  : RISCVReg<0, "x0", ["zero"]>, DwarfRegNum<[0]>;
-  let CostPerUse = 1 in {
-  def X1  : RISCVReg<1, "x1", ["ra"]>, DwarfRegNum<[1]>;
-  def X2  : RISCVReg<2, "x2", ["sp"]>, DwarfRegNum<[2]>;
-  def X3  : RISCVReg<3, "x3", ["gp"]>, DwarfRegNum<[3]>;
-  def X4  : RISCVReg<4, "x4", ["tp"]>, DwarfRegNum<[4]>;
-  def X5  : RISCVReg<5, "x5", ["t0"]>, DwarfRegNum<[5]>;
-  def X6  : RISCVReg<6, "x6", ["t1"]>, DwarfRegNum<[6]>;
-  def X7  : RISCVReg<7, "x7", ["t2"]>, DwarfRegNum<[7]>;
-  }
-  def X8  : RISCVReg<8, "x8", ["s0"]>, DwarfRegNum<[8]>;
-  def X9  : RISCVReg<9, "x9", ["s1"]>, DwarfRegNum<[9]>;
-  def X10 : RISCVReg<10,"x10", ["a0"]>, DwarfRegNum<[10]>;
-  def X11 : RISCVReg<11,"x11", ["a1"]>, DwarfRegNum<[11]>;
-  def X12 : RISCVReg<12,"x12", ["a2"]>, DwarfRegNum<[12]>;
-  def X13 : RISCVReg<13,"x13", ["a3"]>, DwarfRegNum<[13]>;
-  def X14 : RISCVReg<14,"x14", ["a4"]>, DwarfRegNum<[14]>;
-  def X15 : RISCVReg<15,"x15", ["a5"]>, DwarfRegNum<[15]>;
-  let CostPerUse = 1 in {
-  def X16 : RISCVReg<16,"x16", ["a6"]>, DwarfRegNum<[16]>;
-  def X17 : RISCVReg<17,"x17", ["a7"]>, DwarfRegNum<[17]>;
-  def X18 : RISCVReg<18,"x18", ["s2"]>, DwarfRegNum<[18]>;
-  def X19 : RISCVReg<19,"x19", ["s3"]>, DwarfRegNum<[19]>;
-  def X20 : RISCVReg<20,"x20", ["s4"]>, DwarfRegNum<[20]>;
-  def X21 : RISCVReg<21,"x21", ["s5"]>, DwarfRegNum<[21]>;
-  def X22 : RISCVReg<22,"x22", ["s6"]>, DwarfRegNum<[22]>;
-  def X23 : RISCVReg<23,"x23", ["s7"]>, DwarfRegNum<[23]>;
-  def X24 : RISCVReg<24,"x24", ["s8"]>, DwarfRegNum<[24]>;
-  def X25 : RISCVReg<25,"x25", ["s9"]>, DwarfRegNum<[25]>;
-  def X26 : RISCVReg<26,"x26", ["s10"]>, DwarfRegNum<[26]>;
-  def X27 : RISCVReg<27,"x27", ["s11"]>, DwarfRegNum<[27]>;
-  def X28 : RISCVReg<28,"x28", ["t3"]>, DwarfRegNum<[28]>;
-  def X29 : RISCVReg<29,"x29", ["t4"]>, DwarfRegNum<[29]>;
-  def X30 : RISCVReg<30,"x30", ["t5"]>, DwarfRegNum<[30]>;
-  def X31 : RISCVReg<31,"x31", ["t6"]>, DwarfRegNum<[31]>;
-  }
-}
-
-def XLenVT : ValueTypeByHwMode<[RV32, RV64, DefaultMode],
-                               [i32,  i64,  i32]>;
-
-// The order of registers represents the preferred allocation sequence.
-// Registers are listed in the order caller-save, callee-save, specials.
-def GPR : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 0, 4)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-// The order of registers represents the preferred allocation sequence.
-// Registers are listed in the order caller-save, callee-save, specials.
-def GPRNoX0 : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 1, 4)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def GPRNoX0X2 : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    X1, X3, X4
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def GPRC : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 15),
-    (sequence "X%u", 8, 9)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-// For indirect tail calls, we can't use callee-saved registers, as they are
-// restored to the saved value before the tail call, which would clobber a call
-// address.
-def GPRTC : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 28, 31)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def SP : RegisterClass<"RISCV", [XLenVT], 32, (add X2)> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-// Floating point registers
-let RegAltNameIndices = [ABIRegAltName] in {
-  def F0_32  : RISCVReg32<0, "f0", ["ft0"]>, DwarfRegNum<[32]>;
-  def F1_32  : RISCVReg32<1, "f1", ["ft1"]>, DwarfRegNum<[33]>;
-  def F2_32  : RISCVReg32<2, "f2", ["ft2"]>, DwarfRegNum<[34]>;
-  def F3_32  : RISCVReg32<3, "f3", ["ft3"]>, DwarfRegNum<[35]>;
-  def F4_32  : RISCVReg32<4, "f4", ["ft4"]>, DwarfRegNum<[36]>;
-  def F5_32  : RISCVReg32<5, "f5", ["ft5"]>, DwarfRegNum<[37]>;
-  def F6_32  : RISCVReg32<6, "f6", ["ft6"]>, DwarfRegNum<[38]>;
-  def F7_32  : RISCVReg32<7, "f7", ["ft7"]>, DwarfRegNum<[39]>;
-  def F8_32  : RISCVReg32<8, "f8", ["fs0"]>, DwarfRegNum<[40]>;
-  def F9_32  : RISCVReg32<9, "f9", ["fs1"]>, DwarfRegNum<[41]>;
-  def F10_32 : RISCVReg32<10,"f10", ["fa0"]>, DwarfRegNum<[42]>;
-  def F11_32 : RISCVReg32<11,"f11", ["fa1"]>, DwarfRegNum<[43]>;
-  def F12_32 : RISCVReg32<12,"f12", ["fa2"]>, DwarfRegNum<[44]>;
-  def F13_32 : RISCVReg32<13,"f13", ["fa3"]>, DwarfRegNum<[45]>;
-  def F14_32 : RISCVReg32<14,"f14", ["fa4"]>, DwarfRegNum<[46]>;
-  def F15_32 : RISCVReg32<15,"f15", ["fa5"]>, DwarfRegNum<[47]>;
-  def F16_32 : RISCVReg32<16,"f16", ["fa6"]>, DwarfRegNum<[48]>;
-  def F17_32 : RISCVReg32<17,"f17", ["fa7"]>, DwarfRegNum<[49]>;
-  def F18_32 : RISCVReg32<18,"f18", ["fs2"]>, DwarfRegNum<[50]>;
-  def F19_32 : RISCVReg32<19,"f19", ["fs3"]>, DwarfRegNum<[51]>;
-  def F20_32 : RISCVReg32<20,"f20", ["fs4"]>, DwarfRegNum<[52]>;
-  def F21_32 : RISCVReg32<21,"f21", ["fs5"]>, DwarfRegNum<[53]>;
-  def F22_32 : RISCVReg32<22,"f22", ["fs6"]>, DwarfRegNum<[54]>;
-  def F23_32 : RISCVReg32<23,"f23", ["fs7"]>, DwarfRegNum<[55]>;
-  def F24_32 : RISCVReg32<24,"f24", ["fs8"]>, DwarfRegNum<[56]>;
-  def F25_32 : RISCVReg32<25,"f25", ["fs9"]>, DwarfRegNum<[57]>;
-  def F26_32 : RISCVReg32<26,"f26", ["fs10"]>, DwarfRegNum<[58]>;
-  def F27_32 : RISCVReg32<27,"f27", ["fs11"]>, DwarfRegNum<[59]>;
-  def F28_32 : RISCVReg32<28,"f28", ["ft8"]>, DwarfRegNum<[60]>;
-  def F29_32 : RISCVReg32<29,"f29", ["ft9"]>, DwarfRegNum<[61]>;
-  def F30_32 : RISCVReg32<30,"f30", ["ft10"]>, DwarfRegNum<[62]>;
-  def F31_32 : RISCVReg32<31,"f31", ["ft11"]>, DwarfRegNum<[63]>;
-
-  foreach Index = 0-31 in {
-    def F#Index#_64 : RISCVReg64<!cast<RISCVReg32>("F"#Index#"_32")>,
-      DwarfRegNum<[!add(Index, 32)]>;
-  }
-}
-
-// The order of registers represents the preferred allocation sequence,
-// meaning caller-save regs are listed before callee-save.
-def FPR32 : RegisterClass<"RISCV", [f32], 32, (add
-    (sequence "F%u_32", 0, 7),
-    (sequence "F%u_32", 10, 17),
-    (sequence "F%u_32", 28, 31),
-    (sequence "F%u_32", 8, 9),
-    (sequence "F%u_32", 18, 27)
-)>;
-
-def FPR32C : RegisterClass<"RISCV", [f32], 32, (add
-  (sequence "F%u_32", 10, 15),
-  (sequence "F%u_32", 8, 9)
-)>;
-
-// The order of registers represents the preferred allocation sequence,
-// meaning caller-save regs are listed before callee-save.
-def FPR64 : RegisterClass<"RISCV", [f64], 64, (add
-    (sequence "F%u_64", 0, 7),
-    (sequence "F%u_64", 10, 17),
-    (sequence "F%u_64", 28, 31),
-    (sequence "F%u_64", 8, 9),
-    (sequence "F%u_64", 18, 27)
-)>;
-
-def FPR64C : RegisterClass<"RISCV", [f64], 64, (add
-  (sequence "F%u_64", 10, 15),
-  (sequence "F%u_64", 8, 9)
-)>;
diff --git a/lib/Target/RISCV/RISCVSubtarget.cpp b/lib/Target/RISCV/RISCVSubtarget.cpp
deleted file mode 100644
index b221ea84a33..00000000000
--- a/lib/Target/RISCV/RISCVSubtarget.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//===-- RISCVSubtarget.cpp - RISCV Subtarget Information ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCV specific subclass of TargetSubtargetInfo.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVSubtarget.h"
-#include "RISCV.h"
-#include "RISCVFrameLowering.h"
-#include "llvm/Support/TargetRegistry.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-subtarget"
-
-#define GET_SUBTARGETINFO_TARGET_DESC
-#define GET_SUBTARGETINFO_CTOR
-#include "RISCVGenSubtargetInfo.inc"
-
-void RISCVSubtarget::anchor() {}
-
-RISCVSubtarget &RISCVSubtarget::initializeSubtargetDependencies(StringRef CPU,
-                                                                StringRef FS,
-                                                                bool Is64Bit) {
-  // Determine default and user-specified characteristics
-  std::string CPUName = CPU;
-  if (CPUName.empty())
-    CPUName = Is64Bit ? "generic-rv64" : "generic-rv32";
-  ParseSubtargetFeatures(CPUName, FS);
-  if (Is64Bit) {
-    XLenVT = MVT::i64;
-    XLen = 64;
-  }
-  return *this;
-}
-
-RISCVSubtarget::RISCVSubtarget(const Triple &TT, const std::string &CPU,
-                               const std::string &FS, const TargetMachine &TM)
-    : RISCVGenSubtargetInfo(TT, CPU, FS),
-      FrameLowering(initializeSubtargetDependencies(CPU, FS, TT.isArch64Bit())),
-      InstrInfo(), RegInfo(getHwMode()), TLInfo(TM, *this) {}
diff --git a/lib/Target/RISCV/RISCVSubtarget.h b/lib/Target/RISCV/RISCVSubtarget.h
deleted file mode 100644
index 0e09391e782..00000000000
--- a/lib/Target/RISCV/RISCVSubtarget.h
+++ /dev/null
@@ -1,87 +0,0 @@
-//===-- RISCVSubtarget.h - Define Subtarget for the RISCV -------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares the RISCV specific subclass of TargetSubtargetInfo.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVSUBTARGET_H
-#define LLVM_LIB_TARGET_RISCV_RISCVSUBTARGET_H
-
-#include "RISCVFrameLowering.h"
-#include "RISCVISelLowering.h"
-#include "RISCVInstrInfo.h"
-#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
-#include "llvm/CodeGen/TargetSubtargetInfo.h"
-#include "llvm/IR/DataLayout.h"
-#include "llvm/Target/TargetMachine.h"
-
-#define GET_SUBTARGETINFO_HEADER
-#include "RISCVGenSubtargetInfo.inc"
-
-namespace llvm {
-class StringRef;
-
-class RISCVSubtarget : public RISCVGenSubtargetInfo {
-  virtual void anchor();
-  bool HasStdExtM = false;
-  bool HasStdExtA = false;
-  bool HasStdExtF = false;
-  bool HasStdExtD = false;
-  bool HasStdExtC = false;
-  bool HasRV64 = false;
-  bool EnableLinkerRelax = false;
-  unsigned XLen = 32;
-  MVT XLenVT = MVT::i32;
-  RISCVFrameLowering FrameLowering;
-  RISCVInstrInfo InstrInfo;
-  RISCVRegisterInfo RegInfo;
-  RISCVTargetLowering TLInfo;
-  SelectionDAGTargetInfo TSInfo;
-
-  /// Initializes using the passed in CPU and feature strings so that we can
-  /// use initializer lists for subtarget initialization.
-  RISCVSubtarget &initializeSubtargetDependencies(StringRef CPU, StringRef FS,
-                                                  bool Is64Bit);
-
-public:
-  // Initializes the data members to match that of the specified triple.
-  RISCVSubtarget(const Triple &TT, const std::string &CPU,
-                 const std::string &FS, const TargetMachine &TM);
-
-  // Parses features string setting specified subtarget options. The
-  // definition of this function is auto-generated by tblgen.
-  void ParseSubtargetFeatures(StringRef CPU, StringRef FS);
-
-  const RISCVFrameLowering *getFrameLowering() const override {
-    return &FrameLowering;
-  }
-  const RISCVInstrInfo *getInstrInfo() const override { return &InstrInfo; }
-  const RISCVRegisterInfo *getRegisterInfo() const override {
-    return &RegInfo;
-  }
-  const RISCVTargetLowering *getTargetLowering() const override {
-    return &TLInfo;
-  }
-  const SelectionDAGTargetInfo *getSelectionDAGInfo() const override {
-    return &TSInfo;
-  }
-  bool hasStdExtM() const { return HasStdExtM; }
-  bool hasStdExtA() const { return HasStdExtA; }
-  bool hasStdExtF() const { return HasStdExtF; }
-  bool hasStdExtD() const { return HasStdExtD; }
-  bool hasStdExtC() const { return HasStdExtC; }
-  bool is64Bit() const { return HasRV64; }
-  bool enableLinkerRelax() const { return EnableLinkerRelax; }
-  MVT getXLenVT() const { return XLenVT; }
-  unsigned getXLen() const { return XLen; }
-};
-} // End llvm namespace
-
-#endif
diff --git a/lib/Target/RISCV/RISCVSystemOperands.td b/lib/Target/RISCV/RISCVSystemOperands.td
deleted file mode 100644
index f1b7984ffe6..00000000000
--- a/lib/Target/RISCV/RISCVSystemOperands.td
+++ /dev/null
@@ -1,352 +0,0 @@
-//===- RISCVSystemOperands.td ----------------------------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the symbolic operands permitted for various kinds of
-// RISC-V system instruction.
-//
-//===----------------------------------------------------------------------===//
-
-include "llvm/TableGen/SearchableTable.td"
-
-//===----------------------------------------------------------------------===//
-// CSR (control and status register read/write) instruction options.
-//===----------------------------------------------------------------------===//
-
-class SysReg<string name, bits<12> op> {
-  string Name = name;
-  bits<12> Encoding = op;
-  // FIXME: add these additional fields when needed.
-  // Privilege Access: Read and Write = 0, 1, 2; Read-Only = 3.
-  // Privilege Mode: User = 0, System = 1 or Machine = 3.
-  // bits<2> ReadWrite = op{11 - 10};
-  // bits<2> XMode = op{9 - 8};
-  // Check Extra field name and what bits 7-6 correspond to.
-  // bits<2> Extra = op{7 - 6};
-  // Register number without the privilege bits.
-  // bits<6> Number = op{5 - 0};
-  code FeaturesRequired = [{ {} }];
-  bit isRV32Only = 0;
-}
-
-def SysRegsList : GenericTable {
-  let FilterClass = "SysReg";
-  // FIXME: add "ReadWrite", "Mode", "Extra", "Number" fields when needed.
-  let Fields = [ "Name", "Encoding", "FeaturesRequired", "isRV32Only" ];
-
-  let PrimaryKey = [ "Encoding" ];
-  let PrimaryKeyName = "lookupSysRegByEncoding";
-}
-
-def lookupSysRegByName : SearchIndex {
-  let Table = SysRegsList;
-  let Key = [ "Name" ];
-}
-
-// The following CSR encodings match those given in Tables 2.2,
-// 2.3, 2.4 and  2.5 in the RISC-V Instruction Set Manual
-// Volume II: Privileged Architecture.
-
-//===--------------------------
-// User Trap Setup
-//===--------------------------
-def : SysReg<"ustatus", 0x000>;
-def : SysReg<"uie", 0x004>;
-def : SysReg<"utvec", 0x005>;
-
-//===--------------------------
-// User Trap Handling
-//===--------------------------
-def : SysReg<"uscratch", 0x040>;
-def : SysReg<"uepc", 0x041>;
-def : SysReg<"ucause", 0x042>;
-def : SysReg<"utval", 0x043>;
-def : SysReg<"uip", 0x044>;
-
-//===--------------------------
-// User Floating-Point CSRs
-//===--------------------------
-
-let FeaturesRequired = [{ {RISCV::FeatureStdExtF} }] in {
-def : SysReg<"fflags", 0x001>;
-def : SysReg<"frm", 0x002>;
-def : SysReg<"fcsr", 0x003>;
-}
-
-//===--------------------------
-// User Counter/Timers
-//===--------------------------
-def : SysReg<"cycle", 0xC00>;
-def : SysReg<"time", 0xC01>;
-def : SysReg<"instret", 0xC02>;
-
-def : SysReg<"hpmcounter3", 0xC03>;
-def : SysReg<"hpmcounter4", 0xC04>;
-def : SysReg<"hpmcounter5", 0xC05>;
-def : SysReg<"hpmcounter6", 0xC06>;
-def : SysReg<"hpmcounter7", 0xC07>;
-def : SysReg<"hpmcounter8", 0xC08>;
-def : SysReg<"hpmcounter9", 0xC09>;
-def : SysReg<"hpmcounter10", 0xC0A>;
-def : SysReg<"hpmcounter11", 0xC0B>;
-def : SysReg<"hpmcounter12", 0xC0C>;
-def : SysReg<"hpmcounter13", 0xC0D>;
-def : SysReg<"hpmcounter14", 0xC0E>;
-def : SysReg<"hpmcounter15", 0xC0F>;
-def : SysReg<"hpmcounter16", 0xC10>;
-def : SysReg<"hpmcounter17", 0xC11>;
-def : SysReg<"hpmcounter18", 0xC12>;
-def : SysReg<"hpmcounter19", 0xC13>;
-def : SysReg<"hpmcounter20", 0xC14>;
-def : SysReg<"hpmcounter21", 0xC15>;
-def : SysReg<"hpmcounter22", 0xC16>;
-def : SysReg<"hpmcounter23", 0xC17>;
-def : SysReg<"hpmcounter24", 0xC18>;
-def : SysReg<"hpmcounter25", 0xC19>;
-def : SysReg<"hpmcounter26", 0xC1A>;
-def : SysReg<"hpmcounter27", 0xC1B>;
-def : SysReg<"hpmcounter28", 0xC1C>;
-def : SysReg<"hpmcounter29", 0xC1D>;
-def : SysReg<"hpmcounter30", 0xC1E>;
-def : SysReg<"hpmcounter31", 0xC1F>;
-
-let isRV32Only = 1 in {
-def: SysReg<"cycleh", 0xC80>;
-def: SysReg<"timeh", 0xC81>;
-def: SysReg<"instreth", 0xC82>;
-
-def: SysReg<"hpmcounter3h", 0xC83>;
-def: SysReg<"hpmcounter4h", 0xC84>;
-def: SysReg<"hpmcounter5h", 0xC85>;
-def: SysReg<"hpmcounter6h", 0xC86>;
-def: SysReg<"hpmcounter7h", 0xC87>;
-def: SysReg<"hpmcounter8h", 0xC88>;
-def: SysReg<"hpmcounter9h", 0xC89>;
-def: SysReg<"hpmcounter10h", 0xC8A>;
-def: SysReg<"hpmcounter11h", 0xC8B>;
-def: SysReg<"hpmcounter12h", 0xC8C>;
-def: SysReg<"hpmcounter13h", 0xC8D>;
-def: SysReg<"hpmcounter14h", 0xC8E>;
-def: SysReg<"hpmcounter15h", 0xC8F>;
-def: SysReg<"hpmcounter16h", 0xC90>;
-def: SysReg<"hpmcounter17h", 0xC91>;
-def: SysReg<"hpmcounter18h", 0xC92>;
-def: SysReg<"hpmcounter19h", 0xC93>;
-def: SysReg<"hpmcounter20h", 0xC94>;
-def: SysReg<"hpmcounter21h", 0xC95>;
-def: SysReg<"hpmcounter22h", 0xC96>;
-def: SysReg<"hpmcounter23h", 0xC97>;
-def: SysReg<"hpmcounter24h", 0xC98>;
-def: SysReg<"hpmcounter25h", 0xC99>;
-def: SysReg<"hpmcounter26h", 0xC9A>;
-def: SysReg<"hpmcounter27h", 0xC9B>;
-def: SysReg<"hpmcounter28h", 0xC9C>;
-def: SysReg<"hpmcounter29h", 0xC9D>;
-def: SysReg<"hpmcounter30h", 0xC9E>;
-def: SysReg<"hpmcounter31h", 0xC9F>;
-}
-
-//===--------------------------
-// Supervisor Trap Setup
-//===--------------------------
-def : SysReg<"sstatus", 0x100>;
-def : SysReg<"sedeleg", 0x102>;
-def : SysReg<"sideleg", 0x103>;
-def : SysReg<"sie", 0x104>;
-def : SysReg<"stvec", 0x105>;
-def : SysReg<"scounteren", 0x106>;
-
-//===--------------------------
-// Supervisor Trap Handling
-//===--------------------------
-def : SysReg<"sscratch", 0x140>;
-def : SysReg<"sepc", 0x141>;
-def : SysReg<"scause", 0x142>;
-def : SysReg<"stval", 0x143>;
-def : SysReg<"sip", 0x144>;
-
-//===-------------------------------------
-// Supervisor Protection and Translation
-//===-------------------------------------
-def : SysReg<"satp", 0x180>;
-
-//===-----------------------------
-// Machine Information Registers
-//===-----------------------------
-
-def : SysReg<"mvendorid", 0xF11>;
-def : SysReg<"marchid", 0xF12>;
-def : SysReg<"mimpid", 0xF13>;
-def : SysReg<"mhartid", 0xF14>;
-
-//===-----------------------------
-// Machine Trap Setup
-//===-----------------------------
-def : SysReg<"mstatus", 0x300>;
-def : SysReg<"misa", 0x301>;
-def : SysReg<"medeleg", 0x302>;
-def : SysReg<"mideleg", 0x303>;
-def : SysReg<"mie", 0x304>;
-def : SysReg<"mtvec", 0x305>;
-def : SysReg<"mcounteren", 0x306>;
-
-//===-----------------------------
-// Machine Trap Handling
-//===-----------------------------
-def : SysReg<"mscratch", 0x340>;
-def : SysReg<"mepc", 0x341>;
-def : SysReg<"mcause", 0x342>;
-def : SysReg<"mtval", 0x343>;
-def : SysReg<"mip", 0x344>;
-
-//===----------------------------------
-// Machine Protection and Translation
-//===----------------------------------
-def : SysReg<"pmpcfg0", 0x3A0>;
-def : SysReg<"pmpcfg2", 0x3A2>;
-let isRV32Only = 1 in {
-def : SysReg<"pmpcfg1", 0x3A1>;
-def : SysReg<"pmpcfg3", 0x3A3>;
-}
-
-def : SysReg<"pmpaddr0", 0x3B0>;
-def : SysReg<"pmpaddr1", 0x3B1>;
-def : SysReg<"pmpaddr2", 0x3B2>;
-def : SysReg<"pmpaddr3", 0x3B3>;
-def : SysReg<"pmpaddr4", 0x3B4>;
-def : SysReg<"pmpaddr5", 0x3B5>;
-def : SysReg<"pmpaddr6", 0x3B6>;
-def : SysReg<"pmpaddr7", 0x3B7>;
-def : SysReg<"pmpaddr8", 0x3B8>;
-def : SysReg<"pmpaddr9", 0x3B9>;
-def : SysReg<"pmpaddr10", 0x3BA>;
-def : SysReg<"pmpaddr11", 0x3BB>;
-def : SysReg<"pmpaddr12", 0x3BC>;
-def : SysReg<"pmpaddr13", 0x3BD>;
-def : SysReg<"pmpaddr14", 0x3BE>;
-def : SysReg<"pmpaddr15", 0x3BF>;
-
-
-//===--------------------------
-// Machine Counter and Timers
-//===--------------------------
-def : SysReg<"mcycle", 0xB00>;
-def : SysReg<"minstret", 0xB02>;
-
-def : SysReg<"mhpmcounter3", 0xB03>;
-def : SysReg<"mhpmcounter4", 0xB04>;
-def : SysReg<"mhpmcounter5", 0xB05>;
-def : SysReg<"mhpmcounter6", 0xB06>;
-def : SysReg<"mhpmcounter7", 0xB07>;
-def : SysReg<"mhpmcounter8", 0xB08>;
-def : SysReg<"mhpmcounter9", 0xB09>;
-def : SysReg<"mhpmcounter10", 0xB0A>;
-def : SysReg<"mhpmcounter11", 0xB0B>;
-def : SysReg<"mhpmcounter12", 0xB0C>;
-def : SysReg<"mhpmcounter13", 0xB0D>;
-def : SysReg<"mhpmcounter14", 0xB0E>;
-def : SysReg<"mhpmcounter15", 0xB0F>;
-def : SysReg<"mhpmcounter16", 0xB10>;
-def : SysReg<"mhpmcounter17", 0xB11>;
-def : SysReg<"mhpmcounter18", 0xB12>;
-def : SysReg<"mhpmcounter19", 0xB13>;
-def : SysReg<"mhpmcounter20", 0xB14>;
-def : SysReg<"mhpmcounter21", 0xB15>;
-def : SysReg<"mhpmcounter22", 0xB16>;
-def : SysReg<"mhpmcounter23", 0xB17>;
-def : SysReg<"mhpmcounter24", 0xB18>;
-def : SysReg<"mhpmcounter25", 0xB19>;
-def : SysReg<"mhpmcounter26", 0xB1A>;
-def : SysReg<"mhpmcounter27", 0xB1B>;
-def : SysReg<"mhpmcounter28", 0xB1C>;
-def : SysReg<"mhpmcounter29", 0xB1D>;
-def : SysReg<"mhpmcounter30", 0xB1E>;
-def : SysReg<"mhpmcounter31", 0xB1F>;
-
-let isRV32Only = 1 in {
-def: SysReg<"mcycleh", 0xB80>;
-def: SysReg<"minstreth", 0xB82>;
-
-def: SysReg<"mhpmcounter3h", 0xB83>;
-def: SysReg<"mhpmcounter4h", 0xB84>;
-def: SysReg<"mhpmcounter5h", 0xB85>;
-def: SysReg<"mhpmcounter6h", 0xB86>;
-def: SysReg<"mhpmcounter7h", 0xB87>;
-def: SysReg<"mhpmcounter8h", 0xB88>;
-def: SysReg<"mhpmcounter9h", 0xB89>;
-def: SysReg<"mhpmcounter10h", 0xB8A>;
-def: SysReg<"mhpmcounter11h", 0xB8B>;
-def: SysReg<"mhpmcounter12h", 0xB8C>;
-def: SysReg<"mhpmcounter13h", 0xB8D>;
-def: SysReg<"mhpmcounter14h", 0xB8E>;
-def: SysReg<"mhpmcounter15h", 0xB8F>;
-def: SysReg<"mhpmcounter16h", 0xB90>;
-def: SysReg<"mhpmcounter17h", 0xB91>;
-def: SysReg<"mhpmcounter18h", 0xB92>;
-def: SysReg<"mhpmcounter19h", 0xB93>;
-def: SysReg<"mhpmcounter20h", 0xB94>;
-def: SysReg<"mhpmcounter21h", 0xB95>;
-def: SysReg<"mhpmcounter22h", 0xB96>;
-def: SysReg<"mhpmcounter23h", 0xB97>;
-def: SysReg<"mhpmcounter24h", 0xB98>;
-def: SysReg<"mhpmcounter25h", 0xB99>;
-def: SysReg<"mhpmcounter26h", 0xB9A>;
-def: SysReg<"mhpmcounter27h", 0xB9B>;
-def: SysReg<"mhpmcounter28h", 0xB9C>;
-def: SysReg<"mhpmcounter29h", 0xB9D>;
-def: SysReg<"mhpmcounter30h", 0xB9E>;
-def: SysReg<"mhpmcounter31h", 0xB9F>;
-}
-
-//===--------------------------
-// Machine Counter Setup
-//===--------------------------
-def : SysReg<"mhpmevent3", 0x323>;
-def : SysReg<"mhpmevent4", 0x324>;
-def : SysReg<"mhpmevent5", 0x325>;
-def : SysReg<"mhpmevent6", 0x326>;
-def : SysReg<"mhpmevent7", 0x327>;
-def : SysReg<"mhpmevent8", 0x328>;
-def : SysReg<"mhpmevent9", 0x329>;
-def : SysReg<"mhpmevent10", 0x32A>;
-def : SysReg<"mhpmevent11", 0x32B>;
-def : SysReg<"mhpmevent12", 0x32C>;
-def : SysReg<"mhpmevent13", 0x32D>;
-def : SysReg<"mhpmevent14", 0x32E>;
-def : SysReg<"mhpmevent15", 0x32F>;
-def : SysReg<"mhpmevent16", 0x330>;
-def : SysReg<"mhpmevent17", 0x331>;
-def : SysReg<"mhpmevent18", 0x332>;
-def : SysReg<"mhpmevent19", 0x333>;
-def : SysReg<"mhpmevent20", 0x334>;
-def : SysReg<"mhpmevent21", 0x335>;
-def : SysReg<"mhpmevent22", 0x336>;
-def : SysReg<"mhpmevent23", 0x337>;
-def : SysReg<"mhpmevent24", 0x338>;
-def : SysReg<"mhpmevent25", 0x339>;
-def : SysReg<"mhpmevent26", 0x33A>;
-def : SysReg<"mhpmevent27", 0x33B>;
-def : SysReg<"mhpmevent28", 0x33C>;
-def : SysReg<"mhpmevent29", 0x33D>;
-def : SysReg<"mhpmevent30", 0x33E>;
-def : SysReg<"mhpmevent31", 0x33F>;
-
-//===-----------------------------------------------
-// Debug/ Trace Registers (shared with Debug Mode)
-//===-----------------------------------------------
-def : SysReg<"tselect", 0x7A0>;
-def : SysReg<"tdata1", 0x7A1>;
-def : SysReg<"tdata2", 0x7A2>;
-def : SysReg<"tdata3", 0x7A3>;
-
-//===-----------------------------------------------
-// Debug Mode Registers
-//===-----------------------------------------------
-def : SysReg<"dcsr", 0x7B0>;
-def : SysReg<"dpc", 0x7B1>;
-def : SysReg<"dscratch", 0x7B2>;
diff --git a/lib/Target/RISCV/RISCVTargetMachine.cpp b/lib/Target/RISCV/RISCVTargetMachine.cpp
deleted file mode 100644
index 8937ec200bd..00000000000
--- a/lib/Target/RISCV/RISCVTargetMachine.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-//===-- RISCVTargetMachine.cpp - Define TargetMachine for RISCV -----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Implements the info about RISCV target spec.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "RISCVTargetMachine.h"
-#include "RISCVTargetObjectFile.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/CodeGen/Passes.h"
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
-#include "llvm/CodeGen/TargetPassConfig.h"
-#include "llvm/IR/LegacyPassManager.h"
-#include "llvm/Support/FormattedStream.h"
-#include "llvm/Support/TargetRegistry.h"
-#include "llvm/Target/TargetOptions.h"
-using namespace llvm;
-
-extern "C" void LLVMInitializeRISCVTarget() {
-  RegisterTargetMachine<RISCVTargetMachine> X(getTheRISCV32Target());
-  RegisterTargetMachine<RISCVTargetMachine> Y(getTheRISCV64Target());
-  auto PR = PassRegistry::getPassRegistry();
-  initializeRISCVExpandPseudoPass(*PR);
-}
-
-static std::string computeDataLayout(const Triple &TT) {
-  if (TT.isArch64Bit()) {
-    return "e-m:e-p:64:64-i64:64-i128:128-n64-S128";
-  } else {
-    assert(TT.isArch32Bit() && "only RV32 and RV64 are currently supported");
-    return "e-m:e-p:32:32-i64:64-n32-S128";
-  }
-}
-
-static Reloc::Model getEffectiveRelocModel(const Triple &TT,
-                                           Optional<Reloc::Model> RM) {
-  if (!RM.hasValue())
-    return Reloc::Static;
-  return *RM;
-}
-
-RISCVTargetMachine::RISCVTargetMachine(const Target &T, const Triple &TT,
-                                       StringRef CPU, StringRef FS,
-                                       const TargetOptions &Options,
-                                       Optional<Reloc::Model> RM,
-                                       Optional<CodeModel::Model> CM,
-                                       CodeGenOpt::Level OL, bool JIT)
-    : LLVMTargetMachine(T, computeDataLayout(TT), TT, CPU, FS, Options,
-                        getEffectiveRelocModel(TT, RM),
-                        getEffectiveCodeModel(CM, CodeModel::Small), OL),
-      TLOF(make_unique<RISCVELFTargetObjectFile>()),
-      Subtarget(TT, CPU, FS, *this) {
-  initAsmInfo();
-}
-
-namespace {
-class RISCVPassConfig : public TargetPassConfig {
-public:
-  RISCVPassConfig(RISCVTargetMachine &TM, PassManagerBase &PM)
-      : TargetPassConfig(TM, PM) {}
-
-  RISCVTargetMachine &getRISCVTargetMachine() const {
-    return getTM<RISCVTargetMachine>();
-  }
-
-  void addIRPasses() override;
-  bool addInstSelector() override;
-  void addPreEmitPass() override;
-  void addPreEmitPass2() override;
-  void addPreRegAlloc() override;
-};
-}
-
-TargetPassConfig *RISCVTargetMachine::createPassConfig(PassManagerBase &PM) {
-  return new RISCVPassConfig(*this, PM);
-}
-
-void RISCVPassConfig::addIRPasses() {
-  addPass(createAtomicExpandPass());
-  TargetPassConfig::addIRPasses();
-}
-
-bool RISCVPassConfig::addInstSelector() {
-  addPass(createRISCVISelDag(getRISCVTargetMachine()));
-
-  return false;
-}
-
-void RISCVPassConfig::addPreEmitPass() { addPass(&BranchRelaxationPassID); }
-
-void RISCVPassConfig::addPreEmitPass2() {
-  // Schedule the expansion of AMOs at the last possible moment, avoiding the
-  // possibility for other passes to break the requirements for forward
-  // progress in the LR/SC block.
-  addPass(createRISCVExpandPseudoPass());
-}
-
-void RISCVPassConfig::addPreRegAlloc() {
-  addPass(createRISCVMergeBaseOffsetOptPass());
-}
diff --git a/lib/Target/RISCV/RISCVTargetMachine.h b/lib/Target/RISCV/RISCVTargetMachine.h
deleted file mode 100644
index 02361dddebf..00000000000
--- a/lib/Target/RISCV/RISCVTargetMachine.h
+++ /dev/null
@@ -1,46 +0,0 @@
-//===-- RISCVTargetMachine.h - Define TargetMachine for RISCV ---*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares the RISCV specific subclass of TargetMachine.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVTARGETMACHINE_H
-#define LLVM_LIB_TARGET_RISCV_RISCVTARGETMACHINE_H
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
-#include "llvm/IR/DataLayout.h"
-#include "llvm/Target/TargetMachine.h"
-
-namespace llvm {
-class RISCVTargetMachine : public LLVMTargetMachine {
-  std::unique_ptr<TargetLoweringObjectFile> TLOF;
-  RISCVSubtarget Subtarget;
-
-public:
-  RISCVTargetMachine(const Target &T, const Triple &TT, StringRef CPU,
-                     StringRef FS, const TargetOptions &Options,
-                     Optional<Reloc::Model> RM, Optional<CodeModel::Model> CM,
-                     CodeGenOpt::Level OL, bool JIT);
-
-  const RISCVSubtarget *getSubtargetImpl(const Function &) const override {
-    return &Subtarget;
-  }
-
-  TargetPassConfig *createPassConfig(PassManagerBase &PM) override;
-
-  TargetLoweringObjectFile *getObjFileLowering() const override {
-    return TLOF.get();
-  }
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCVTargetObjectFile.cpp b/lib/Target/RISCV/RISCVTargetObjectFile.cpp
deleted file mode 100644
index 46e81b628b6..00000000000
--- a/lib/Target/RISCV/RISCVTargetObjectFile.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//===-- RISCVTargetObjectFile.cpp - RISCV Object Info -----------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVTargetObjectFile.h"
-#include "RISCVTargetMachine.h"
-
-using namespace llvm;
-
-void RISCVELFTargetObjectFile::Initialize(MCContext &Ctx,
-                                          const TargetMachine &TM) {
-  TargetLoweringObjectFileELF::Initialize(Ctx, TM);
-  InitializeELF(TM.Options.UseInitArray);
-}
diff --git a/lib/Target/RISCV/RISCVTargetObjectFile.h b/lib/Target/RISCV/RISCVTargetObjectFile.h
deleted file mode 100644
index 5467220301c..00000000000
--- a/lib/Target/RISCV/RISCVTargetObjectFile.h
+++ /dev/null
@@ -1,25 +0,0 @@
-//===-- RISCVTargetObjectFile.h - RISCV Object Info -*- C++ ---------*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVTARGETOBJECTFILE_H
-#define LLVM_LIB_TARGET_RISCV_RISCVTARGETOBJECTFILE_H
-
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
-
-namespace llvm {
-class RISCVTargetMachine;
-
-/// This implementation is used for RISCV ELF targets.
-class RISCVELFTargetObjectFile : public TargetLoweringObjectFileELF {
-  void Initialize(MCContext &Ctx, const TargetMachine &TM) override;
-};
-
-} // end namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/TargetInfo/CMakeLists.txt b/lib/Target/RISCV/TargetInfo/CMakeLists.txt
deleted file mode 100644
index f440fe2cb82..00000000000
--- a/lib/Target/RISCV/TargetInfo/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVInfo
-  RISCVTargetInfo.cpp
-  )
diff --git a/lib/Target/RISCV/TargetInfo/LLVMBuild.txt b/lib/Target/RISCV/TargetInfo/LLVMBuild.txt
deleted file mode 100644
index db7f66f94bf..00000000000
--- a/lib/Target/RISCV/TargetInfo/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/TargetInfo/LLVMBuild.txt --------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVInfo
-parent = RISCV
-required_libraries = Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp b/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
deleted file mode 100644
index 0f369d960fe..00000000000
--- a/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-//===-- RISCVTargetInfo.cpp - RISCV Target Implementation -----------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "llvm/Support/TargetRegistry.h"
-using namespace llvm;
-
-namespace llvm {
-Target &getTheRISCV32Target() {
-  static Target TheRISCV32Target;
-  return TheRISCV32Target;
-}
-
-Target &getTheRISCV64Target() {
-  static Target TheRISCV64Target;
-  return TheRISCV64Target;
-}
-}
-
-extern "C" void LLVMInitializeRISCVTargetInfo() {
-  RegisterTarget<Triple::riscv32> X(getTheRISCV32Target(), "riscv32",
-                                    "32-bit RISC-V", "RISCV");
-  RegisterTarget<Triple::riscv64> Y(getTheRISCV64Target(), "riscv64",
-                                    "64-bit RISC-V", "RISCV");
-}
diff --git a/lib/Target/RISCV/Utils/CMakeLists.txt b/lib/Target/RISCV/Utils/CMakeLists.txt
deleted file mode 100644
index 727ab4a9fd7..00000000000
--- a/lib/Target/RISCV/Utils/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-add_llvm_library(LLVMRISCVUtils
-  RISCVBaseInfo.cpp
-  RISCVMatInt.cpp
-  )
diff --git a/lib/Target/RISCV/Utils/LLVMBuild.txt b/lib/Target/RISCV/Utils/LLVMBuild.txt
deleted file mode 100644
index ec75b930366..00000000000
--- a/lib/Target/RISCV/Utils/LLVMBuild.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-;===- ./lib/Target/RISCV/Utils/LLVMBuild.txt ----------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVUtils
-parent = RISCV
-required_libraries = Support
-add_to_library_groups = RISCV
-
diff --git a/lib/Target/RISCV/Utils/RISCVBaseInfo.cpp b/lib/Target/RISCV/Utils/RISCVBaseInfo.cpp
deleted file mode 100644
index 964af1f74ce..00000000000
--- a/lib/Target/RISCV/Utils/RISCVBaseInfo.cpp
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "RISCVBaseInfo.h"
-#include "llvm/ADT/ArrayRef.h"
-
-namespace llvm {
-namespace RISCVSysReg {
-#define GET_SysRegsList_IMPL
-#include "RISCVGenSystemOperands.inc"
-} // namespace RISCVSysReg
-} // namespace llvm
diff --git a/lib/Target/RISCV/Utils/RISCVBaseInfo.h b/lib/Target/RISCV/Utils/RISCVBaseInfo.h
deleted file mode 100644
index 372e0e80bba..00000000000
--- a/lib/Target/RISCV/Utils/RISCVBaseInfo.h
+++ /dev/null
@@ -1,158 +0,0 @@
-//===-- RISCVBaseInfo.h - Top level definitions for RISCV MC ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains small standalone enum definitions for the RISCV target
-// useful for the compiler back-end and the MC libraries.
-//
-//===----------------------------------------------------------------------===//
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVBASEINFO_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVBASEINFO_H
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/StringSwitch.h"
-#include "llvm/MC/SubtargetFeature.h"
-
-namespace llvm {
-
-// RISCVII - This namespace holds all of the target specific flags that
-// instruction info tracks. All definitions must match RISCVInstrFormats.td.
-namespace RISCVII {
-enum {
-  InstFormatPseudo = 0,
-  InstFormatR = 1,
-  InstFormatR4 = 2,
-  InstFormatI = 3,
-  InstFormatS = 4,
-  InstFormatB = 5,
-  InstFormatU = 6,
-  InstFormatJ = 7,
-  InstFormatCR = 8,
-  InstFormatCI = 9,
-  InstFormatCSS = 10,
-  InstFormatCIW = 11,
-  InstFormatCL = 12,
-  InstFormatCS = 13,
-  InstFormatCA = 14,
-  InstFormatCB = 15,
-  InstFormatCJ = 16,
-  InstFormatOther = 17,
-
-  InstFormatMask = 31
-};
-
-enum {
-  MO_None,
-  MO_LO,
-  MO_HI,
-  MO_PCREL_HI,
-};
-} // namespace RISCVII
-
-// Describes the predecessor/successor bits used in the FENCE instruction.
-namespace RISCVFenceField {
-enum FenceField {
-  I = 8,
-  O = 4,
-  R = 2,
-  W = 1
-};
-}
-
-// Describes the supported floating point rounding mode encodings.
-namespace RISCVFPRndMode {
-enum RoundingMode {
-  RNE = 0,
-  RTZ = 1,
-  RDN = 2,
-  RUP = 3,
-  RMM = 4,
-  DYN = 7,
-  Invalid
-};
-
-inline static StringRef roundingModeToString(RoundingMode RndMode) {
-  switch (RndMode) {
-  default:
-    llvm_unreachable("Unknown floating point rounding mode");
-  case RISCVFPRndMode::RNE:
-    return "rne";
-  case RISCVFPRndMode::RTZ:
-    return "rtz";
-  case RISCVFPRndMode::RDN:
-    return "rdn";
-  case RISCVFPRndMode::RUP:
-    return "rup";
-  case RISCVFPRndMode::RMM:
-    return "rmm";
-  case RISCVFPRndMode::DYN:
-    return "dyn";
-  }
-}
-
-inline static RoundingMode stringToRoundingMode(StringRef Str) {
-  return StringSwitch<RoundingMode>(Str)
-      .Case("rne", RISCVFPRndMode::RNE)
-      .Case("rtz", RISCVFPRndMode::RTZ)
-      .Case("rdn", RISCVFPRndMode::RDN)
-      .Case("rup", RISCVFPRndMode::RUP)
-      .Case("rmm", RISCVFPRndMode::RMM)
-      .Case("dyn", RISCVFPRndMode::DYN)
-      .Default(RISCVFPRndMode::Invalid);
-}
-
-inline static bool isValidRoundingMode(unsigned Mode) {
-  switch (Mode) {
-  default:
-    return false;
-  case RISCVFPRndMode::RNE:
-  case RISCVFPRndMode::RTZ:
-  case RISCVFPRndMode::RDN:
-  case RISCVFPRndMode::RUP:
-  case RISCVFPRndMode::RMM:
-  case RISCVFPRndMode::DYN:
-    return true;
-  }
-}
-} // namespace RISCVFPRndMode
-
-namespace RISCVSysReg {
-struct SysReg {
-  const char *Name;
-  unsigned Encoding;
-  // FIXME: add these additional fields when needed.
-  // Privilege Access: Read, Write, Read-Only.
-  // unsigned ReadWrite;
-  // Privilege Mode: User, System or Machine.
-  // unsigned Mode;
-  // Check field name.
-  // unsigned Extra;
-  // Register number without the privilege bits.
-  // unsigned Number;
-  FeatureBitset FeaturesRequired;
-  bool isRV32Only;
-
-  bool haveRequiredFeatures(FeatureBitset ActiveFeatures) const {
-    // Not in 32-bit mode.
-    if (isRV32Only && ActiveFeatures[RISCV::Feature64Bit])
-      return false;
-    // No required feature associated with the system register.
-    if (FeaturesRequired.none())
-      return true;
-    return (FeaturesRequired & ActiveFeatures) == FeaturesRequired;
-  }
-};
-
-#define GET_SysRegsList_DECL
-#include "RISCVGenSystemOperands.inc"
-} // end namespace RISCVSysReg
-
-} // namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/Utils/RISCVMatInt.cpp b/lib/Target/RISCV/Utils/RISCVMatInt.cpp
deleted file mode 100644
index 3dc298246bc..00000000000
--- a/lib/Target/RISCV/Utils/RISCVMatInt.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//===- RISCVMatInt.cpp - Immediate materialisation -------------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMatInt.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/Support/MachineValueType.h"
-#include "llvm/Support/MathExtras.h"
-#include <cstdint>
-
-namespace llvm {
-
-namespace RISCVMatInt {
-void generateInstSeq(int64_t Val, bool Is64Bit, InstSeq &Res) {
-  if (isInt<32>(Val)) {
-    // Depending on the active bits in the immediate Value v, the following
-    // instruction sequences are emitted:
-    //
-    // v == 0                        : ADDI
-    // v[0,12) != 0 && v[12,32) == 0 : ADDI
-    // v[0,12) == 0 && v[12,32) != 0 : LUI
-    // v[0,32) != 0                  : LUI+ADDI(W)
-    int64_t Hi20 = ((Val + 0x800) >> 12) & 0xFFFFF;
-    int64_t Lo12 = SignExtend64<12>(Val);
-
-    if (Hi20)
-      Res.push_back(Inst(RISCV::LUI, Hi20));
-
-    if (Lo12 || Hi20 == 0) {
-      unsigned AddiOpc = (Is64Bit && Hi20) ? RISCV::ADDIW : RISCV::ADDI;
-      Res.push_back(Inst(AddiOpc, Lo12));
-    }
-    return;
-  }
-
-  assert(Is64Bit && "Can't emit >32-bit imm for non-RV64 target");
-
-  // In the worst case, for a full 64-bit constant, a sequence of 8 instructions
-  // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emmitted. Note
-  // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits
-  // while the following ADDI instructions contribute up to 12 bits each.
-  //
-  // On the first glance, implementing this seems to be possible by simply
-  // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left
-  // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the
-  // fact that ADDI performs a sign extended addition, doing it like that would
-  // only be possible when at most 11 bits of the ADDI instructions are used.
-  // Using all 12 bits of the ADDI instructions, like done by GAS, actually
-  // requires that the constant is processed starting with the least significant
-  // bit.
-  //
-  // In the following, constants are processed from LSB to MSB but instruction
-  // emission is performed from MSB to LSB by recursively calling
-  // generateInstSeq. In each recursion, first the lowest 12 bits are removed
-  // from the constant and the optimal shift amount, which can be greater than
-  // 12 bits if the constant is sparse, is determined. Then, the shifted
-  // remaining constant is processed recursively and gets emitted as soon as it
-  // fits into 32 bits. The emission of the shifts and additions is subsequently
-  // performed when the recursion returns.
-
-  int64_t Lo12 = SignExtend64<12>(Val);
-  int64_t Hi52 = (Val + 0x800) >> 12;
-  int ShiftAmount = 12 + findFirstSet((uint64_t)Hi52);
-  Hi52 = SignExtend64(Hi52 >> (ShiftAmount - 12), 64 - ShiftAmount);
-
-  generateInstSeq(Hi52, Is64Bit, Res);
-
-  Res.push_back(Inst(RISCV::SLLI, ShiftAmount));
-  if (Lo12)
-    Res.push_back(Inst(RISCV::ADDI, Lo12));
-}
-} // namespace RISCVMatInt
-} // namespace llvm
diff --git a/lib/Target/RISCV/Utils/RISCVMatInt.h b/lib/Target/RISCV/Utils/RISCVMatInt.h
deleted file mode 100644
index 49d1d89adc7..00000000000
--- a/lib/Target/RISCV/Utils/RISCVMatInt.h
+++ /dev/null
@@ -1,36 +0,0 @@
-//===- RISCVMatInt.h - Immediate materialisation ---------------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MATINT_H
-#define LLVM_LIB_TARGET_RISCV_MATINT_H
-
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/Support/MachineValueType.h"
-#include <cstdint>
-
-namespace llvm {
-
-namespace RISCVMatInt {
-struct Inst {
-  unsigned Opc;
-  int64_t Imm;
-
-  Inst(unsigned Opc, int64_t Imm) : Opc(Opc), Imm(Imm) {}
-};
-using InstSeq = SmallVector<Inst, 8>;
-
-// Helper to generate an instruction sequence that will materialise the given
-// immediate value into a register. A sequence of instructions represented by
-// a simple struct produced rather than directly emitting the instructions in
-// order to allow this helper to be used from both the MC layer and during
-// instruction selection.
-void generateInstSeq(int64_t Val, bool IsRV64, InstSeq &Res);
-} // namespace RISCVMatInt
-} // namespace llvm
-#endif
diff --git a/test/Assembler/empty-string.s b/test/Assembler/empty-string.s
deleted file mode 100644
index 2d3d0ed15ad..00000000000
--- a/test/Assembler/empty-string.s
+++ /dev/null
@@ -1,3 +0,0 @@
-// REQUIRES: riscv-registered-target
-// RUN: not llvm-mc -triple riscv32-unknown-linux-gnu < %s 2>&1 | FileCheck %s
-"" # CHECK: error: unrecognized instruction mnemonic
diff --git a/test/CodeGen/RISCV/addc-adde-sube-subc.ll b/test/CodeGen/RISCV/addc-adde-sube-subc.ll
deleted file mode 100644
index 7c28df4c30f..00000000000
--- a/test/CodeGen/RISCV/addc-adde-sube-subc.ll
+++ /dev/null
@@ -1,30 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-; Ensure that the ISDOpcodes ADDC, ADDE, SUBC, SUBE are handled correctly
-
-define i64 @addc_adde(i64 %a, i64 %b) {
-; RV32I-LABEL: addc_adde:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a1, a1, a3
-; RV32I-NEXT:    add a2, a0, a2
-; RV32I-NEXT:    sltu a0, a2, a0
-; RV32I-NEXT:    add a1, a1, a0
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = add i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @subc_sube(i64 %a, i64 %b) {
-; RV32I-LABEL: subc_sube:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sltu a3, a0, a2
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sub a0, a0, a2
-; RV32I-NEXT:    ret
-  %1 = sub i64 %a, %b
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/align.ll b/test/CodeGen/RISCV/align.ll
deleted file mode 100644
index f044f3bb156..00000000000
--- a/test/CodeGen/RISCV/align.ll
+++ /dev/null
@@ -1,13 +0,0 @@
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv32 -mattr=+c -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32C
-
-define void @foo() {
-;RV32I: .p2align 2
-;RV32I: foo:
-;RV32C: .p2align 1
-;RV32C: foo:
-entry:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/alloca.ll b/test/CodeGen/RISCV/alloca.ll
deleted file mode 100644
index 22dd42ccb7e..00000000000
--- a/test/CodeGen/RISCV/alloca.ll
+++ /dev/null
@@ -1,105 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-declare void @notdead(i8*)
-
-; These tests must ensure the stack pointer is restored using the frame
-; pointer
-
-define void @simple_alloca(i32 %n) nounwind {
-; RV32I-LABEL: simple_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    call notdead
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = alloca i8, i32 %n
-  call void @notdead(i8* %1)
-  ret void
-}
-
-declare i8* @llvm.stacksave()
-declare void @llvm.stackrestore(i8*)
-
-define void @scoped_alloca(i32 %n) nounwind {
-; RV32I-LABEL: scoped_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    sw s1, 4(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    mv s1, sp
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    call notdead
-; RV32I-NEXT:    mv sp, s1
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s1, 4(sp)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %sp = call i8* @llvm.stacksave()
-  %addr = alloca i8, i32 %n
-  call void @notdead(i8* %addr)
-  call void @llvm.stackrestore(i8* %sp)
-  ret void
-}
-
-declare void @func(i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)
-
-; Check that outgoing arguments passed on the stack do not corrupt a
-; variable-sized stack object.
-define void @alloca_callframe(i32 %n) nounwind {
-; RV32I-LABEL: alloca_callframe:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    addi a1, zero, 12
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 11
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, zero, 10
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    addi a1, zero, 9
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    addi a1, zero, 2
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    addi a4, zero, 5
-; RV32I-NEXT:    addi a5, zero, 6
-; RV32I-NEXT:    addi a6, zero, 7
-; RV32I-NEXT:    addi a7, zero, 8
-; RV32I-NEXT:    call func
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = alloca i8, i32 %n
-  call void @func(i8* %1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8,
-                  i32 9, i32 10, i32 11, i32 12)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/alu16.ll b/test/CodeGen/RISCV/alu16.ll
deleted file mode 100644
index 15bf44e526e..00000000000
--- a/test/CodeGen/RISCV/alu16.ll
+++ /dev/null
@@ -1,324 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; These tests are identical to those in alu32.ll but operate on i16. They check
-; that legalisation of these non-native types doesn't introduce unnecessary
-; inefficiencies.
-
-define i16 @addi(i16 %a) nounwind {
-; RV32I-LABEL: addi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: addi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = add i16 %a, 1
-  ret i16 %1
-}
-
-define i16 @slti(i16 %a) nounwind {
-; RV32I-LABEL: slti:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 16
-; RV32I-NEXT:    slti a0, a0, 2
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slti:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 48
-; RV64I-NEXT:    slti a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = icmp slt i16 %a, 2
-  %2 = zext i1 %1 to i16
-  ret i16 %2
-}
-
-define i16 @sltiu(i16 %a) nounwind {
-; RV32I-LABEL: sltiu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    sltiu a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltiu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a1, 16
-; RV64I-NEXT:    addiw a1, a1, -1
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    sltiu a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = icmp ult i16 %a, 3
-  %2 = zext i1 %1 to i16
-  ret i16 %2
-}
-
-define i16 @xori(i16 %a) nounwind {
-; RV32I-LABEL: xori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xori a0, a0, 4
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xori a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = xor i16 %a, 4
-  ret i16 %1
-}
-
-define i16 @ori(i16 %a) nounwind {
-; RV32I-LABEL: ori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ori a0, a0, 5
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: ori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ori a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = or i16 %a, 5
-  ret i16 %1
-}
-
-define i16 @andi(i16 %a) nounwind {
-; RV32I-LABEL: andi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 6
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: andi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = and i16 %a, 6
-  ret i16 %1
-}
-
-define i16 @slli(i16 %a) nounwind {
-; RV32I-LABEL: slli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 7
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 7
-; RV64I-NEXT:    ret
-  %1 = shl i16 %a, 7
-  ret i16 %1
-}
-
-define i16 @srli(i16 %a) nounwind {
-; RV32I-LABEL: srli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -64
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    srli a0, a0, 6
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a1, 16
-; RV64I-NEXT:    addiw a1, a1, -64
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    srli a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = lshr i16 %a, 6
-  ret i16 %1
-}
-
-define i16 @srai(i16 %a) nounwind {
-; RV32I-LABEL: srai:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 25
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srai:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 57
-; RV64I-NEXT:    ret
-  %1 = ashr i16 %a, 9
-  ret i16 %1
-}
-
-
-define i16 @add(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: add:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: add:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @sub(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: sub:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sub:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @sll(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: sll:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sll:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @slt(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 16
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slt:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a1, a1, 48
-; RV64I-NEXT:    srai a1, a1, 48
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 48
-; RV64I-NEXT:    slt a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp slt i16 %a, %b
-  %2 = zext i1 %1 to i16
-  ret i16 %2
-}
-
-define i16 @sltu(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: sltu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, 16
-; RV32I-NEXT:    addi a2, a2, -1
-; RV32I-NEXT:    and a1, a1, a2
-; RV32I-NEXT:    and a0, a0, a2
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a2, 16
-; RV64I-NEXT:    addiw a2, a2, -1
-; RV64I-NEXT:    and a1, a1, a2
-; RV64I-NEXT:    and a0, a0, a2
-; RV64I-NEXT:    sltu a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp ult i16 %a, %b
-  %2 = zext i1 %1 to i16
-  ret i16 %2
-}
-
-define i16 @xor(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: xor:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xor:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xor a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = xor i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @srl(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: srl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, 16
-; RV32I-NEXT:    addi a2, a2, -1
-; RV32I-NEXT:    and a0, a0, a2
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srl:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a2, 16
-; RV64I-NEXT:    addiw a2, a2, -1
-; RV64I-NEXT:    and a0, a0, a2
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @sra(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: sra:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 16
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sra:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 48
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @or(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: or:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: or:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    or a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = or i16 %a, %b
-  ret i16 %1
-}
-
-define i16 @and(i16 %a, i16 %b) nounwind {
-; RV32I-LABEL: and:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: and:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = and i16 %a, %b
-  ret i16 %1
-}
diff --git a/test/CodeGen/RISCV/alu32.ll b/test/CodeGen/RISCV/alu32.ll
deleted file mode 100644
index 3776e53c306..00000000000
--- a/test/CodeGen/RISCV/alu32.ll
+++ /dev/null
@@ -1,299 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; These tests are each targeted at a particular RISC-V ALU instruction. Most
-; other files in this folder exercise LLVM IR instructions that don't directly
-; match a RISC-V instruction.
-
-; Register-immediate instructions.
-
-; TODO: Sign-extension would also work when promoting the operands of
-; sltu/sltiu on RV64 and is cheaper than zero-extension (1 instruction vs 2).
-
-define i32 @addi(i32 %a) nounwind {
-; RV32I-LABEL: addi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: addi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @slti(i32 %a) nounwind {
-; RV32I-LABEL: slti:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slti a0, a0, 2
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slti:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    slti a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = icmp slt i32 %a, 2
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @sltiu(i32 %a) nounwind {
-; RV32I-LABEL: sltiu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltiu a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltiu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sltiu a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = icmp ult i32 %a, 3
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @xori(i32 %a) nounwind {
-; RV32I-LABEL: xori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xori a0, a0, 4
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xori a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = xor i32 %a, 4
-  ret i32 %1
-}
-
-define i32 @ori(i32 %a) nounwind {
-; RV32I-LABEL: ori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ori a0, a0, 5
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: ori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ori a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = or i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @andi(i32 %a) nounwind {
-; RV32I-LABEL: andi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 6
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: andi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = and i32 %a, 6
-  ret i32 %1
-}
-
-define i32 @slli(i32 %a) nounwind {
-; RV32I-LABEL: slli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 7
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 7
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 7
-  ret i32 %1
-}
-
-define i32 @srli(i32 %a) nounwind {
-; RV32I-LABEL: srli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 8
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 8
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 8
-  ret i32 %1
-}
-
-define i32 @srai(i32 %a) nounwind {
-; RV32I-LABEL: srai:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a0, a0, 9
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srai:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 9
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 9
-  ret i32 %1
-}
-
-; Register-register instructions
-
-define i32 @add(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: add:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: add:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sub(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sub:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sub:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sll(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sll:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sll:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @slt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slt:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a1, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    slt a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp slt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @sltu(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sltu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a1, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sltu a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp ult i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @xor(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: xor:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xor:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xor a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = xor i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: should select srlw for RV64.
-
-define i32 @srl(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srl:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: should select sraw for RV64.
-
-define i32 @sra(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sra:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sra:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @or(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: or:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: or:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    or a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = or i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @and(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: and:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: and:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = and i32 %a, %b
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/alu64.ll b/test/CodeGen/RISCV/alu64.ll
deleted file mode 100644
index 021211b6f36..00000000000
--- a/test/CodeGen/RISCV/alu64.ll
+++ /dev/null
@@ -1,499 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; These tests are each targeted at a particular RISC-V ALU instruction. Other
-; files in this folder exercise LLVM IR instructions that don't directly match a
-; RISC-V instruction. This file contains tests for the instructions common
-; between RV32I and RV64I as well as the *W instructions introduced in RV64I.
-
-; Register-immediate instructions
-
-define i64 @addi(i64 %a) nounwind {
-; RV64I-LABEL: addi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: addi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a2, a0, 1
-; RV32I-NEXT:    sltu a0, a2, a0
-; RV32I-NEXT:    add a1, a1, a0
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = add i64 %a, 1
-  ret i64 %1
-}
-
-define i64 @slti(i64 %a) nounwind {
-; RV64I-LABEL: slti:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slti a0, a0, 2
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: slti:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    beqz a1, .LBB1_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    slti a0, a1, 0
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB1_2:
-; RV32I-NEXT:    sltiu a0, a0, 2
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = icmp slt i64 %a, 2
-  %2 = zext i1 %1 to i64
-  ret i64 %2
-}
-
-define i64 @sltiu(i64 %a) nounwind {
-; RV64I-LABEL: sltiu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sltiu a0, a0, 3
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sltiu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    beqz a1, .LBB2_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB2_2:
-; RV32I-NEXT:    sltiu a0, a0, 3
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = icmp ult i64 %a, 3
-  %2 = zext i1 %1 to i64
-  ret i64 %2
-}
-
-define i64 @xori(i64 %a) nounwind {
-; RV64I-LABEL: xori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xori a0, a0, 4
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: xori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xori a0, a0, 4
-; RV32I-NEXT:    ret
-  %1 = xor i64 %a, 4
-  ret i64 %1
-}
-
-define i64 @ori(i64 %a) nounwind {
-; RV64I-LABEL: ori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ori a0, a0, 5
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: ori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ori a0, a0, 5
-; RV32I-NEXT:    ret
-  %1 = or i64 %a, 5
-  ret i64 %1
-}
-
-define i64 @andi(i64 %a) nounwind {
-; RV64I-LABEL: andi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 6
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: andi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 6
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = and i64 %a, 6
-  ret i64 %1
-}
-
-define i64 @slli(i64 %a) nounwind {
-; RV64I-LABEL: slli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 7
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: slli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a1, 7
-; RV32I-NEXT:    srli a2, a0, 25
-; RV32I-NEXT:    or a1, a1, a2
-; RV32I-NEXT:    slli a0, a0, 7
-; RV32I-NEXT:    ret
-  %1 = shl i64 %a, 7
-  ret i64 %1
-}
-
-define i64 @srli(i64 %a) nounwind {
-; RV64I-LABEL: srli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srli a0, a0, 8
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: srli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 8
-; RV32I-NEXT:    slli a2, a1, 24
-; RV32I-NEXT:    or a0, a0, a2
-; RV32I-NEXT:    srli a1, a1, 8
-; RV32I-NEXT:    ret
-  %1 = lshr i64 %a, 8
-  ret i64 %1
-}
-
-define i64 @srai(i64 %a) nounwind {
-; RV64I-LABEL: srai:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srai a0, a0, 9
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: srai:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 9
-; RV32I-NEXT:    slli a2, a1, 23
-; RV32I-NEXT:    or a0, a0, a2
-; RV32I-NEXT:    srai a1, a1, 9
-; RV32I-NEXT:    ret
-  %1 = ashr i64 %a, 9
-  ret i64 %1
-}
-
-; Register-register instructions
-
-define i64 @add(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: add:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: add:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a1, a1, a3
-; RV32I-NEXT:    add a2, a0, a2
-; RV32I-NEXT:    sltu a0, a2, a0
-; RV32I-NEXT:    add a1, a1, a0
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = add i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @sub(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: sub:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sub:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sltu a3, a0, a2
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sub a0, a0, a2
-; RV32I-NEXT:    ret
-  %1 = sub i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @sll(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: sll:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sll:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __ashldi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = shl i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @slt(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: slt:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slt a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    beq a1, a3, .LBB12_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    slt a0, a1, a3
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB12_2:
-; RV32I-NEXT:    sltu a0, a0, a2
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = icmp slt i64 %a, %b
-  %2 = zext i1 %1 to i64
-  ret i64 %2
-}
-
-define i64 @sltu(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: sltu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sltu a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sltu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    beq a1, a3, .LBB13_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    sltu a0, a1, a3
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB13_2:
-; RV32I-NEXT:    sltu a0, a0, a2
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = icmp ult i64 %a, %b
-  %2 = zext i1 %1 to i64
-  ret i64 %2
-}
-
-define i64 @xor(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: xor:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xor a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: xor:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a2
-; RV32I-NEXT:    xor a1, a1, a3
-; RV32I-NEXT:    ret
-  %1 = xor i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @srl(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: srl:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: srl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __lshrdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = lshr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @sra(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: sra:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sra:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __ashrdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = ashr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @or(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: or:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    or a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: or:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    or a0, a0, a2
-; RV32I-NEXT:    or a1, a1, a3
-; RV32I-NEXT:    ret
-  %1 = or i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @and(i64 %a, i64 %b) nounwind {
-; RV64I-LABEL: and:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: and:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    and a0, a0, a2
-; RV32I-NEXT:    and a1, a1, a3
-; RV32I-NEXT:    ret
-  %1 = and i64 %a, %b
-  ret i64 %1
-}
-
-; RV64I-only instructions
-
-define signext i32 @addiw(i32 signext %a) {
-; RV64I-LABEL: addiw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addiw a0, a0, 123
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: addiw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 123
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, 123
-  ret i32 %1
-}
-
-define signext i32 @slliw(i32 signext %a) {
-; RV64I-LABEL: slliw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slliw a0, a0, 17
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: slliw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 17
-; RV32I-NEXT:    ret
-  %1 = shl i32 %a, 17
-  ret i32 %1
-}
-
-define signext i32 @srliw(i32 %a) {
-; RV64I-LABEL: srliw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 8
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: srliw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 8
-; RV32I-NEXT:    ret
-  %1 = lshr i32 %a, 8
-  ret i32 %1
-}
-
-define signext i32 @sraiw(i32 %a) {
-; RV64I-LABEL: sraiw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 9
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sraiw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a0, a0, 9
-; RV32I-NEXT:    ret
-  %1 = ashr i32 %a, 9
-  ret i32 %1
-}
-
-define signext i32 @sextw(i32 zeroext %a) {
-; RV64I-LABEL: sextw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sextw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i32 %a
-}
-
-define signext i32 @addw(i32 signext %a, i32 signext %b) {
-; RV64I-LABEL: addw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: addw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @subw(i32 signext %a, i32 signext %b) {
-; RV64I-LABEL: subw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: subw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: should select sllw for RV64.
-
-define signext i32 @sllw(i32 signext %a, i32 zeroext %b) {
-; RV64I-LABEL: sllw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sllw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: should select srlw for RV64.
-
-define signext i32 @srlw(i32 signext %a, i32 zeroext %b) {
-; RV64I-LABEL: srlw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: srlw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: should select sraw for RV64.
-
-define signext i32 @sraw(i64 %a, i32 zeroext %b) {
-; RV64I-LABEL: sraw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-;
-; RV32I-LABEL: sraw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sra a0, a0, a2
-; RV32I-NEXT:    ret
-  %1 = trunc i64 %a to i32
-  %2 = ashr i32 %1, %b
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/alu8.ll b/test/CodeGen/RISCV/alu8.ll
deleted file mode 100644
index ed09174745b..00000000000
--- a/test/CodeGen/RISCV/alu8.ll
+++ /dev/null
@@ -1,308 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; These tests are identical to those in alu32.ll but operate on i8. They check
-; that legalisation of these non-native types doesn't introduce unnecessary
-; inefficiencies.
-
-define i8 @addi(i8 %a) nounwind {
-; RV32I-LABEL: addi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: addi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = add i8 %a, 1
-  ret i8 %1
-}
-
-define i8 @slti(i8 %a) nounwind {
-; RV32I-LABEL: slti:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    slti a0, a0, 2
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slti:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    slti a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = icmp slt i8 %a, 2
-  %2 = zext i1 %1 to i8
-  ret i8 %2
-}
-
-define i8 @sltiu(i8 %a) nounwind {
-; RV32I-LABEL: sltiu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    sltiu a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltiu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    sltiu a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = icmp ult i8 %a, 3
-  %2 = zext i1 %1 to i8
-  ret i8 %2
-}
-
-define i8 @xori(i8 %a) nounwind {
-; RV32I-LABEL: xori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xori a0, a0, 4
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xori a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = xor i8 %a, 4
-  ret i8 %1
-}
-
-define i8 @ori(i8 %a) nounwind {
-; RV32I-LABEL: ori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ori a0, a0, 5
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: ori:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ori a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = or i8 %a, 5
-  ret i8 %1
-}
-
-define i8 @andi(i8 %a) nounwind {
-; RV32I-LABEL: andi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 6
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: andi:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = and i8 %a, 6
-  ret i8 %1
-}
-
-define i8 @slli(i8 %a) nounwind {
-; RV32I-LABEL: slli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 7
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 7
-; RV64I-NEXT:    ret
-  %1 = shl i8 %a, 7
-  ret i8 %1
-}
-
-define i8 @srli(i8 %a) nounwind {
-; RV32I-LABEL: srli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 192
-; RV32I-NEXT:    srli a0, a0, 6
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srli:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 192
-; RV64I-NEXT:    srli a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = lshr i8 %a, 6
-  ret i8 %1
-}
-
-define i8 @srai(i8 %a) nounwind {
-; RV32I-LABEL: srai:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 29
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srai:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 61
-; RV64I-NEXT:    ret
-  %1 = ashr i8 %a, 5
-  ret i8 %1
-}
-
-
-define i8 @add(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: add:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: add:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @sub(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: sub:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sub:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @sll(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: sll:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sll:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @slt(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: slt:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a1, a1, 56
-; RV64I-NEXT:    srai a1, a1, 56
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    slt a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp slt i8 %a, %b
-  %2 = zext i1 %1 to i8
-  ret i8 %2
-}
-
-define i8 @sltu(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: sltu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a1, a1, 255
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sltu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a1, a1, 255
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    sltu a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = icmp ult i8 %a, %b
-  %2 = zext i1 %1 to i8
-  ret i8 %2
-}
-
-define i8 @xor(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: xor:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: xor:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    xor a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = xor i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @srl(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: srl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: srl:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @sra(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: sra:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sra:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @or(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: or:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: or:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    or a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = or i8 %a, %b
-  ret i8 %1
-}
-
-define i8 @and(i8 %a, i8 %b) nounwind {
-; RV32I-LABEL: and:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: and:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = and i8 %a, %b
-  ret i8 %1
-}
diff --git a/test/CodeGen/RISCV/analyze-branch.ll b/test/CodeGen/RISCV/analyze-branch.ll
deleted file mode 100644
index f5b07836e87..00000000000
--- a/test/CodeGen/RISCV/analyze-branch.ll
+++ /dev/null
@@ -1,79 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-; This test checks that LLVM can do basic stripping and reapplying of branches
-; to basic blocks.
-
-declare void @test_true()
-declare void @test_false()
-
-; !0 corresponds to a branch being taken, !1 to not being takne.
-!0 = !{!"branch_weights", i32 64, i32 4}
-!1 = !{!"branch_weights", i32 4, i32 64}
-
-define void @test_bcc_fallthrough_taken(i32 %in) nounwind {
-; RV32I-LABEL: test_bcc_fallthrough_taken:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 42
-; RV32I-NEXT:    bne a0, a1, .LBB0_3
-; RV32I-NEXT:  # %bb.1: # %true
-; RV32I-NEXT:    call test_true
-; RV32I-NEXT:  .LBB0_2: # %true
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_3: # %false
-; RV32I-NEXT:    call test_false
-; RV32I-NEXT:    j .LBB0_2
-  %tst = icmp eq i32 %in, 42
-  br i1 %tst, label %true, label %false, !prof !0
-
-; Expected layout order is: Entry, TrueBlock, FalseBlock
-; Entry->TrueBlock is the common path, which should be taken whenever the
-; conditional branch is false.
-
-true:
-  call void @test_true()
-  ret void
-
-false:
-  call void @test_false()
-  ret void
-}
-
-define void @test_bcc_fallthrough_nottaken(i32 %in) nounwind {
-; RV32I-LABEL: test_bcc_fallthrough_nottaken:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 42
-; RV32I-NEXT:    beq a0, a1, .LBB1_3
-; RV32I-NEXT:  # %bb.1: # %false
-; RV32I-NEXT:    call test_false
-; RV32I-NEXT:  .LBB1_2: # %true
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB1_3: # %true
-; RV32I-NEXT:    call test_true
-; RV32I-NEXT:    j .LBB1_2
-  %tst = icmp eq i32 %in, 42
-  br i1 %tst, label %true, label %false, !prof !1
-
-; Expected layout order is: Entry, FalseBlock, TrueBlock
-; Entry->FalseBlock is the common path, which should be taken whenever the
-; conditional branch is false
-
-true:
-  call void @test_true()
-  ret void
-
-false:
-  call void @test_false()
-  ret void
-}
-
-; TODO: how can we expand the coverage of the branch analysis functions?
diff --git a/test/CodeGen/RISCV/arith-with-overflow.ll b/test/CodeGen/RISCV/arith-with-overflow.ll
deleted file mode 100644
index 3fb6342133e..00000000000
--- a/test/CodeGen/RISCV/arith-with-overflow.ll
+++ /dev/null
@@ -1,84 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
-declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
-declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
-declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)
-
-define i1 @sadd(i32 %a, i32 %b, i32* %c) nounwind {
-; RV32I-LABEL: sadd:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    add a3, a0, a1
-; RV32I-NEXT:    sw a3, 0(a2)
-; RV32I-NEXT:    addi a2, zero, -1
-; RV32I-NEXT:    slt a1, a2, a1
-; RV32I-NEXT:    slt a0, a2, a0
-; RV32I-NEXT:    slt a2, a2, a3
-; RV32I-NEXT:    xor a2, a0, a2
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    seqz a0, a0
-; RV32I-NEXT:    snez a1, a2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-entry:
-  %x = call {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
-  %calc = extractvalue {i32, i1} %x, 0
-  %ovf = extractvalue {i32, i1} %x, 1
-  store i32 %calc, i32* %c
-  ret i1 %ovf
-}
-
-define i1 @ssub(i32 %a, i32 %b, i32* %c) nounwind {
-; RV32I-LABEL: ssub:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    sub a3, a0, a1
-; RV32I-NEXT:    sw a3, 0(a2)
-; RV32I-NEXT:    addi a2, zero, -1
-; RV32I-NEXT:    slt a1, a2, a1
-; RV32I-NEXT:    slt a0, a2, a0
-; RV32I-NEXT:    slt a2, a2, a3
-; RV32I-NEXT:    xor a2, a0, a2
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    snez a1, a2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-entry:
-  %x = call {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
-  %calc = extractvalue {i32, i1} %x, 0
-  %ovf = extractvalue {i32, i1} %x, 1
-  store i32 %calc, i32* %c
-  ret i1 %ovf
-}
-
-define i1 @uadd(i32 %a, i32 %b, i32* %c) nounwind {
-; RV32I-LABEL: uadd:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    add a1, a0, a1
-; RV32I-NEXT:    sw a1, 0(a2)
-; RV32I-NEXT:    sltu a0, a1, a0
-; RV32I-NEXT:    ret
-entry:
-  %x = call {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
-  %calc = extractvalue {i32, i1} %x, 0
-  %ovf = extractvalue {i32, i1} %x, 1
-  store i32 %calc, i32* %c
-  ret i1 %ovf
-}
-
-define i1 @usub(i32 %a, i32 %b, i32* %c) nounwind {
-; RV32I-LABEL: usub:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    sub a1, a0, a1
-; RV32I-NEXT:    sw a1, 0(a2)
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-entry:
-  %x = call {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)
-  %calc = extractvalue {i32, i1} %x, 0
-  %ovf = extractvalue {i32, i1} %x, 1
-  store i32 %calc, i32* %c
-  ret i1 %ovf
-}
diff --git a/test/CodeGen/RISCV/atomic-cmpxchg.ll b/test/CodeGen/RISCV/atomic-cmpxchg.ll
deleted file mode 100644
index 85cd1691366..00000000000
--- a/test/CodeGen/RISCV/atomic-cmpxchg.ll
+++ /dev/null
@@ -1,1489 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+a -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IA %s
-
-define void @cmpxchg_i8_monotonic_monotonic(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_monotonic_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_monotonic_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB0_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB0_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB0_1
-; RV32IA-NEXT:  .LBB0_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val monotonic monotonic
-  ret void
-}
-
-define void @cmpxchg_i8_acquire_monotonic(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_acquire_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_acquire_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB1_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB1_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB1_1
-; RV32IA-NEXT:  .LBB1_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val acquire monotonic
-  ret void
-}
-
-define void @cmpxchg_i8_acquire_acquire(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_acquire_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_acquire_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB2_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB2_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB2_1
-; RV32IA-NEXT:  .LBB2_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val acquire acquire
-  ret void
-}
-
-define void @cmpxchg_i8_release_monotonic(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_release_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_release_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB3_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB3_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB3_1
-; RV32IA-NEXT:  .LBB3_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val release monotonic
-  ret void
-}
-
-define void @cmpxchg_i8_release_acquire(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_release_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_release_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB4_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB4_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB4_1
-; RV32IA-NEXT:  .LBB4_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val release acquire
-  ret void
-}
-
-define void @cmpxchg_i8_acq_rel_monotonic(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_acq_rel_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_acq_rel_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB5_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB5_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB5_1
-; RV32IA-NEXT:  .LBB5_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val acq_rel monotonic
-  ret void
-}
-
-define void @cmpxchg_i8_acq_rel_acquire(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_acq_rel_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_acq_rel_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB6_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB6_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB6_1
-; RV32IA-NEXT:  .LBB6_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val acq_rel acquire
-  ret void
-}
-
-define void @cmpxchg_i8_seq_cst_monotonic(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_seq_cst_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_seq_cst_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB7_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB7_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB7_1
-; RV32IA-NEXT:  .LBB7_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val seq_cst monotonic
-  ret void
-}
-
-define void @cmpxchg_i8_seq_cst_acquire(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_seq_cst_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_seq_cst_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB8_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB8_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB8_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB8_1
-; RV32IA-NEXT:  .LBB8_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val seq_cst acquire
-  ret void
-}
-
-define void @cmpxchg_i8_seq_cst_seq_cst(i8* %ptr, i8 %cmp, i8 %val) {
-; RV32I-LABEL: cmpxchg_i8_seq_cst_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sb a1, 11(sp)
-; RV32I-NEXT:    addi a1, sp, 11
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i8_seq_cst_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a4, a4, a3
-; RV32IA-NEXT:    andi a2, a2, 255
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB9_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    and a5, a3, a4
-; RV32IA-NEXT:    bne a5, a1, .LBB9_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB9_1 Depth=1
-; RV32IA-NEXT:    xor a5, a3, a2
-; RV32IA-NEXT:    and a5, a5, a4
-; RV32IA-NEXT:    xor a5, a3, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB9_1
-; RV32IA-NEXT:  .LBB9_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i8* %ptr, i8 %cmp, i8 %val seq_cst seq_cst
-  ret void
-}
-
-define void @cmpxchg_i16_monotonic_monotonic(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_monotonic_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_monotonic_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB10_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB10_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB10_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB10_1
-; RV32IA-NEXT:  .LBB10_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val monotonic monotonic
-  ret void
-}
-
-define void @cmpxchg_i16_acquire_monotonic(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_acquire_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_acquire_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB11_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB11_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB11_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB11_1
-; RV32IA-NEXT:  .LBB11_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val acquire monotonic
-  ret void
-}
-
-define void @cmpxchg_i16_acquire_acquire(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_acquire_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_acquire_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB12_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB12_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB12_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB12_1
-; RV32IA-NEXT:  .LBB12_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val acquire acquire
-  ret void
-}
-
-define void @cmpxchg_i16_release_monotonic(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_release_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_release_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB13_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB13_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB13_1
-; RV32IA-NEXT:  .LBB13_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val release monotonic
-  ret void
-}
-
-define void @cmpxchg_i16_release_acquire(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_release_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_release_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB14_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB14_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB14_1
-; RV32IA-NEXT:  .LBB14_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val release acquire
-  ret void
-}
-
-define void @cmpxchg_i16_acq_rel_monotonic(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_acq_rel_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_acq_rel_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB15_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB15_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB15_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB15_1
-; RV32IA-NEXT:  .LBB15_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val acq_rel monotonic
-  ret void
-}
-
-define void @cmpxchg_i16_acq_rel_acquire(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_acq_rel_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_acq_rel_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB16_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB16_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB16_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB16_1
-; RV32IA-NEXT:  .LBB16_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val acq_rel acquire
-  ret void
-}
-
-define void @cmpxchg_i16_seq_cst_monotonic(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_seq_cst_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_seq_cst_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB17_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB17_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB17_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB17_1
-; RV32IA-NEXT:  .LBB17_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val seq_cst monotonic
-  ret void
-}
-
-define void @cmpxchg_i16_seq_cst_acquire(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_seq_cst_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_seq_cst_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB18_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB18_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB18_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB18_1
-; RV32IA-NEXT:  .LBB18_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val seq_cst acquire
-  ret void
-}
-
-define void @cmpxchg_i16_seq_cst_seq_cst(i16* %ptr, i16 %cmp, i16 %val) {
-; RV32I-LABEL: cmpxchg_i16_seq_cst_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sh a1, 10(sp)
-; RV32I-NEXT:    addi a1, sp, 10
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i16_seq_cst_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a3, 16
-; RV32IA-NEXT:    addi a3, a3, -1
-; RV32IA-NEXT:    and a1, a1, a3
-; RV32IA-NEXT:    and a2, a2, a3
-; RV32IA-NEXT:    slli a4, a0, 3
-; RV32IA-NEXT:    andi a4, a4, 24
-; RV32IA-NEXT:    sll a3, a3, a4
-; RV32IA-NEXT:    sll a2, a2, a4
-; RV32IA-NEXT:    sll a1, a1, a4
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB19_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a3
-; RV32IA-NEXT:    bne a5, a1, .LBB19_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB19_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a2
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB19_1
-; RV32IA-NEXT:  .LBB19_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i16* %ptr, i16 %cmp, i16 %val seq_cst seq_cst
-  ret void
-}
-
-define void @cmpxchg_i32_monotonic_monotonic(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_monotonic_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_monotonic_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB20_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB20_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB20_1 Depth=1
-; RV32IA-NEXT:    sc.w a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB20_1
-; RV32IA-NEXT:  .LBB20_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val monotonic monotonic
-  ret void
-}
-
-define void @cmpxchg_i32_acquire_monotonic(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_acquire_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_acquire_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB21_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB21_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB21_1 Depth=1
-; RV32IA-NEXT:    sc.w a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB21_1
-; RV32IA-NEXT:  .LBB21_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val acquire monotonic
-  ret void
-}
-
-define void @cmpxchg_i32_acquire_acquire(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_acquire_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_acquire_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB22_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB22_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB22_1 Depth=1
-; RV32IA-NEXT:    sc.w a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB22_1
-; RV32IA-NEXT:  .LBB22_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val acquire acquire
-  ret void
-}
-
-define void @cmpxchg_i32_release_monotonic(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_release_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_release_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB23_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB23_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB23_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB23_1
-; RV32IA-NEXT:  .LBB23_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val release monotonic
-  ret void
-}
-
-define void @cmpxchg_i32_release_acquire(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_release_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_release_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB24_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB24_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB24_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB24_1
-; RV32IA-NEXT:  .LBB24_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val release acquire
-  ret void
-}
-
-define void @cmpxchg_i32_acq_rel_monotonic(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_acq_rel_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_acq_rel_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB25_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB25_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB25_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB25_1
-; RV32IA-NEXT:  .LBB25_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val acq_rel monotonic
-  ret void
-}
-
-define void @cmpxchg_i32_acq_rel_acquire(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_acq_rel_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_acq_rel_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB26_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB26_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB26_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB26_1
-; RV32IA-NEXT:  .LBB26_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val acq_rel acquire
-  ret void
-}
-
-define void @cmpxchg_i32_seq_cst_monotonic(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_seq_cst_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_seq_cst_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB27_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB27_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB27_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB27_1
-; RV32IA-NEXT:  .LBB27_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val seq_cst monotonic
-  ret void
-}
-
-define void @cmpxchg_i32_seq_cst_acquire(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_seq_cst_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_seq_cst_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB28_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB28_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB28_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB28_1
-; RV32IA-NEXT:  .LBB28_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val seq_cst acquire
-  ret void
-}
-
-define void @cmpxchg_i32_seq_cst_seq_cst(i32* %ptr, i32 %cmp, i32 %val) {
-; RV32I-LABEL: cmpxchg_i32_seq_cst_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    mv a4, a3
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i32_seq_cst_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB29_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a3, (a0)
-; RV32IA-NEXT:    bne a3, a1, .LBB29_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB29_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a4, a2, (a0)
-; RV32IA-NEXT:    bnez a4, .LBB29_1
-; RV32IA-NEXT:  .LBB29_3:
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i32* %ptr, i32 %cmp, i32 %val seq_cst seq_cst
-  ret void
-}
-
-define void @cmpxchg_i64_monotonic_monotonic(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_monotonic_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_monotonic_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a4
-; RV32IA-NEXT:    mv a4, zero
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val monotonic monotonic
-  ret void
-}
-
-define void @cmpxchg_i64_acquire_monotonic(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_acquire_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a5, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_acquire_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 2
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val acquire monotonic
-  ret void
-}
-
-define void @cmpxchg_i64_acquire_acquire(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_acquire_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a5, zero, 2
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a4
-; RV32I-NEXT:    mv a4, a5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_acquire_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a5, zero, 2
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a4
-; RV32IA-NEXT:    mv a4, a5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val acquire acquire
-  ret void
-}
-
-define void @cmpxchg_i64_release_monotonic(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_release_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a5, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 3
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_release_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 3
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val release monotonic
-  ret void
-}
-
-define void @cmpxchg_i64_release_acquire(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_release_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a6, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 3
-; RV32I-NEXT:    addi a5, zero, 2
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_release_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a6, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 3
-; RV32IA-NEXT:    addi a5, zero, 2
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val release acquire
-  ret void
-}
-
-define void @cmpxchg_i64_acq_rel_monotonic(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_acq_rel_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a5, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 4
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_acq_rel_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 4
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val acq_rel monotonic
-  ret void
-}
-
-define void @cmpxchg_i64_acq_rel_acquire(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_acq_rel_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a6, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 4
-; RV32I-NEXT:    addi a5, zero, 2
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_acq_rel_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a6, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 4
-; RV32IA-NEXT:    addi a5, zero, 2
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val acq_rel acquire
-  ret void
-}
-
-define void @cmpxchg_i64_seq_cst_monotonic(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_seq_cst_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a5, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 5
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_seq_cst_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 5
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val seq_cst monotonic
-  ret void
-}
-
-define void @cmpxchg_i64_seq_cst_acquire(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_seq_cst_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a6, a4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a4, zero, 5
-; RV32I-NEXT:    addi a5, zero, 2
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_seq_cst_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a6, a4
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a4, zero, 5
-; RV32IA-NEXT:    addi a5, zero, 2
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val seq_cst acquire
-  ret void
-}
-
-define void @cmpxchg_i64_seq_cst_seq_cst(i64* %ptr, i64 %cmp, i64 %val) {
-; RV32I-LABEL: cmpxchg_i64_seq_cst_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    sw a1, 0(sp)
-; RV32I-NEXT:    mv a1, sp
-; RV32I-NEXT:    addi a5, zero, 5
-; RV32I-NEXT:    mv a2, a3
-; RV32I-NEXT:    mv a3, a4
-; RV32I-NEXT:    mv a4, a5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: cmpxchg_i64_seq_cst_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    sw a2, 4(sp)
-; RV32IA-NEXT:    sw a1, 0(sp)
-; RV32IA-NEXT:    mv a1, sp
-; RV32IA-NEXT:    addi a5, zero, 5
-; RV32IA-NEXT:    mv a2, a3
-; RV32IA-NEXT:    mv a3, a4
-; RV32IA-NEXT:    mv a4, a5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %res = cmpxchg i64* %ptr, i64 %cmp, i64 %val seq_cst seq_cst
-  ret void
-}
diff --git a/test/CodeGen/RISCV/atomic-fence.ll b/test/CodeGen/RISCV/atomic-fence.ll
deleted file mode 100644
index 174977d98d6..00000000000
--- a/test/CodeGen/RISCV/atomic-fence.ll
+++ /dev/null
@@ -1,41 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+a -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define void @fence_acquire() nounwind {
-; RV32I-LABEL: fence_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    fence r, rw
-; RV32I-NEXT:    ret
-  fence acquire
-  ret void
-}
-
-define void @fence_release() nounwind {
-; RV32I-LABEL: fence_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    fence rw, w
-; RV32I-NEXT:    ret
-  fence release
-  ret void
-}
-
-define void @fence_acq_rel() nounwind {
-; RV32I-LABEL: fence_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    fence.tso
-; RV32I-NEXT:    ret
-  fence acq_rel
-  ret void
-}
-
-define void @fence_seq_cst() nounwind {
-; RV32I-LABEL: fence_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    fence rw, rw
-; RV32I-NEXT:    ret
-  fence seq_cst
-  ret void
-}
diff --git a/test/CodeGen/RISCV/atomic-load-store.ll b/test/CodeGen/RISCV/atomic-load-store.ll
deleted file mode 100644
index ba2b594c1c7..00000000000
--- a/test/CodeGen/RISCV/atomic-load-store.ll
+++ /dev/null
@@ -1,668 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+a -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IA %s
-
-define i8 @atomic_load_i8_unordered(i8 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i8_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i8_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lb a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i8, i8* %a unordered, align 1
-  ret i8 %1
-}
-
-define i8 @atomic_load_i8_monotonic(i8 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lb a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i8, i8* %a monotonic, align 1
-  ret i8 %1
-}
-
-define i8 @atomic_load_i8_acquire(i8 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 2
-; RV32I-NEXT:    call __atomic_load_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lb a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i8, i8* %a acquire, align 1
-  ret i8 %1
-}
-
-define i8 @atomic_load_i8_seq_cst(i8 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __atomic_load_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, rw
-; RV32IA-NEXT:    lb a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i8, i8* %a seq_cst, align 1
-  ret i8 %1
-}
-
-define i16 @atomic_load_i16_unordered(i16 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i16_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i16_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lh a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i16, i16* %a unordered, align 2
-  ret i16 %1
-}
-
-define i16 @atomic_load_i16_monotonic(i16 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lh a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i16, i16* %a monotonic, align 2
-  ret i16 %1
-}
-
-define i16 @atomic_load_i16_acquire(i16 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 2
-; RV32I-NEXT:    call __atomic_load_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lh a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i16, i16* %a acquire, align 2
-  ret i16 %1
-}
-
-define i16 @atomic_load_i16_seq_cst(i16 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __atomic_load_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, rw
-; RV32IA-NEXT:    lh a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i16, i16* %a seq_cst, align 2
-  ret i16 %1
-}
-
-define i32 @atomic_load_i32_unordered(i32 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i32_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i32_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lw a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i32, i32* %a unordered, align 4
-  ret i32 %1
-}
-
-define i32 @atomic_load_i32_monotonic(i32 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lw a0, 0(a0)
-; RV32IA-NEXT:    ret
-  %1 = load atomic i32, i32* %a monotonic, align 4
-  ret i32 %1
-}
-
-define i32 @atomic_load_i32_acquire(i32 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 2
-; RV32I-NEXT:    call __atomic_load_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lw a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i32, i32* %a acquire, align 4
-  ret i32 %1
-}
-
-define i32 @atomic_load_i32_seq_cst(i32 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __atomic_load_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, rw
-; RV32IA-NEXT:    lw a0, 0(a0)
-; RV32IA-NEXT:    fence r, rw
-; RV32IA-NEXT:    ret
-  %1 = load atomic i32, i32* %a seq_cst, align 4
-  ret i32 %1
-}
-
-define i64 @atomic_load_i64_unordered(i64 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i64_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i64_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a1, zero
-; RV32IA-NEXT:    call __atomic_load_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = load atomic i64, i64* %a unordered, align 8
-  ret i64 %1
-}
-
-define i64 @atomic_load_i64_monotonic(i64 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    call __atomic_load_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a1, zero
-; RV32IA-NEXT:    call __atomic_load_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = load atomic i64, i64* %a monotonic, align 8
-  ret i64 %1
-}
-
-define i64 @atomic_load_i64_acquire(i64 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 2
-; RV32I-NEXT:    call __atomic_load_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a1, zero, 2
-; RV32IA-NEXT:    call __atomic_load_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = load atomic i64, i64* %a acquire, align 8
-  ret i64 %1
-}
-
-define i64 @atomic_load_i64_seq_cst(i64 *%a) nounwind {
-; RV32I-LABEL: atomic_load_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __atomic_load_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_load_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a1, zero, 5
-; RV32IA-NEXT:    call __atomic_load_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = load atomic i64, i64* %a seq_cst, align 8
-  ret i64 %1
-}
-
-define void @atomic_store_i8_unordered(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomic_store_i8_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i8_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sb a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i8 %b, i8* %a unordered, align 1
-  ret void
-}
-
-define void @atomic_store_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomic_store_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sb a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i8 %b, i8* %a monotonic, align 1
-  ret void
-}
-
-define void @atomic_store_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomic_store_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_store_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sb a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i8 %b, i8* %a release, align 1
-  ret void
-}
-
-define void @atomic_store_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomic_store_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_store_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sb a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i8 %b, i8* %a seq_cst, align 1
-  ret void
-}
-
-define void @atomic_store_i16_unordered(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomic_store_i16_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i16_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sh a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i16 %b, i16* %a unordered, align 2
-  ret void
-}
-
-define void @atomic_store_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomic_store_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sh a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i16 %b, i16* %a monotonic, align 2
-  ret void
-}
-
-define void @atomic_store_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomic_store_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_store_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sh a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i16 %b, i16* %a release, align 2
-  ret void
-}
-
-define void @atomic_store_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomic_store_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_store_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sh a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i16 %b, i16* %a seq_cst, align 2
-  ret void
-}
-
-define void @atomic_store_i32_unordered(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomic_store_i32_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i32_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sw a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i32 %b, i32* %a unordered, align 4
-  ret void
-}
-
-define void @atomic_store_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomic_store_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_store_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    sw a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i32 %b, i32* %a monotonic, align 4
-  ret void
-}
-
-define void @atomic_store_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomic_store_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_store_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sw a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i32 %b, i32* %a release, align 4
-  ret void
-}
-
-define void @atomic_store_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomic_store_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_store_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    fence rw, w
-; RV32IA-NEXT:    sw a1, 0(a0)
-; RV32IA-NEXT:    ret
-  store atomic i32 %b, i32* %a seq_cst, align 4
-  ret void
-}
-
-define void @atomic_store_i64_unordered(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomic_store_i64_unordered:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_store_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i64_unordered:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_store_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  store atomic i64 %b, i64* %a unordered, align 8
-  ret void
-}
-
-define void @atomic_store_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomic_store_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_store_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_store_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  store atomic i64 %b, i64* %a monotonic, align 8
-  ret void
-}
-
-define void @atomic_store_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomic_store_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_store_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_store_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  store atomic i64 %b, i64* %a release, align 8
-  ret void
-}
-
-define void @atomic_store_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomic_store_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_store_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomic_store_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_store_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  store atomic i64 %b, i64* %a seq_cst, align 8
-  ret void
-}
diff --git a/test/CodeGen/RISCV/atomic-rmw.ll b/test/CodeGen/RISCV/atomic-rmw.ll
deleted file mode 100644
index f27afbba7cc..00000000000
--- a/test/CodeGen/RISCV/atomic-rmw.ll
+++ /dev/null
@@ -1,10415 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+a -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IA %s
-
-define i8 @atomicrmw_xchg_i8_monotonic(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB0_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xchg_i8_acquire(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB1_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xchg_i8_release(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB2_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xchg_i8_acq_rel(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB3_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xchg_i8_seq_cst(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_exchange_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB4_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_add_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_add_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB5_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_add_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_add_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB6_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_add_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_add_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB7_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_add_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_add_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB8_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB8_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_add_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_add_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB9_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB9_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_sub_i8_monotonic(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_sub_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_sub_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB10_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB10_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_sub_i8_acquire(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_sub_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_sub_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB11_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB11_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_sub_i8_release(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_sub_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_sub_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB12_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB12_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_sub_i8_acq_rel(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_sub_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_sub_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB13_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_sub_i8_seq_cst(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_sub_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_sub_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB14_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_and_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_and_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    or a1, a3, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_and_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_and_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    or a1, a3, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_and_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_and_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    or a1, a3, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_and_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_and_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    or a1, a3, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_and_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_and_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    or a1, a3, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_nand_i8_monotonic(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_nand_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_nand_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB20_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB20_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_nand_i8_acquire(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_nand_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_nand_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB21_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB21_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_nand_i8_release(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_nand_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_nand_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB22_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB22_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_nand_i8_acq_rel(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_nand_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_nand_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB23_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB23_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_nand_i8_seq_cst(i8* %a, i8 %b) {
-; RV32I-LABEL: atomicrmw_nand_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_nand_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a3, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB24_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a3
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB24_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_or_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_or_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_or_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_or_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_or_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_or_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_or_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_or_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_or_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_or_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xor_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_xor_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xor_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_xor_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xor_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_xor_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xor_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_xor_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_xor_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_xor_1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_max_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 11
-; RV32I-NEXT:  .LBB35_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB35_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB35_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB35_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB35_1 Depth=1
-; RV32I-NEXT:    sb a0, 11(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 11(sp)
-; RV32I-NEXT:    beqz a1, .LBB35_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB35_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB35_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB35_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB35_3: # in Loop: Header=BB35_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB35_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_max_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s5, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB36_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s5, a1, .LBB36_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB36_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB36_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB36_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB36_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB36_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB36_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB36_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB36_3: # in Loop: Header=BB36_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB36_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_max_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB37_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB37_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB37_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB37_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB37_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB37_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB37_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB37_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB37_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB37_3: # in Loop: Header=BB37_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB37_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_max_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 3
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB38_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB38_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB38_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB38_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB38_1 Depth=1
-; RV32I-NEXT:    sb a0, 3(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 3(sp)
-; RV32I-NEXT:    beqz a1, .LBB38_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB38_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB38_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB38_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB38_3: # in Loop: Header=BB38_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB38_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_max_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s5, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB39_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s5, a1, .LBB39_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB39_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB39_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB39_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB39_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB39_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB39_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB39_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB39_3: # in Loop: Header=BB39_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB39_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_min_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 11
-; RV32I-NEXT:  .LBB40_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB40_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB40_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB40_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB40_1 Depth=1
-; RV32I-NEXT:    sb a0, 11(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 11(sp)
-; RV32I-NEXT:    beqz a1, .LBB40_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB40_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB40_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB40_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB40_3: # in Loop: Header=BB40_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB40_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_min_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s5, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB41_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s5, a1, .LBB41_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB41_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB41_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB41_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB41_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB41_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB41_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB41_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB41_3: # in Loop: Header=BB41_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB41_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_min_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB42_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB42_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB42_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB42_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB42_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB42_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB42_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB42_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB42_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB42_3: # in Loop: Header=BB42_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB42_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_min_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s1, a1, 24
-; RV32I-NEXT:    addi s3, sp, 3
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB43_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB43_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB43_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB43_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB43_1 Depth=1
-; RV32I-NEXT:    sb a0, 3(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 3(sp)
-; RV32I-NEXT:    beqz a1, .LBB43_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB43_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB43_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB43_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB43_3: # in Loop: Header=BB43_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB43_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_min_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    srai s5, a1, 24
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB44_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a1, a1, 24
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s5, a1, .LBB44_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB44_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB44_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB44_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB44_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 24
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    addi a4, zero, 255
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 24
-; RV32IA-NEXT:    srai a1, a1, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB44_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB44_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB44_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB44_3: # in Loop: Header=BB44_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB44_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umax_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 11
-; RV32I-NEXT:  .LBB45_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s1, a1, .LBB45_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB45_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB45_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB45_1 Depth=1
-; RV32I-NEXT:    sb a0, 11(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 11(sp)
-; RV32I-NEXT:    beqz a1, .LBB45_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB45_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a3, a1, .LBB45_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB45_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB45_3: # in Loop: Header=BB45_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB45_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umax_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s5, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB46_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s5, a1, .LBB46_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB46_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB46_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB46_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB46_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB46_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a3, a1, .LBB46_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB46_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB46_3: # in Loop: Header=BB46_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB46_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umax_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB47_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s1, a1, .LBB47_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB47_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB47_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB47_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB47_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB47_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a3, a1, .LBB47_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB47_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB47_3: # in Loop: Header=BB47_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB47_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umax_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 3
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB48_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s1, a1, .LBB48_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB48_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB48_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB48_1 Depth=1
-; RV32I-NEXT:    sb a0, 3(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 3(sp)
-; RV32I-NEXT:    beqz a1, .LBB48_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB48_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a3, a1, .LBB48_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB48_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB48_3: # in Loop: Header=BB48_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB48_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umax_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s5, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB49_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s5, a1, .LBB49_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB49_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB49_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB49_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB49_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB49_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a3, a1, .LBB49_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB49_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB49_3: # in Loop: Header=BB49_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB49_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umin_i8_monotonic(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i8_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 11
-; RV32I-NEXT:  .LBB50_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s1, a1, .LBB50_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB50_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB50_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB50_1 Depth=1
-; RV32I-NEXT:    sb a0, 11(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 11(sp)
-; RV32I-NEXT:    beqz a1, .LBB50_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i8_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB50_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a3, .LBB50_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB50_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB50_3: # in Loop: Header=BB50_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB50_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i8* %a, i8 %b monotonic
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umin_i8_acquire(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i8_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s5, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB51_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s5, a1, .LBB51_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB51_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB51_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB51_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB51_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i8_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB51_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a3, .LBB51_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB51_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB51_3: # in Loop: Header=BB51_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB51_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i8* %a, i8 %b acquire
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umin_i8_release(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i8_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB52_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s1, a1, .LBB52_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB52_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB52_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB52_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB52_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i8_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB52_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a3, .LBB52_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB52_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB52_3: # in Loop: Header=BB52_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB52_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i8* %a, i8 %b release
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umin_i8_acq_rel(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i8_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s1, a1, 255
-; RV32I-NEXT:    addi s3, sp, 3
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB53_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s1, a1, .LBB53_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB53_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB53_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB53_1 Depth=1
-; RV32I-NEXT:    sb a0, 3(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 3(sp)
-; RV32I-NEXT:    beqz a1, .LBB53_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i8_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB53_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a3, .LBB53_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB53_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB53_3: # in Loop: Header=BB53_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB53_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i8* %a, i8 %b acq_rel
-  ret i8 %1
-}
-
-define i8 @atomicrmw_umin_i8_seq_cst(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i8_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lbu a0, 0(a0)
-; RV32I-NEXT:    andi s5, a1, 255
-; RV32I-NEXT:    addi s3, sp, 7
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB54_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s5, a1, .LBB54_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB54_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB54_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB54_1 Depth=1
-; RV32I-NEXT:    sb a0, 7(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lb a0, 7(sp)
-; RV32I-NEXT:    beqz a1, .LBB54_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i8_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 255
-; RV32IA-NEXT:    sll a6, a3, a2
-; RV32IA-NEXT:    andi a1, a1, 255
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB54_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a3, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a3, .LBB54_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB54_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB54_3: # in Loop: Header=BB54_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB54_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i8* %a, i8 %b seq_cst
-  ret i8 %1
-}
-
-define i16 @atomicrmw_xchg_i16_monotonic(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB55_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB55_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xchg_i16_acquire(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB56_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB56_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xchg_i16_release(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB57_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB57_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xchg_i16_acq_rel(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB58_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB58_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xchg_i16_seq_cst(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_exchange_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB59_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    add a5, zero, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB59_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_add_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_add_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB60_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB60_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_add_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_add_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB61_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB61_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_add_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_add_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB62_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB62_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_add_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_add_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB63_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB63_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_add_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_add_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB64_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    add a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB64_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_sub_i16_monotonic(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_sub_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_sub_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB65_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB65_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_sub_i16_acquire(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_sub_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_sub_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB66_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB66_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_sub_i16_release(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_sub_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_sub_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB67_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB67_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_sub_i16_acq_rel(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_sub_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_sub_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB68_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB68_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_sub_i16_seq_cst(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_sub_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_sub_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB69_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    sub a5, a4, a1
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB69_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_and_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_and_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    not a2, a2
-; RV32IA-NEXT:    or a1, a2, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_and_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_and_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    not a2, a2
-; RV32IA-NEXT:    or a1, a2, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_and_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_and_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    not a2, a2
-; RV32IA-NEXT:    or a1, a2, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_and_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_and_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    not a2, a2
-; RV32IA-NEXT:    or a1, a2, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_and_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_and_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    not a2, a2
-; RV32IA-NEXT:    or a1, a2, a1
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_nand_i16_monotonic(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_nand_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_nand_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB75_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB75_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_nand_i16_acquire(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_nand_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_nand_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB76_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB76_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_nand_i16_release(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_nand_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_nand_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB77_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB77_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_nand_i16_acq_rel(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_nand_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_nand_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB78_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB78_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_nand_i16_seq_cst(i16* %a, i16 %b) {
-; RV32I-LABEL: atomicrmw_nand_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_nand_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a2, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB79_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a5, a4, a1
-; RV32IA-NEXT:    not a5, a5
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    and a5, a5, a2
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB79_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_or_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_or_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_or_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_or_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_or_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_or_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_or_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_or_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_or_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_or_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xor_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_xor_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xor_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_xor_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xor_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_xor_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xor_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_xor_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_xor_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_xor_2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    srl a0, a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_max_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 10
-; RV32I-NEXT:  .LBB90_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB90_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB90_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB90_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB90_1 Depth=1
-; RV32I-NEXT:    sh a0, 10(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 10(sp)
-; RV32I-NEXT:    beqz a1, .LBB90_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB90_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB90_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB90_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB90_3: # in Loop: Header=BB90_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB90_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_max_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s5, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB91_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s5, a1, .LBB91_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB91_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB91_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB91_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB91_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB91_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB91_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB91_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB91_3: # in Loop: Header=BB91_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB91_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_max_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB92_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB92_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB92_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB92_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB92_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB92_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB92_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB92_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB92_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB92_3: # in Loop: Header=BB92_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB92_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_max_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB93_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s1, a1, .LBB93_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB93_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB93_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB93_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB93_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB93_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB93_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB93_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB93_3: # in Loop: Header=BB93_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB93_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_max_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s5, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB94_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    blt s5, a1, .LBB94_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB94_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB94_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB94_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB94_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB94_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a4, a1, .LBB94_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB94_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB94_3: # in Loop: Header=BB94_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB94_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_min_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 10
-; RV32I-NEXT:  .LBB95_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB95_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB95_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB95_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB95_1 Depth=1
-; RV32I-NEXT:    sh a0, 10(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 10(sp)
-; RV32I-NEXT:    beqz a1, .LBB95_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB95_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB95_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB95_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB95_3: # in Loop: Header=BB95_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB95_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_min_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s5, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB96_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s5, a1, .LBB96_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB96_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB96_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB96_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB96_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB96_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB96_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB96_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB96_3: # in Loop: Header=BB96_1 Depth=1
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB96_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_min_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB97_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB97_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB97_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB97_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB97_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB97_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB97_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB97_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB97_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB97_3: # in Loop: Header=BB97_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB97_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_min_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s1, a1, 16
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB98_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s1, a1, .LBB98_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB98_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB98_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB98_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB98_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB98_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB98_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB98_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB98_3: # in Loop: Header=BB98_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB98_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_min_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    slli a1, a1, 16
-; RV32I-NEXT:    srai s5, a1, 16
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB99_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a1, a1, 16
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bge s5, a1, .LBB99_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB99_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB99_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB99_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB99_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    slli a2, a0, 3
-; RV32IA-NEXT:    andi a2, a2, 24
-; RV32IA-NEXT:    addi a3, zero, 16
-; RV32IA-NEXT:    sub a6, a3, a2
-; RV32IA-NEXT:    lui a4, 16
-; RV32IA-NEXT:    addi a4, a4, -1
-; RV32IA-NEXT:    sll a7, a4, a2
-; RV32IA-NEXT:    slli a1, a1, 16
-; RV32IA-NEXT:    srai a1, a1, 16
-; RV32IA-NEXT:    sll a1, a1, a2
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB99_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a5, (a0)
-; RV32IA-NEXT:    and a4, a5, a7
-; RV32IA-NEXT:    mv a3, a5
-; RV32IA-NEXT:    sll a4, a4, a6
-; RV32IA-NEXT:    sra a4, a4, a6
-; RV32IA-NEXT:    bge a1, a4, .LBB99_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB99_1 Depth=1
-; RV32IA-NEXT:    xor a3, a5, a1
-; RV32IA-NEXT:    and a3, a3, a7
-; RV32IA-NEXT:    xor a3, a5, a3
-; RV32IA-NEXT:  .LBB99_3: # in Loop: Header=BB99_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB99_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a5, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umax_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s5, s2, s1
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:  .LBB100_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s5, a1, .LBB100_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB100_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB100_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB100_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB100_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB100_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a2, a1, .LBB100_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB100_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB100_3: # in Loop: Header=BB100_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB100_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umax_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s5, a1, -1
-; RV32I-NEXT:    and s6, s2, s5
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB101_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s5
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s6, a1, .LBB101_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB101_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB101_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB101_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB101_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB101_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a2, a1, .LBB101_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB101_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB101_3: # in Loop: Header=BB101_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB101_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umax_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s6, s2, s1
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB102_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s6, a1, .LBB102_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB102_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB102_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB102_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB102_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB102_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a2, a1, .LBB102_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB102_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB102_3: # in Loop: Header=BB102_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB102_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umax_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    sw s7, 16(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s7, s2, s1
-; RV32I-NEXT:    addi s3, sp, 14
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB103_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s7, a1, .LBB103_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB103_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB103_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB103_1 Depth=1
-; RV32I-NEXT:    sh a0, 14(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 14(sp)
-; RV32I-NEXT:    beqz a1, .LBB103_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s7, 16(sp)
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB103_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a2, a1, .LBB103_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB103_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB103_3: # in Loop: Header=BB103_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB103_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umax_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s5, a1, -1
-; RV32I-NEXT:    and s6, s2, s5
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB104_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s5
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bltu s6, a1, .LBB104_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB104_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB104_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB104_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB104_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB104_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a2, a1, .LBB104_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB104_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB104_3: # in Loop: Header=BB104_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB104_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umin_i16_monotonic(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i16_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s5, s2, s1
-; RV32I-NEXT:    addi s3, sp, 6
-; RV32I-NEXT:  .LBB105_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s5, a1, .LBB105_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB105_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB105_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB105_1 Depth=1
-; RV32I-NEXT:    sh a0, 6(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 6(sp)
-; RV32I-NEXT:    beqz a1, .LBB105_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i16_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB105_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a2, .LBB105_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB105_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB105_3: # in Loop: Header=BB105_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB105_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i16* %a, i16 %b monotonic
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umin_i16_acquire(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i16_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s5, a1, -1
-; RV32I-NEXT:    and s6, s2, s5
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s1, zero, 2
-; RV32I-NEXT:  .LBB106_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s5
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s6, a1, .LBB106_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB106_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB106_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB106_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB106_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i16_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB106_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a2, .LBB106_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB106_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB106_3: # in Loop: Header=BB106_1 Depth=1
-; RV32IA-NEXT:    sc.w a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB106_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i16* %a, i16 %b acquire
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umin_i16_release(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i16_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s5, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s6, s2, s1
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB107_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s6, a1, .LBB107_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB107_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB107_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB107_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s5
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB107_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i16_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB107_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a2, .LBB107_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB107_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB107_3: # in Loop: Header=BB107_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB107_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i16* %a, i16 %b release
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umin_i16_acq_rel(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i16_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    sw s7, 16(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s6, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s1, a1, -1
-; RV32I-NEXT:    and s7, s2, s1
-; RV32I-NEXT:    addi s3, sp, 14
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB108_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s7, a1, .LBB108_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB108_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB108_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB108_1 Depth=1
-; RV32I-NEXT:    sh a0, 14(sp)
-; RV32I-NEXT:    mv a0, s6
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 14(sp)
-; RV32I-NEXT:    beqz a1, .LBB108_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s7, 16(sp)
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i16_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB108_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a2, .LBB108_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB108_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB108_3: # in Loop: Header=BB108_1 Depth=1
-; RV32IA-NEXT:    sc.w.rl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB108_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i16* %a, i16 %b acq_rel
-  ret i16 %1
-}
-
-define i16 @atomicrmw_umin_i16_seq_cst(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i16_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    lhu a0, 0(a0)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi s5, a1, -1
-; RV32I-NEXT:    and s6, s2, s5
-; RV32I-NEXT:    addi s3, sp, 2
-; RV32I-NEXT:    addi s1, zero, 5
-; RV32I-NEXT:  .LBB109_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    and a1, a0, s5
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    bgeu s6, a1, .LBB109_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB109_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB109_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB109_1 Depth=1
-; RV32I-NEXT:    sh a0, 2(sp)
-; RV32I-NEXT:    mv a0, s4
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    call __atomic_compare_exchange_2
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    lh a0, 2(sp)
-; RV32I-NEXT:    beqz a1, .LBB109_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i16_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    lui a2, 16
-; RV32IA-NEXT:    addi a2, a2, -1
-; RV32IA-NEXT:    and a1, a1, a2
-; RV32IA-NEXT:    slli a3, a0, 3
-; RV32IA-NEXT:    andi a3, a3, 24
-; RV32IA-NEXT:    sll a6, a2, a3
-; RV32IA-NEXT:    sll a1, a1, a3
-; RV32IA-NEXT:    andi a0, a0, -4
-; RV32IA-NEXT:  .LBB109_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a4, (a0)
-; RV32IA-NEXT:    and a2, a4, a6
-; RV32IA-NEXT:    mv a5, a4
-; RV32IA-NEXT:    bgeu a1, a2, .LBB109_3
-; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB109_1 Depth=1
-; RV32IA-NEXT:    xor a5, a4, a1
-; RV32IA-NEXT:    and a5, a5, a6
-; RV32IA-NEXT:    xor a5, a4, a5
-; RV32IA-NEXT:  .LBB109_3: # in Loop: Header=BB109_1 Depth=1
-; RV32IA-NEXT:    sc.w.aqrl a5, a5, (a0)
-; RV32IA-NEXT:    bnez a5, .LBB109_1
-; RV32IA-NEXT:  # %bb.4:
-; RV32IA-NEXT:    srl a0, a4, a3
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i16* %a, i16 %b seq_cst
-  ret i16 %1
-}
-
-define i32 @atomicrmw_xchg_i32_monotonic(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoswap.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xchg_i32_acquire(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoswap.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xchg_i32_release(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoswap.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xchg_i32_acq_rel(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xchg_i32_seq_cst(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_exchange_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_add_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_add_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoadd.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_add_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_add_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoadd.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_add_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_add_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoadd.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_add_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_add_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_add_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_add_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_sub_i32_monotonic(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_sub_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_sub_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    neg a1, a1
-; RV32IA-NEXT:    amoadd.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_sub_i32_acquire(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_sub_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_sub_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    neg a1, a1
-; RV32IA-NEXT:    amoadd.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_sub_i32_release(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_sub_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_sub_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    neg a1, a1
-; RV32IA-NEXT:    amoadd.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_sub_i32_acq_rel(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_sub_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_sub_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    neg a1, a1
-; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_sub_i32_seq_cst(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_sub_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_sub_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    neg a1, a1
-; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_and_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_and_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoand.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_and_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_and_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoand.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_and_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_and_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoand.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_and_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_and_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_and_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_and_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_nand_i32_monotonic(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_nand_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_nand_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB130_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a2, (a0)
-; RV32IA-NEXT:    and a3, a2, a1
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB130_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_nand_i32_acquire(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_nand_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_nand_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB131_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a2, (a0)
-; RV32IA-NEXT:    and a3, a2, a1
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    sc.w a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB131_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_nand_i32_release(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_nand_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_nand_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB132_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w a2, (a0)
-; RV32IA-NEXT:    and a3, a2, a1
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB132_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_nand_i32_acq_rel(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_nand_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_nand_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB133_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aq a2, (a0)
-; RV32IA-NEXT:    and a3, a2, a1
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB133_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_nand_i32_seq_cst(i32* %a, i32 %b) {
-; RV32I-LABEL: atomicrmw_nand_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_nand_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:  .LBB134_1: # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    lr.w.aqrl a2, (a0)
-; RV32IA-NEXT:    and a3, a2, a1
-; RV32IA-NEXT:    not a3, a3
-; RV32IA-NEXT:    sc.w.aqrl a3, a3, (a0)
-; RV32IA-NEXT:    bnez a3, .LBB134_1
-; RV32IA-NEXT:  # %bb.2:
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_or_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_or_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoor.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_or_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_or_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_or_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_or_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_or_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_or_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_or_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_or_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xor_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    call __atomic_fetch_xor_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoxor.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xor_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_xor_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoxor.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xor_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_xor_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoxor.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xor_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_xor_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_xor_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_xor_4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_max_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 12
-; RV32I-NEXT:  .LBB145_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 12(sp)
-; RV32I-NEXT:    blt s1, a2, .LBB145_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB145_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB145_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB145_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB145_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomax.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_max_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 2
-; RV32I-NEXT:  .LBB146_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    blt s1, a2, .LBB146_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB146_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB146_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB146_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB146_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomax.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_max_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB147_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    blt s1, a2, .LBB147_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB147_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB147_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB147_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB147_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomax.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_max_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 4
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB148_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    blt s1, a2, .LBB148_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB148_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB148_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB148_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 4(sp)
-; RV32I-NEXT:    beqz a0, .LBB148_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_max_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 5
-; RV32I-NEXT:  .LBB149_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    blt s1, a2, .LBB149_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB149_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB149_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB149_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB149_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_min_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 12
-; RV32I-NEXT:  .LBB150_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 12(sp)
-; RV32I-NEXT:    bge s1, a2, .LBB150_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB150_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB150_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB150_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB150_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomin.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_min_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 2
-; RV32I-NEXT:  .LBB151_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bge s1, a2, .LBB151_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB151_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB151_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB151_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB151_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomin.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_min_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB152_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bge s1, a2, .LBB152_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB152_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB152_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB152_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB152_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomin.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_min_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 4
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB153_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    bge s1, a2, .LBB153_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB153_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB153_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB153_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 4(sp)
-; RV32I-NEXT:    beqz a0, .LBB153_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_min_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 5
-; RV32I-NEXT:  .LBB154_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bge s1, a2, .LBB154_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB154_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB154_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB154_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB154_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umax_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 12
-; RV32I-NEXT:  .LBB155_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 12(sp)
-; RV32I-NEXT:    bltu s1, a2, .LBB155_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB155_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB155_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB155_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB155_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomaxu.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umax_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 2
-; RV32I-NEXT:  .LBB156_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bltu s1, a2, .LBB156_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB156_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB156_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB156_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB156_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomaxu.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umax_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB157_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bltu s1, a2, .LBB157_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB157_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB157_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB157_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB157_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomaxu.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umax_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 4
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB158_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    bltu s1, a2, .LBB158_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB158_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB158_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB158_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 4(sp)
-; RV32I-NEXT:    beqz a0, .LBB158_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umax_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 5
-; RV32I-NEXT:  .LBB159_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bltu s1, a2, .LBB159_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB159_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB159_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB159_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB159_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umin_i32_monotonic(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i32_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 12
-; RV32I-NEXT:  .LBB160_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 12(sp)
-; RV32I-NEXT:    bgeu s1, a2, .LBB160_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB160_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB160_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB160_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB160_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i32_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amominu.w a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i32* %a, i32 %b monotonic
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umin_i32_acquire(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i32_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 2
-; RV32I-NEXT:  .LBB161_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bgeu s1, a2, .LBB161_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB161_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB161_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB161_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB161_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i32_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amominu.w.aq a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i32* %a, i32 %b acquire
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umin_i32_release(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i32_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 3
-; RV32I-NEXT:  .LBB162_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bgeu s1, a2, .LBB162_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB162_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB162_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB162_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB162_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i32_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amominu.w.rl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i32* %a, i32 %b release
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umin_i32_acq_rel(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i32_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 4
-; RV32I-NEXT:    addi s4, zero, 4
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB163_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    bgeu s1, a2, .LBB163_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB163_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB163_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB163_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 4(sp)
-; RV32I-NEXT:    beqz a0, .LBB163_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i32_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i32* %a, i32 %b acq_rel
-  ret i32 %1
-}
-
-define i32 @atomicrmw_umin_i32_seq_cst(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i32_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a1
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s3, sp, 8
-; RV32I-NEXT:    addi s4, zero, 5
-; RV32I-NEXT:  .LBB164_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bgeu s1, a2, .LBB164_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB164_1 Depth=1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:  .LBB164_3: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB164_1 Depth=1
-; RV32I-NEXT:    mv a0, s2
-; RV32I-NEXT:    mv a1, s3
-; RV32I-NEXT:    mv a3, s4
-; RV32I-NEXT:    mv a4, s4
-; RV32I-NEXT:    call __atomic_compare_exchange_4
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB164_1
-; RV32I-NEXT:  # %bb.4: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i32_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i32* %a, i32 %b seq_cst
-  ret i32 %1
-}
-
-define i64 @atomicrmw_xchg_i64_monotonic(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xchg_i64_acquire(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xchg_i64_release(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xchg_i64_acq_rel(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xchg_i64_seq_cst(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_xchg_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_exchange_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xchg_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_exchange_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xchg i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_add_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_add_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_add_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_add_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_add_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_add_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_add_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_add_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_add_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_add_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_add_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_add_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_add_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_add_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_add_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_add_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_add_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw add i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_sub_i64_monotonic(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_sub_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_sub_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_sub_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_sub_i64_acquire(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_sub_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_sub_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_sub_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_sub_i64_release(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_sub_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_sub_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_sub_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_sub_i64_acq_rel(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_sub_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_sub_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_sub_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_sub_i64_seq_cst(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_sub_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_sub_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_sub_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_sub_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw sub i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_and_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_and_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_and_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_and_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_and_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_and_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_and_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_and_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_and_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_and_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_and_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_and_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_and_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_and_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_and_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_and_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_and_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw and i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_nand_i64_monotonic(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_nand_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_nand_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_nand_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_nand_i64_acquire(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_nand_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_nand_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_nand_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_nand_i64_release(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_nand_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_nand_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_nand_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_nand_i64_acq_rel(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_nand_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_nand_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_nand_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_nand_i64_seq_cst(i64* %a, i64 %b) {
-; RV32I-LABEL: atomicrmw_nand_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_nand_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_nand_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_nand_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw nand i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_or_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_or_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_or_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_or_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_or_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_or_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_or_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_or_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_or_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_or_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_or_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_or_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_or_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_or_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_or_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_or_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_or_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw or i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xor_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __atomic_fetch_xor_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    mv a3, zero
-; RV32IA-NEXT:    call __atomic_fetch_xor_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xor_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 2
-; RV32I-NEXT:    call __atomic_fetch_xor_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 2
-; RV32IA-NEXT:    call __atomic_fetch_xor_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xor_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    call __atomic_fetch_xor_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 3
-; RV32IA-NEXT:    call __atomic_fetch_xor_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xor_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 4
-; RV32I-NEXT:    call __atomic_fetch_xor_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 4
-; RV32IA-NEXT:    call __atomic_fetch_xor_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_xor_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_xor_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a3, zero, 5
-; RV32I-NEXT:    call __atomic_fetch_xor_8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_xor_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -16
-; RV32IA-NEXT:    sw ra, 12(sp)
-; RV32IA-NEXT:    addi a3, zero, 5
-; RV32IA-NEXT:    call __atomic_fetch_xor_8
-; RV32IA-NEXT:    lw ra, 12(sp)
-; RV32IA-NEXT:    addi sp, sp, 16
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw xor i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_max_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:  .LBB200_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB200_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB200_4
-; RV32I-NEXT:    j .LBB200_5
-; RV32I-NEXT:  .LBB200_3: # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB200_5
-; RV32I-NEXT:  .LBB200_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB200_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB200_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB200_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB200_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:  .LBB200_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB200_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB200_4
-; RV32IA-NEXT:    j .LBB200_5
-; RV32IA-NEXT:  .LBB200_3: # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB200_5
-; RV32IA-NEXT:  .LBB200_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB200_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB200_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB200_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB200_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, zero
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB200_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_max_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB201_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB201_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB201_4
-; RV32I-NEXT:    j .LBB201_5
-; RV32I-NEXT:  .LBB201_3: # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB201_5
-; RV32I-NEXT:  .LBB201_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB201_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB201_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB201_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB201_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 2
-; RV32IA-NEXT:  .LBB201_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB201_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB201_4
-; RV32IA-NEXT:    j .LBB201_5
-; RV32IA-NEXT:  .LBB201_3: # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB201_5
-; RV32IA-NEXT:  .LBB201_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB201_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB201_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB201_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB201_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB201_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_max_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 3
-; RV32I-NEXT:  .LBB202_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB202_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB202_4
-; RV32I-NEXT:    j .LBB202_5
-; RV32I-NEXT:  .LBB202_3: # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB202_5
-; RV32I-NEXT:  .LBB202_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB202_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB202_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB202_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB202_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 3
-; RV32IA-NEXT:  .LBB202_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB202_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB202_4
-; RV32IA-NEXT:    j .LBB202_5
-; RV32IA-NEXT:  .LBB202_3: # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB202_5
-; RV32IA-NEXT:  .LBB202_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB202_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB202_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB202_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB202_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB202_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_max_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s4, sp, 8
-; RV32I-NEXT:    addi s5, zero, 4
-; RV32I-NEXT:    addi s6, zero, 2
-; RV32I-NEXT:  .LBB203_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB203_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB203_4
-; RV32I-NEXT:    j .LBB203_5
-; RV32I-NEXT:  .LBB203_3: # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bnez a0, .LBB203_5
-; RV32I-NEXT:  .LBB203_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB203_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB203_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB203_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 12(sp)
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB203_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -48
-; RV32IA-NEXT:    sw ra, 44(sp)
-; RV32IA-NEXT:    sw s1, 40(sp)
-; RV32IA-NEXT:    sw s2, 36(sp)
-; RV32IA-NEXT:    sw s3, 32(sp)
-; RV32IA-NEXT:    sw s4, 28(sp)
-; RV32IA-NEXT:    sw s5, 24(sp)
-; RV32IA-NEXT:    sw s6, 20(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    addi s4, sp, 8
-; RV32IA-NEXT:    addi s5, zero, 4
-; RV32IA-NEXT:    addi s6, zero, 2
-; RV32IA-NEXT:  .LBB203_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB203_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB203_4
-; RV32IA-NEXT:    j .LBB203_5
-; RV32IA-NEXT:  .LBB203_3: # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    bnez a0, .LBB203_5
-; RV32IA-NEXT:  .LBB203_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB203_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB203_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB203_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB203_1 Depth=1
-; RV32IA-NEXT:    sw a1, 12(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 12(sp)
-; RV32IA-NEXT:    lw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB203_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s6, 20(sp)
-; RV32IA-NEXT:    lw s5, 24(sp)
-; RV32IA-NEXT:    lw s4, 28(sp)
-; RV32IA-NEXT:    lw s3, 32(sp)
-; RV32IA-NEXT:    lw s2, 36(sp)
-; RV32IA-NEXT:    lw s1, 40(sp)
-; RV32IA-NEXT:    lw ra, 44(sp)
-; RV32IA-NEXT:    addi sp, sp, 48
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_max_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_max_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 5
-; RV32I-NEXT:  .LBB204_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB204_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB204_4
-; RV32I-NEXT:    j .LBB204_5
-; RV32I-NEXT:  .LBB204_3: # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB204_5
-; RV32I-NEXT:  .LBB204_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB204_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB204_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB204_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB204_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_max_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 5
-; RV32IA-NEXT:  .LBB204_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB204_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB204_4
-; RV32IA-NEXT:    j .LBB204_5
-; RV32IA-NEXT:  .LBB204_3: # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB204_5
-; RV32IA-NEXT:  .LBB204_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB204_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB204_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB204_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB204_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB204_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw max i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_min_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:  .LBB205_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB205_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    j .LBB205_4
-; RV32I-NEXT:  .LBB205_3: # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB205_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB205_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB205_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB205_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB205_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB205_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:  .LBB205_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB205_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    j .LBB205_4
-; RV32IA-NEXT:  .LBB205_3: # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB205_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB205_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB205_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB205_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB205_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB205_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, zero
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB205_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_min_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB206_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB206_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    j .LBB206_4
-; RV32I-NEXT:  .LBB206_3: # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB206_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB206_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB206_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB206_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB206_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB206_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 2
-; RV32IA-NEXT:  .LBB206_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB206_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    j .LBB206_4
-; RV32IA-NEXT:  .LBB206_3: # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB206_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB206_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB206_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB206_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB206_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB206_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB206_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_min_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 3
-; RV32I-NEXT:  .LBB207_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB207_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    j .LBB207_4
-; RV32I-NEXT:  .LBB207_3: # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB207_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB207_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB207_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB207_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB207_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB207_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 3
-; RV32IA-NEXT:  .LBB207_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB207_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    j .LBB207_4
-; RV32IA-NEXT:  .LBB207_3: # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB207_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB207_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB207_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB207_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB207_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB207_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB207_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_min_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s4, sp, 8
-; RV32I-NEXT:    addi s5, zero, 4
-; RV32I-NEXT:    addi s6, zero, 2
-; RV32I-NEXT:  .LBB208_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB208_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    j .LBB208_4
-; RV32I-NEXT:  .LBB208_3: # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB208_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bnez a0, .LBB208_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB208_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB208_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB208_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 12(sp)
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB208_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -48
-; RV32IA-NEXT:    sw ra, 44(sp)
-; RV32IA-NEXT:    sw s1, 40(sp)
-; RV32IA-NEXT:    sw s2, 36(sp)
-; RV32IA-NEXT:    sw s3, 32(sp)
-; RV32IA-NEXT:    sw s4, 28(sp)
-; RV32IA-NEXT:    sw s5, 24(sp)
-; RV32IA-NEXT:    sw s6, 20(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    addi s4, sp, 8
-; RV32IA-NEXT:    addi s5, zero, 4
-; RV32IA-NEXT:    addi s6, zero, 2
-; RV32IA-NEXT:  .LBB208_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB208_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    j .LBB208_4
-; RV32IA-NEXT:  .LBB208_3: # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB208_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    bnez a0, .LBB208_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB208_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB208_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB208_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB208_1 Depth=1
-; RV32IA-NEXT:    sw a1, 12(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 12(sp)
-; RV32IA-NEXT:    lw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB208_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s6, 20(sp)
-; RV32IA-NEXT:    lw s5, 24(sp)
-; RV32IA-NEXT:    lw s4, 28(sp)
-; RV32IA-NEXT:    lw s3, 32(sp)
-; RV32IA-NEXT:    lw s2, 36(sp)
-; RV32IA-NEXT:    lw s1, 40(sp)
-; RV32IA-NEXT:    lw ra, 44(sp)
-; RV32IA-NEXT:    addi sp, sp, 48
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_min_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_min_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 5
-; RV32I-NEXT:  .LBB209_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB209_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    slt a0, s1, a1
-; RV32I-NEXT:    j .LBB209_4
-; RV32I-NEXT:  .LBB209_3: # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB209_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB209_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB209_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB209_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB209_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB209_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_min_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 5
-; RV32IA-NEXT:  .LBB209_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB209_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    slt a0, s1, a1
-; RV32IA-NEXT:    j .LBB209_4
-; RV32IA-NEXT:  .LBB209_3: # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB209_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB209_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB209_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB209_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB209_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB209_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB209_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw min i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umax_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:  .LBB210_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB210_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB210_4
-; RV32I-NEXT:    j .LBB210_5
-; RV32I-NEXT:  .LBB210_3: # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB210_5
-; RV32I-NEXT:  .LBB210_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB210_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB210_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB210_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB210_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:  .LBB210_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB210_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB210_4
-; RV32IA-NEXT:    j .LBB210_5
-; RV32IA-NEXT:  .LBB210_3: # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB210_5
-; RV32IA-NEXT:  .LBB210_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB210_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB210_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB210_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB210_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, zero
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB210_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umax_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB211_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB211_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB211_4
-; RV32I-NEXT:    j .LBB211_5
-; RV32I-NEXT:  .LBB211_3: # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB211_5
-; RV32I-NEXT:  .LBB211_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB211_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB211_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB211_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB211_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 2
-; RV32IA-NEXT:  .LBB211_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB211_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB211_4
-; RV32IA-NEXT:    j .LBB211_5
-; RV32IA-NEXT:  .LBB211_3: # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB211_5
-; RV32IA-NEXT:  .LBB211_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB211_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB211_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB211_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB211_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB211_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umax_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 3
-; RV32I-NEXT:  .LBB212_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB212_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB212_4
-; RV32I-NEXT:    j .LBB212_5
-; RV32I-NEXT:  .LBB212_3: # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB212_5
-; RV32I-NEXT:  .LBB212_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB212_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB212_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB212_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB212_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 3
-; RV32IA-NEXT:  .LBB212_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB212_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB212_4
-; RV32IA-NEXT:    j .LBB212_5
-; RV32IA-NEXT:  .LBB212_3: # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB212_5
-; RV32IA-NEXT:  .LBB212_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB212_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB212_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB212_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB212_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB212_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umax_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s4, sp, 8
-; RV32I-NEXT:    addi s5, zero, 4
-; RV32I-NEXT:    addi s6, zero, 2
-; RV32I-NEXT:  .LBB213_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB213_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB213_4
-; RV32I-NEXT:    j .LBB213_5
-; RV32I-NEXT:  .LBB213_3: # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bnez a0, .LBB213_5
-; RV32I-NEXT:  .LBB213_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB213_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB213_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB213_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 12(sp)
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB213_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -48
-; RV32IA-NEXT:    sw ra, 44(sp)
-; RV32IA-NEXT:    sw s1, 40(sp)
-; RV32IA-NEXT:    sw s2, 36(sp)
-; RV32IA-NEXT:    sw s3, 32(sp)
-; RV32IA-NEXT:    sw s4, 28(sp)
-; RV32IA-NEXT:    sw s5, 24(sp)
-; RV32IA-NEXT:    sw s6, 20(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    addi s4, sp, 8
-; RV32IA-NEXT:    addi s5, zero, 4
-; RV32IA-NEXT:    addi s6, zero, 2
-; RV32IA-NEXT:  .LBB213_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB213_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB213_4
-; RV32IA-NEXT:    j .LBB213_5
-; RV32IA-NEXT:  .LBB213_3: # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    bnez a0, .LBB213_5
-; RV32IA-NEXT:  .LBB213_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB213_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB213_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB213_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB213_1 Depth=1
-; RV32IA-NEXT:    sw a1, 12(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 12(sp)
-; RV32IA-NEXT:    lw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB213_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s6, 20(sp)
-; RV32IA-NEXT:    lw s5, 24(sp)
-; RV32IA-NEXT:    lw s4, 28(sp)
-; RV32IA-NEXT:    lw s3, 32(sp)
-; RV32IA-NEXT:    lw s2, 36(sp)
-; RV32IA-NEXT:    lw s1, 40(sp)
-; RV32IA-NEXT:    lw ra, 44(sp)
-; RV32IA-NEXT:    addi sp, sp, 48
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umax_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umax_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 5
-; RV32I-NEXT:  .LBB214_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB214_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB214_4
-; RV32I-NEXT:    j .LBB214_5
-; RV32I-NEXT:  .LBB214_3: # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB214_5
-; RV32I-NEXT:  .LBB214_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB214_5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB214_7
-; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB214_7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB214_1
-; RV32I-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umax_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 5
-; RV32IA-NEXT:  .LBB214_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB214_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB214_4
-; RV32IA-NEXT:    j .LBB214_5
-; RV32IA-NEXT:  .LBB214_3: # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB214_5
-; RV32IA-NEXT:  .LBB214_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB214_5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB214_7
-; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB214_7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB214_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB214_1
-; RV32IA-NEXT:  # %bb.8: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umax i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umin_i64_monotonic(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i64_monotonic:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:  .LBB215_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB215_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    j .LBB215_4
-; RV32I-NEXT:  .LBB215_3: # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB215_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB215_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB215_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB215_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB215_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB215_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i64_monotonic:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:  .LBB215_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB215_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    j .LBB215_4
-; RV32IA-NEXT:  .LBB215_3: # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB215_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB215_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB215_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB215_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB215_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB215_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, zero
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB215_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i64* %a, i64 %b monotonic
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umin_i64_acquire(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i64_acquire:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 2
-; RV32I-NEXT:  .LBB216_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB216_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    j .LBB216_4
-; RV32I-NEXT:  .LBB216_3: # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB216_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB216_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB216_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB216_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB216_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB216_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i64_acquire:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 2
-; RV32IA-NEXT:  .LBB216_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB216_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    j .LBB216_4
-; RV32IA-NEXT:  .LBB216_3: # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB216_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB216_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB216_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB216_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB216_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB216_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB216_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i64* %a, i64 %b acquire
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umin_i64_release(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i64_release:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 3
-; RV32I-NEXT:  .LBB217_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB217_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    j .LBB217_4
-; RV32I-NEXT:  .LBB217_3: # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB217_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB217_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB217_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB217_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB217_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, zero
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB217_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i64_release:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 3
-; RV32IA-NEXT:  .LBB217_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB217_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    j .LBB217_4
-; RV32IA-NEXT:  .LBB217_3: # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB217_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB217_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB217_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB217_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB217_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB217_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, zero
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB217_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i64* %a, i64 %b release
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umin_i64_acq_rel(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i64_acq_rel:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi s4, sp, 8
-; RV32I-NEXT:    addi s5, zero, 4
-; RV32I-NEXT:    addi s6, zero, 2
-; RV32I-NEXT:  .LBB218_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB218_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    j .LBB218_4
-; RV32I-NEXT:  .LBB218_3: # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB218_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    bnez a0, .LBB218_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB218_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB218_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB218_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s6
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 12(sp)
-; RV32I-NEXT:    lw a2, 8(sp)
-; RV32I-NEXT:    beqz a0, .LBB218_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i64_acq_rel:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -48
-; RV32IA-NEXT:    sw ra, 44(sp)
-; RV32IA-NEXT:    sw s1, 40(sp)
-; RV32IA-NEXT:    sw s2, 36(sp)
-; RV32IA-NEXT:    sw s3, 32(sp)
-; RV32IA-NEXT:    sw s4, 28(sp)
-; RV32IA-NEXT:    sw s5, 24(sp)
-; RV32IA-NEXT:    sw s6, 20(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    addi s4, sp, 8
-; RV32IA-NEXT:    addi s5, zero, 4
-; RV32IA-NEXT:    addi s6, zero, 2
-; RV32IA-NEXT:  .LBB218_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB218_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    j .LBB218_4
-; RV32IA-NEXT:  .LBB218_3: # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB218_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 8(sp)
-; RV32IA-NEXT:    bnez a0, .LBB218_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB218_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB218_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB218_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB218_1 Depth=1
-; RV32IA-NEXT:    sw a1, 12(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s6
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 12(sp)
-; RV32IA-NEXT:    lw a2, 8(sp)
-; RV32IA-NEXT:    beqz a0, .LBB218_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s6, 20(sp)
-; RV32IA-NEXT:    lw s5, 24(sp)
-; RV32IA-NEXT:    lw s4, 28(sp)
-; RV32IA-NEXT:    lw s3, 32(sp)
-; RV32IA-NEXT:    lw s2, 36(sp)
-; RV32IA-NEXT:    lw s1, 40(sp)
-; RV32IA-NEXT:    lw ra, 44(sp)
-; RV32IA-NEXT:    addi sp, sp, 48
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i64* %a, i64 %b acq_rel
-  ret i64 %1
-}
-
-define i64 @atomicrmw_umin_i64_seq_cst(i64 *%a, i64 %b) nounwind {
-; RV32I-LABEL: atomicrmw_umin_i64_seq_cst:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    mv s1, a2
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    mv s4, sp
-; RV32I-NEXT:    addi s5, zero, 5
-; RV32I-NEXT:  .LBB219_1: # %atomicrmw.start
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    beq a1, s1, .LBB219_3
-; RV32I-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    sltu a0, s1, a1
-; RV32I-NEXT:    j .LBB219_4
-; RV32I-NEXT:  .LBB219_3: # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    sltu a0, s2, a2
-; RV32I-NEXT:  .LBB219_4: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    sw a2, 0(sp)
-; RV32I-NEXT:    bnez a0, .LBB219_6
-; RV32I-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    mv a2, s2
-; RV32I-NEXT:  .LBB219_6: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    mv a3, a1
-; RV32I-NEXT:    bnez a0, .LBB219_8
-; RV32I-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:  .LBB219_8: # %atomicrmw.start
-; RV32I-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    mv a0, s3
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    mv a4, s5
-; RV32I-NEXT:    mv a5, s5
-; RV32I-NEXT:    call __atomic_compare_exchange_8
-; RV32I-NEXT:    lw a1, 4(sp)
-; RV32I-NEXT:    lw a2, 0(sp)
-; RV32I-NEXT:    beqz a0, .LBB219_1
-; RV32I-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-;
-; RV32IA-LABEL: atomicrmw_umin_i64_seq_cst:
-; RV32IA:       # %bb.0:
-; RV32IA-NEXT:    addi sp, sp, -32
-; RV32IA-NEXT:    sw ra, 28(sp)
-; RV32IA-NEXT:    sw s1, 24(sp)
-; RV32IA-NEXT:    sw s2, 20(sp)
-; RV32IA-NEXT:    sw s3, 16(sp)
-; RV32IA-NEXT:    sw s4, 12(sp)
-; RV32IA-NEXT:    sw s5, 8(sp)
-; RV32IA-NEXT:    mv s1, a2
-; RV32IA-NEXT:    mv s2, a1
-; RV32IA-NEXT:    mv s3, a0
-; RV32IA-NEXT:    lw a1, 4(a0)
-; RV32IA-NEXT:    lw a2, 0(a0)
-; RV32IA-NEXT:    mv s4, sp
-; RV32IA-NEXT:    addi s5, zero, 5
-; RV32IA-NEXT:  .LBB219_1: # %atomicrmw.start
-; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32IA-NEXT:    beq a1, s1, .LBB219_3
-; RV32IA-NEXT:  # %bb.2: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s1, a1
-; RV32IA-NEXT:    j .LBB219_4
-; RV32IA-NEXT:  .LBB219_3: # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    sltu a0, s2, a2
-; RV32IA-NEXT:  .LBB219_4: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    xori a0, a0, 1
-; RV32IA-NEXT:    sw a2, 0(sp)
-; RV32IA-NEXT:    bnez a0, .LBB219_6
-; RV32IA-NEXT:  # %bb.5: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    mv a2, s2
-; RV32IA-NEXT:  .LBB219_6: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    mv a3, a1
-; RV32IA-NEXT:    bnez a0, .LBB219_8
-; RV32IA-NEXT:  # %bb.7: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    mv a3, s1
-; RV32IA-NEXT:  .LBB219_8: # %atomicrmw.start
-; RV32IA-NEXT:    # in Loop: Header=BB219_1 Depth=1
-; RV32IA-NEXT:    sw a1, 4(sp)
-; RV32IA-NEXT:    mv a0, s3
-; RV32IA-NEXT:    mv a1, s4
-; RV32IA-NEXT:    mv a4, s5
-; RV32IA-NEXT:    mv a5, s5
-; RV32IA-NEXT:    call __atomic_compare_exchange_8
-; RV32IA-NEXT:    lw a1, 4(sp)
-; RV32IA-NEXT:    lw a2, 0(sp)
-; RV32IA-NEXT:    beqz a0, .LBB219_1
-; RV32IA-NEXT:  # %bb.9: # %atomicrmw.end
-; RV32IA-NEXT:    mv a0, a2
-; RV32IA-NEXT:    lw s5, 8(sp)
-; RV32IA-NEXT:    lw s4, 12(sp)
-; RV32IA-NEXT:    lw s3, 16(sp)
-; RV32IA-NEXT:    lw s2, 20(sp)
-; RV32IA-NEXT:    lw s1, 24(sp)
-; RV32IA-NEXT:    lw ra, 28(sp)
-; RV32IA-NEXT:    addi sp, sp, 32
-; RV32IA-NEXT:    ret
-  %1 = atomicrmw umin i64* %a, i64 %b seq_cst
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/bare-select.ll b/test/CodeGen/RISCV/bare-select.ll
deleted file mode 100644
index 59add65d1db..00000000000
--- a/test/CodeGen/RISCV/bare-select.ll
+++ /dev/null
@@ -1,31 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define i32 @bare_select(i1 %a, i32 %b, i32 %c) {
-; RV32I-LABEL: bare_select:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    bnez a0, .LBB0_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a1, a2
-; RV32I-NEXT:  .LBB0_2:
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = select i1 %a, i32 %b, i32 %c
-  ret i32 %1
-}
-
-define float @bare_select_float(i1 %a, float %b, float %c) {
-; RV32I-LABEL: bare_select_float:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    bnez a0, .LBB1_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a1, a2
-; RV32I-NEXT:  .LBB1_2:
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = select i1 %a, float %b, float %c
-  ret float %1
-}
diff --git a/test/CodeGen/RISCV/blockaddress.ll b/test/CodeGen/RISCV/blockaddress.ll
deleted file mode 100644
index 5b7f8187642..00000000000
--- a/test/CodeGen/RISCV/blockaddress.ll
+++ /dev/null
@@ -1,29 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-@addr = global i8* null
-
-define void @test_blockaddress() nounwind {
-; RV32I-LABEL: test_blockaddress:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(.Ltmp0)
-; RV32I-NEXT:    addi a0, a0, %lo(.Ltmp0)
-; RV32I-NEXT:    lui a1, %hi(addr)
-; RV32I-NEXT:    sw a0, %lo(addr)(a1)
-; RV32I-NEXT:    lw a0, %lo(addr)(a1)
-; RV32I-NEXT:    jr a0
-; RV32I-NEXT:  .Ltmp0: # Block address taken
-; RV32I-NEXT:  .LBB0_1: # %block
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  store volatile i8* blockaddress(@test_blockaddress, %block), i8** @addr
-  %val = load volatile i8*, i8** @addr
-  indirectbr i8* %val, [label %block]
-
-block:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/branch-relaxation.ll b/test/CodeGen/RISCV/branch-relaxation.ll
deleted file mode 100644
index 2be50d10ae9..00000000000
--- a/test/CodeGen/RISCV/branch-relaxation.ll
+++ /dev/null
@@ -1,65 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -filetype=obj < %s \
-; RUN:   -o /dev/null 2>&1
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s | FileCheck %s
-
-define void @relax_bcc(i1 %a) {
-; CHECK-LABEL: relax_bcc:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    andi a0, a0, 1
-; CHECK-NEXT:    bnez a0, .LBB0_1
-; CHECK-NEXT:    j .LBB0_2
-; CHECK-NEXT:  .LBB0_1: # %iftrue
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    .space 4096
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:  .LBB0_2: # %tail
-; CHECK-NEXT:    ret
-  br i1 %a, label %iftrue, label %tail
-
-iftrue:
-  call void asm sideeffect ".space 4096", ""()
-  br label %tail
-
-tail:
-  ret void
-}
-
-define i32 @relax_jal(i1 %a) {
-; CHECK-LABEL: relax_jal:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    andi a0, a0, 1
-; CHECK-NEXT:    bnez a0, .LBB1_1
-; CHECK-NEXT:  # %bb.3:
-; CHECK-NEXT:    lui a0, %hi(.LBB1_2)
-; CHECK-NEXT:    jalr zero, a0, %lo(.LBB1_2)
-; CHECK-NEXT:  .LBB1_1: # %iftrue
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    .space 1048576
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    addi a0, zero, 1
-; CHECK-NEXT:    ret
-; CHECK-NEXT:  .LBB1_2: # %jmp
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    addi a0, zero, 1
-; CHECK-NEXT:    ret
-  br i1 %a, label %iftrue, label %jmp
-
-jmp:
-  call void asm sideeffect "", ""()
-  br label %tail
-
-iftrue:
-  call void asm sideeffect "", ""()
-  br label %space
-
-space:
-  call void asm sideeffect ".space 1048576", ""()
-  br label %tail
-
-tail:
-  ret i32 1
-}
diff --git a/test/CodeGen/RISCV/branch.ll b/test/CodeGen/RISCV/branch.ll
deleted file mode 100644
index 71daf0e57b9..00000000000
--- a/test/CodeGen/RISCV/branch.ll
+++ /dev/null
@@ -1,109 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define void @foo(i32 %a, i32 *%b, i1 %c) {
-; RV32I-LABEL: foo:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    beq a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.1: # %test2
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bne a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.2: # %test3
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    blt a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.3: # %test4
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bge a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.4: # %test5
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bltu a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.5: # %test6
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bgeu a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.6: # %test7
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    blt a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.7: # %test8
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bge a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.8: # %test9
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bltu a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.9: # %test10
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bgeu a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.10: # %test11
-; RV32I-NEXT:    lw a0, 0(a1)
-; RV32I-NEXT:    andi a0, a2, 1
-; RV32I-NEXT:    bnez a0, .LBB0_12
-; RV32I-NEXT:  # %bb.11: # %test12
-; RV32I-NEXT:    lw a0, 0(a1)
-; RV32I-NEXT:  .LBB0_12: # %end
-; RV32I-NEXT:    ret
-  %val1 = load volatile i32, i32* %b
-  %tst1 = icmp eq i32 %val1, %a
-  br i1 %tst1, label %end, label %test2
-
-test2:
-  %val2 = load volatile i32, i32* %b
-  %tst2 = icmp ne i32 %val2, %a
-  br i1 %tst2, label %end, label %test3
-
-test3:
-  %val3 = load volatile i32, i32* %b
-  %tst3 = icmp slt i32 %val3, %a
-  br i1 %tst3, label %end, label %test4
-
-test4:
-  %val4 = load volatile i32, i32* %b
-  %tst4 = icmp sge i32 %val4, %a
-  br i1 %tst4, label %end, label %test5
-
-test5:
-  %val5 = load volatile i32, i32* %b
-  %tst5 = icmp ult i32 %val5, %a
-  br i1 %tst5, label %end, label %test6
-
-test6:
-  %val6 = load volatile i32, i32* %b
-  %tst6 = icmp uge i32 %val6, %a
-  br i1 %tst6, label %end, label %test7
-
-; Check for condition codes that don't have a matching instruction
-
-test7:
-  %val7 = load volatile i32, i32* %b
-  %tst7 = icmp sgt i32 %val7, %a
-  br i1 %tst7, label %end, label %test8
-
-test8:
-  %val8 = load volatile i32, i32* %b
-  %tst8 = icmp sle i32 %val8, %a
-  br i1 %tst8, label %end, label %test9
-
-test9:
-  %val9 = load volatile i32, i32* %b
-  %tst9 = icmp ugt i32 %val9, %a
-  br i1 %tst9, label %end, label %test10
-
-test10:
-  %val10 = load volatile i32, i32* %b
-  %tst10 = icmp ule i32 %val10, %a
-  br i1 %tst10, label %end, label %test11
-
-; Check the case of a branch where the condition was generated in another
-; function
-
-test11:
-  %val11 = load volatile i32, i32* %b
-  br i1 %c, label %end, label %test12
-
-test12:
-  %val12 = load volatile i32, i32* %b
-  br label %end
-
-end:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll b/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
deleted file mode 100644
index 532eedef6fb..00000000000
--- a/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
+++ /dev/null
@@ -1,542 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-declare i16 @llvm.bswap.i16(i16)
-declare i32 @llvm.bswap.i32(i32)
-declare i64 @llvm.bswap.i64(i64)
-declare i8 @llvm.cttz.i8(i8, i1)
-declare i16 @llvm.cttz.i16(i16, i1)
-declare i32 @llvm.cttz.i32(i32, i1)
-declare i64 @llvm.cttz.i64(i64, i1)
-declare i32 @llvm.ctlz.i32(i32, i1)
-declare i32 @llvm.ctpop.i32(i32)
-
-define i16 @test_bswap_i16(i16 %a) nounwind {
-; RV32I-LABEL: test_bswap_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a0, 8
-; RV32I-NEXT:    lui a2, 4080
-; RV32I-NEXT:    and a1, a1, a2
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a0, a0, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.bswap.i16(i16 %a)
-  ret i16 %tmp
-}
-
-define i32 @test_bswap_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_bswap_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -256
-; RV32I-NEXT:    srli a2, a0, 8
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    srli a2, a0, 24
-; RV32I-NEXT:    or a1, a1, a2
-; RV32I-NEXT:    slli a2, a0, 8
-; RV32I-NEXT:    lui a3, 4080
-; RV32I-NEXT:    and a2, a2, a3
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a2
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.bswap.i32(i32 %a)
-  ret i32 %tmp
-}
-
-define i64 @test_bswap_i64(i64 %a) nounwind {
-; RV32I-LABEL: test_bswap_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, 16
-; RV32I-NEXT:    addi a3, a2, -256
-; RV32I-NEXT:    srli a2, a1, 8
-; RV32I-NEXT:    and a2, a2, a3
-; RV32I-NEXT:    srli a4, a1, 24
-; RV32I-NEXT:    or a2, a2, a4
-; RV32I-NEXT:    slli a4, a1, 8
-; RV32I-NEXT:    lui a5, 4080
-; RV32I-NEXT:    and a4, a4, a5
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    or a1, a1, a4
-; RV32I-NEXT:    or a2, a1, a2
-; RV32I-NEXT:    srli a1, a0, 8
-; RV32I-NEXT:    and a1, a1, a3
-; RV32I-NEXT:    srli a3, a0, 24
-; RV32I-NEXT:    or a1, a1, a3
-; RV32I-NEXT:    slli a3, a0, 8
-; RV32I-NEXT:    and a3, a3, a5
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a3
-; RV32I-NEXT:    or a1, a0, a1
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.bswap.i64(i64 %a)
-  ret i64 %tmp
-}
-
-define i8 @test_cttz_i8(i8 %a) nounwind {
-; RV32I-LABEL: test_cttz_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    beqz a1, .LBB3_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB3_3
-; RV32I-NEXT:  .LBB3_2:
-; RV32I-NEXT:    addi a0, zero, 8
-; RV32I-NEXT:  .LBB3_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i8 @llvm.cttz.i8(i8 %a, i1 false)
-  ret i8 %tmp
-}
-
-define i16 @test_cttz_i16(i16 %a) nounwind {
-; RV32I-LABEL: test_cttz_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a1, a0, a1
-; RV32I-NEXT:    beqz a1, .LBB4_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB4_3
-; RV32I-NEXT:  .LBB4_2:
-; RV32I-NEXT:    addi a0, zero, 16
-; RV32I-NEXT:  .LBB4_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.cttz.i16(i16 %a, i1 false)
-  ret i16 %tmp
-}
-
-define i32 @test_cttz_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_cttz_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB5_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB5_3
-; RV32I-NEXT:  .LBB5_2:
-; RV32I-NEXT:    addi a0, zero, 32
-; RV32I-NEXT:  .LBB5_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.cttz.i32(i32 %a, i1 false)
-  ret i32 %tmp
-}
-
-define i32 @test_ctlz_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_ctlz_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB6_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 2
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 8
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 16
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB6_3
-; RV32I-NEXT:  .LBB6_2:
-; RV32I-NEXT:    addi a0, zero, 32
-; RV32I-NEXT:  .LBB6_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.ctlz.i32(i32 %a, i1 false)
-  ret i32 %tmp
-}
-
-define i64 @test_cttz_i64(i64 %a) nounwind {
-; RV32I-LABEL: test_cttz_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    sw s7, 0(sp)
-; RV32I-NEXT:    mv s3, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    addi a0, a0, -1
-; RV32I-NEXT:    not a1, s4
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi s5, a1, 1365
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi s1, a1, 819
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s1
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi s6, a1, 257
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi s7, a1, -241
-; RV32I-NEXT:    and a0, a0, s7
-; RV32I-NEXT:    mv a1, s6
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    addi a0, s3, -1
-; RV32I-NEXT:    not a1, s3
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s1
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    and a0, a0, s7
-; RV32I-NEXT:    mv a1, s6
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    bnez s4, .LBB7_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    addi a0, a0, 32
-; RV32I-NEXT:    j .LBB7_3
-; RV32I-NEXT:  .LBB7_2:
-; RV32I-NEXT:    srli a0, s2, 24
-; RV32I-NEXT:  .LBB7_3:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    lw s7, 0(sp)
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
-  ret i64 %tmp
-}
-
-define i8 @test_cttz_i8_zero_undef(i8 %a) nounwind {
-; RV32I-LABEL: test_cttz_i8_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i8 @llvm.cttz.i8(i8 %a, i1 true)
-  ret i8 %tmp
-}
-
-define i16 @test_cttz_i16_zero_undef(i16 %a) nounwind {
-; RV32I-LABEL: test_cttz_i16_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.cttz.i16(i16 %a, i1 true)
-  ret i16 %tmp
-}
-
-define i32 @test_cttz_i32_zero_undef(i32 %a) nounwind {
-; RV32I-LABEL: test_cttz_i32_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.cttz.i32(i32 %a, i1 true)
-  ret i32 %tmp
-}
-
-define i64 @test_cttz_i64_zero_undef(i64 %a) nounwind {
-; RV32I-LABEL: test_cttz_i64_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    sw s1, 24(sp)
-; RV32I-NEXT:    sw s2, 20(sp)
-; RV32I-NEXT:    sw s3, 16(sp)
-; RV32I-NEXT:    sw s4, 12(sp)
-; RV32I-NEXT:    sw s5, 8(sp)
-; RV32I-NEXT:    sw s6, 4(sp)
-; RV32I-NEXT:    sw s7, 0(sp)
-; RV32I-NEXT:    mv s3, a1
-; RV32I-NEXT:    mv s4, a0
-; RV32I-NEXT:    addi a0, a0, -1
-; RV32I-NEXT:    not a1, s4
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi s5, a1, 1365
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi s1, a1, 819
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s1
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi s6, a1, 257
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi s7, a1, -241
-; RV32I-NEXT:    and a0, a0, s7
-; RV32I-NEXT:    mv a1, s6
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    mv s2, a0
-; RV32I-NEXT:    addi a0, s3, -1
-; RV32I-NEXT:    not a1, s3
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    and a1, a0, s1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s1
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    and a0, a0, s7
-; RV32I-NEXT:    mv a1, s6
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    bnez s4, .LBB11_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    addi a0, a0, 32
-; RV32I-NEXT:    j .LBB11_3
-; RV32I-NEXT:  .LBB11_2:
-; RV32I-NEXT:    srli a0, s2, 24
-; RV32I-NEXT:  .LBB11_3:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    lw s7, 0(sp)
-; RV32I-NEXT:    lw s6, 4(sp)
-; RV32I-NEXT:    lw s5, 8(sp)
-; RV32I-NEXT:    lw s4, 12(sp)
-; RV32I-NEXT:    lw s3, 16(sp)
-; RV32I-NEXT:    lw s2, 20(sp)
-; RV32I-NEXT:    lw s1, 24(sp)
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 true)
-  ret i64 %tmp
-}
-
-define i32 @test_ctpop_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_ctpop_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @llvm.ctpop.i32(i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/byval.ll b/test/CodeGen/RISCV/byval.ll
deleted file mode 100644
index 832dfb2e8a2..00000000000
--- a/test/CodeGen/RISCV/byval.ll
+++ /dev/null
@@ -1,43 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-%struct.Foo = type { i32, i32, i32, i16, i8 }
-@foo = global %struct.Foo { i32 1, i32 2, i32 3, i16 4, i8 5 }, align 4
-
-define i32 @callee(%struct.Foo* byval %f) nounwind {
-; RV32I-LABEL: callee:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    ret
-entry:
-  %0 = getelementptr inbounds %struct.Foo, %struct.Foo* %f, i32 0, i32 0
-  %1 = load i32, i32* %0, align 4
-  ret i32 %1
-}
-
-
-define void @caller() nounwind {
-; RV32I-LABEL: caller:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    lui a0, %hi(foo)
-; RV32I-NEXT:    lw a1, %lo(foo)(a0)
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    addi a0, a0, %lo(foo)
-; RV32I-NEXT:    lw a1, 12(a0)
-; RV32I-NEXT:    sw a1, 24(sp)
-; RV32I-NEXT:    lw a1, 8(a0)
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    lw a0, 4(a0)
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    addi a0, sp, 12
-; RV32I-NEXT:    call callee
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-entry:
-  %call = call i32 @callee(%struct.Foo* byval @foo)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/calling-conv-rv32f-ilp32.ll b/test/CodeGen/RISCV/calling-conv-rv32f-ilp32.ll
deleted file mode 100644
index 849e18a81bb..00000000000
--- a/test/CodeGen/RISCV/calling-conv-rv32f-ilp32.ll
+++ /dev/null
@@ -1,81 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32IF
-
-; Exercises the ILP32 calling convention code in the case that f32 is a legal
-; type. As well as testing that lowering is correct, these tests also aim to
-; check that floating point load/store or integer load/store is chosen
-; optimally when floats are passed on the stack.
-
-define float @onstack_f32_noop(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
-; RV32IF-LABEL: onstack_f32_noop:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lw a0, 4(sp)
-; RV32IF-NEXT:    ret
-  ret float %f
-}
-
-define float @onstack_f32_fadd(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
-; RV32IF-LABEL: onstack_f32_fadd:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    flw ft0, 4(sp)
-; RV32IF-NEXT:    flw ft1, 0(sp)
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fadd float %e, %f
-  ret float %1
-}
-
-define float @caller_onstack_f32_noop(float %a) nounwind {
-; RV32IF-LABEL: caller_onstack_f32_noop:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    sw a0, 4(sp)
-; RV32IF-NEXT:    lui a0, 264704
-; RV32IF-NEXT:    sw a0, 0(sp)
-; RV32IF-NEXT:    addi a0, zero, 1
-; RV32IF-NEXT:    addi a2, zero, 2
-; RV32IF-NEXT:    addi a4, zero, 3
-; RV32IF-NEXT:    addi a6, zero, 4
-; RV32IF-NEXT:    mv a1, zero
-; RV32IF-NEXT:    mv a3, zero
-; RV32IF-NEXT:    mv a5, zero
-; RV32IF-NEXT:    mv a7, zero
-; RV32IF-NEXT:    call onstack_f32_noop
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float 5.0, float %a)
-  ret float %1
-}
-
-define float @caller_onstack_f32_fadd(float %a, float %b) nounwind {
-; RV32IF-LABEL: caller_onstack_f32_fadd:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fsub.s ft2, ft1, ft0
-; RV32IF-NEXT:    fsw ft2, 4(sp)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fsw ft0, 0(sp)
-; RV32IF-NEXT:    addi a0, zero, 1
-; RV32IF-NEXT:    addi a2, zero, 2
-; RV32IF-NEXT:    addi a4, zero, 3
-; RV32IF-NEXT:    addi a6, zero, 4
-; RV32IF-NEXT:    mv a1, zero
-; RV32IF-NEXT:    mv a3, zero
-; RV32IF-NEXT:    mv a5, zero
-; RV32IF-NEXT:    mv a7, zero
-; RV32IF-NEXT:    call onstack_f32_noop
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = fadd float %a, %b
-  %2 = fsub float %b, %a
-  %3 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float %1, float %2)
-  ret float %3
-}
diff --git a/test/CodeGen/RISCV/calling-conv-sext-zext.ll b/test/CodeGen/RISCV/calling-conv-sext-zext.ll
deleted file mode 100644
index 6609ab2008e..00000000000
--- a/test/CodeGen/RISCV/calling-conv-sext-zext.ll
+++ /dev/null
@@ -1,344 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define zeroext i8 @uint8_arg_to_uint8_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-declare void @receive_uint8(i8 zeroext)
-
-define void @pass_uint8_as_uint8(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call receive_uint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_uint8(i8 zeroext %a)
-  ret void
-}
-
-declare zeroext i8 @return_uint8()
-
-define zeroext i8 @ret_callresult_uint8_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_uint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  ret i8 %1
-}
-
-define signext i8 @uint8_arg_to_sint8_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-declare void @receive_sint8(i8 signext)
-
-define void @pass_uint8_as_sint8(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    call receive_sint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-
-  call void @receive_sint8(i8 signext %a)
-  ret void
-}
-
-define signext i8 @ret_callresult_uint8_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_uint8
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  ret i8 %1
-}
-
-define signext i32 @uint8_arg_to_anyint32_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  ret i32 %1
-}
-
-declare void @receive_anyint32(i32 signext)
-
-define void @pass_uint8_as_anyint32(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call receive_anyint32
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  call void @receive_anyint32(i32 signext %1)
-  ret void
-}
-
-define signext i32 @ret_callresult_uint8_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_uint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  %2 = zext i8 %1 to i32
-  ret i32 %2
-}
-
-define zeroext i8 @sint8_arg_to_uint8_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-define void @pass_sint8_as_uint8(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    call receive_uint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_uint8(i8 zeroext %a)
-  ret void
-}
-
-declare signext i8 @return_sint8()
-
-define zeroext i8 @ret_callresult_sint8_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_sint8
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  ret i8 %1
-}
-
-define signext i8 @sint8_arg_to_sint8_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-define void @pass_sint8_as_sint8(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call receive_sint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_sint8(i8 signext %a)
-  ret void
-}
-
-define signext i8 @ret_callresult_sint8_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_sint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  ret i8 %1
-}
-
-define signext i32 @sint8_arg_to_anyint32_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  ret i32 %1
-}
-
-define void @pass_sint8_as_anyint32(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call receive_anyint32
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  call void @receive_anyint32(i32 signext %1)
-  ret void
-}
-
-define signext i32 @ret_callresult_sint8_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_sint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  %2 = sext i8 %1 to i32
-  ret i32 %2
-}
-
-define zeroext i8 @anyint32_arg_to_uint8_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define void @pass_anyint32_as_uint8(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    call receive_uint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  call void @receive_uint8(i8 zeroext %1)
-  ret void
-}
-
-declare signext i32 @return_anyint32()
-
-define zeroext i8 @ret_callresult_anyint32_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_anyint32
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  %2 = trunc i32 %1 to i8
-  ret i8 %2
-}
-
-define signext i8 @anyint32_arg_to_sint8_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define void @pass_anyint32_as_sint8(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    call receive_sint8
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  call void @receive_sint8(i8 signext %1)
-  ret void
-}
-
-define signext i8 @ret_callresult_anyint32_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_anyint32
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  %2 = trunc i32 %1 to i8
-  ret i8 %2
-}
-
-define signext i32 @anyint32_arg_to_anyint32_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i32 %a
-}
-
-define void @pass_anyint32_as_anyint32(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call receive_anyint32
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_anyint32(i32 signext %a)
-  ret void
-}
-
-define signext i32 @ret_callresult_anyint32_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call return_anyint32
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  ret i32 %1
-}
-
diff --git a/test/CodeGen/RISCV/calling-conv.ll b/test/CodeGen/RISCV/calling-conv.ll
deleted file mode 100644
index 53685937283..00000000000
--- a/test/CodeGen/RISCV/calling-conv.ll
+++ /dev/null
@@ -1,1068 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-; As well as calling convention details, we check that ra and fp are
-; consistently stored to fp-4 and fp-8.
-
-; Check that on RV32, i64 and double are passed in a pair of registers. Unlike
-; the convention for varargs, this need not be an aligned pair.
-
-define i32 @callee_scalars(i32 %a, i64 %b, i32 %c, i32 %d, double %e) nounwind {
-; RV32I-FPELIM-LABEL: callee_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 24(sp)
-; RV32I-FPELIM-NEXT:    sw s2, 20(sp)
-; RV32I-FPELIM-NEXT:    sw s3, 16(sp)
-; RV32I-FPELIM-NEXT:    sw s4, 12(sp)
-; RV32I-FPELIM-NEXT:    mv s2, a4
-; RV32I-FPELIM-NEXT:    mv s3, a3
-; RV32I-FPELIM-NEXT:    mv s4, a1
-; RV32I-FPELIM-NEXT:    mv s1, a0
-; RV32I-FPELIM-NEXT:    mv a0, a5
-; RV32I-FPELIM-NEXT:    mv a1, a6
-; RV32I-FPELIM-NEXT:    call __fixdfsi
-; RV32I-FPELIM-NEXT:    add a1, s1, s4
-; RV32I-FPELIM-NEXT:    add a1, a1, s3
-; RV32I-FPELIM-NEXT:    add a1, a1, s2
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw s4, 12(sp)
-; RV32I-FPELIM-NEXT:    lw s3, 16(sp)
-; RV32I-FPELIM-NEXT:    lw s2, 20(sp)
-; RV32I-FPELIM-NEXT:    lw s1, 24(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s2, 16(sp)
-; RV32I-WITHFP-NEXT:    sw s3, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s4, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    mv s2, a4
-; RV32I-WITHFP-NEXT:    mv s3, a3
-; RV32I-WITHFP-NEXT:    mv s4, a1
-; RV32I-WITHFP-NEXT:    mv s1, a0
-; RV32I-WITHFP-NEXT:    mv a0, a5
-; RV32I-WITHFP-NEXT:    mv a1, a6
-; RV32I-WITHFP-NEXT:    call __fixdfsi
-; RV32I-WITHFP-NEXT:    add a1, s1, s4
-; RV32I-WITHFP-NEXT:    add a1, a1, s3
-; RV32I-WITHFP-NEXT:    add a1, a1, s2
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s4, 8(sp)
-; RV32I-WITHFP-NEXT:    lw s3, 12(sp)
-; RV32I-WITHFP-NEXT:    lw s2, 16(sp)
-; RV32I-WITHFP-NEXT:    lw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %b_trunc = trunc i64 %b to i32
-  %e_fptosi = fptosi double %e to i32
-  %1 = add i32 %a, %b_trunc
-  %2 = add i32 %1, %c
-  %3 = add i32 %2, %d
-  %4 = add i32 %3, %e_fptosi
-  ret i32 %4
-}
-
-define i32 @caller_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a3, zero, 3
-; RV32I-FPELIM-NEXT:    addi a4, zero, 4
-; RV32I-FPELIM-NEXT:    lui a6, 262464
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    mv a5, zero
-; RV32I-FPELIM-NEXT:    call callee_scalars
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a3, zero, 3
-; RV32I-WITHFP-NEXT:    addi a4, zero, 4
-; RV32I-WITHFP-NEXT:    lui a6, 262464
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    mv a5, zero
-; RV32I-WITHFP-NEXT:    call callee_scalars
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_scalars(i32 1, i64 2, i32 3, i32 4, double 5.000000e+00)
-  ret i32 %1
-}
-
-; Check that i128 and fp128 are passed indirectly
-
-define i32 @callee_large_scalars(i128 %a, fp128 %b) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a2, 12(a1)
-; RV32I-FPELIM-NEXT:    lw a3, 12(a0)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a3, 4(a1)
-; RV32I-FPELIM-NEXT:    lw a4, 4(a0)
-; RV32I-FPELIM-NEXT:    xor a3, a4, a3
-; RV32I-FPELIM-NEXT:    or a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a3, 8(a1)
-; RV32I-FPELIM-NEXT:    lw a4, 8(a0)
-; RV32I-FPELIM-NEXT:    xor a3, a4, a3
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    xor a0, a0, a1
-; RV32I-FPELIM-NEXT:    or a0, a0, a3
-; RV32I-FPELIM-NEXT:    or a0, a0, a2
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a2, 12(a1)
-; RV32I-WITHFP-NEXT:    lw a3, 12(a0)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a3, 4(a1)
-; RV32I-WITHFP-NEXT:    lw a4, 4(a0)
-; RV32I-WITHFP-NEXT:    xor a3, a4, a3
-; RV32I-WITHFP-NEXT:    or a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a3, 8(a1)
-; RV32I-WITHFP-NEXT:    lw a4, 8(a0)
-; RV32I-WITHFP-NEXT:    xor a3, a4, a3
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    xor a0, a0, a1
-; RV32I-WITHFP-NEXT:    or a0, a0, a3
-; RV32I-WITHFP-NEXT:    or a0, a0, a2
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %b_bitcast = bitcast fp128 %b to i128
-  %1 = icmp eq i128 %a, %b_bitcast
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @caller_large_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 524272
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 8(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 4(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 0(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 36(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 32(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 28(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    mv a1, sp
-; RV32I-FPELIM-NEXT:    call callee_large_scalars
-; RV32I-FPELIM-NEXT:    lw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 48
-; RV32I-WITHFP-NEXT:    lui a0, 524272
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -40(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -44(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -48(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -12(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    addi a1, s0, -48
-; RV32I-WITHFP-NEXT:    call callee_large_scalars
-; RV32I-WITHFP-NEXT:    lw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_large_scalars(i128 1, fp128 0xL00000000000000007FFF000000000000)
-  ret i32 %1
-}
-
-; Must keep define on a single line due to an update_llc_test_checks.py limitation
-define i32 @callee_large_scalars_exhausted_regs(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i128 %h, i32 %i, fp128 %j) nounwind {
-; Check that arguments larger than 2*xlen are handled correctly when their
-; address is passed on the stack rather than in memory
-; RV32I-FPELIM-LABEL: callee_large_scalars_exhausted_regs:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    lw a2, 12(a7)
-; RV32I-FPELIM-NEXT:    xor a1, a2, a1
-; RV32I-FPELIM-NEXT:    lw a2, 4(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 4(a7)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    or a1, a2, a1
-; RV32I-FPELIM-NEXT:    lw a2, 8(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 8(a7)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 0(a7)
-; RV32I-FPELIM-NEXT:    xor a0, a3, a0
-; RV32I-FPELIM-NEXT:    or a0, a0, a2
-; RV32I-FPELIM-NEXT:    or a0, a0, a1
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalars_exhausted_regs:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    lw a2, 12(a7)
-; RV32I-WITHFP-NEXT:    xor a1, a2, a1
-; RV32I-WITHFP-NEXT:    lw a2, 4(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 4(a7)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    or a1, a2, a1
-; RV32I-WITHFP-NEXT:    lw a2, 8(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 8(a7)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 0(a7)
-; RV32I-WITHFP-NEXT:    xor a0, a3, a0
-; RV32I-WITHFP-NEXT:    or a0, a0, a2
-; RV32I-WITHFP-NEXT:    or a0, a0, a1
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %j_bitcast = bitcast fp128 %j to i128
-  %1 = icmp eq i128 %h, %j_bitcast
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @caller_large_scalars_exhausted_regs() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalars_exhausted_regs:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 16
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 9
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 524272
-; RV32I-FPELIM-NEXT:    sw a0, 28(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 24(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 20(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 16(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 52(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 48(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 44(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 8
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a2, zero, 3
-; RV32I-FPELIM-NEXT:    addi a3, zero, 4
-; RV32I-FPELIM-NEXT:    addi a4, zero, 5
-; RV32I-FPELIM-NEXT:    addi a5, zero, 6
-; RV32I-FPELIM-NEXT:    addi a6, zero, 7
-; RV32I-FPELIM-NEXT:    addi a7, sp, 40
-; RV32I-FPELIM-NEXT:    call callee_large_scalars_exhausted_regs
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalars_exhausted_regs:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, s0, -48
-; RV32I-WITHFP-NEXT:    sw a0, 4(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 9
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 524272
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -40(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -44(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -48(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -12(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 8
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a2, zero, 3
-; RV32I-WITHFP-NEXT:    addi a3, zero, 4
-; RV32I-WITHFP-NEXT:    addi a4, zero, 5
-; RV32I-WITHFP-NEXT:    addi a5, zero, 6
-; RV32I-WITHFP-NEXT:    addi a6, zero, 7
-; RV32I-WITHFP-NEXT:    addi a7, s0, -24
-; RV32I-WITHFP-NEXT:    call callee_large_scalars_exhausted_regs
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_large_scalars_exhausted_regs(
-      i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i128 8, i32 9,
-      fp128 0xL00000000000000007FFF000000000000)
-  ret i32 %1
-}
-
-; Ensure that libcalls generated in the middle-end obey the calling convention
-
-define i32 @caller_mixed_scalar_libcalls(i64 %a) nounwind {
-; RV32I-FPELIM-LABEL: caller_mixed_scalar_libcalls:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    mv a2, a1
-; RV32I-FPELIM-NEXT:    mv a1, a0
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    call __floatditf
-; RV32I-FPELIM-NEXT:    lw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_mixed_scalar_libcalls:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    mv a2, a1
-; RV32I-WITHFP-NEXT:    mv a1, a0
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    call __floatditf
-; RV32I-WITHFP-NEXT:    lw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = sitofp i64 %a to fp128
-  %2 = bitcast fp128 %1 to i128
-  %3 = trunc i128 %2 to i32
-  ret i32 %3
-}
-
-; Check that the stack is used once the GPRs are exhausted
-
-define i32 @callee_many_scalars(i8 %a, i16 %b, i32 %c, i64 %d, i32 %e, i32 %f, i64 %g, i32 %h) nounwind {
-; RV32I-FPELIM-LABEL: callee_many_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw t0, 0(sp)
-; RV32I-FPELIM-NEXT:    xor a4, a4, t0
-; RV32I-FPELIM-NEXT:    xor a3, a3, a7
-; RV32I-FPELIM-NEXT:    or a3, a3, a4
-; RV32I-FPELIM-NEXT:    lui a4, 16
-; RV32I-FPELIM-NEXT:    addi a4, a4, -1
-; RV32I-FPELIM-NEXT:    and a1, a1, a4
-; RV32I-FPELIM-NEXT:    andi a0, a0, 255
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    add a0, a0, a2
-; RV32I-FPELIM-NEXT:    seqz a1, a3
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    add a0, a0, a5
-; RV32I-FPELIM-NEXT:    add a0, a0, a6
-; RV32I-FPELIM-NEXT:    lw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_many_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw t0, 0(s0)
-; RV32I-WITHFP-NEXT:    xor a4, a4, t0
-; RV32I-WITHFP-NEXT:    xor a3, a3, a7
-; RV32I-WITHFP-NEXT:    or a3, a3, a4
-; RV32I-WITHFP-NEXT:    lui a4, 16
-; RV32I-WITHFP-NEXT:    addi a4, a4, -1
-; RV32I-WITHFP-NEXT:    and a1, a1, a4
-; RV32I-WITHFP-NEXT:    andi a0, a0, 255
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    add a0, a0, a2
-; RV32I-WITHFP-NEXT:    seqz a1, a3
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    add a0, a0, a5
-; RV32I-WITHFP-NEXT:    add a0, a0, a6
-; RV32I-WITHFP-NEXT:    lw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %a_ext = zext i8 %a to i32
-  %b_ext = zext i16 %b to i32
-  %1 = add i32 %a_ext, %b_ext
-  %2 = add i32 %1, %c
-  %3 = icmp eq i64 %d, %g
-  %4 = zext i1 %3 to i32
-  %5 = add i32 %4, %2
-  %6 = add i32 %5, %e
-  %7 = add i32 %6, %f
-  %8 = add i32 %7, %h
-  ret i32 %8
-}
-
-define i32 @caller_many_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_many_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 8
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 0(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a2, zero, 3
-; RV32I-FPELIM-NEXT:    addi a3, zero, 4
-; RV32I-FPELIM-NEXT:    addi a5, zero, 5
-; RV32I-FPELIM-NEXT:    addi a6, zero, 6
-; RV32I-FPELIM-NEXT:    addi a7, zero, 7
-; RV32I-FPELIM-NEXT:    mv a4, zero
-; RV32I-FPELIM-NEXT:    call callee_many_scalars
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_many_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 8
-; RV32I-WITHFP-NEXT:    sw a0, 4(sp)
-; RV32I-WITHFP-NEXT:    sw zero, 0(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a2, zero, 3
-; RV32I-WITHFP-NEXT:    addi a3, zero, 4
-; RV32I-WITHFP-NEXT:    addi a5, zero, 5
-; RV32I-WITHFP-NEXT:    addi a6, zero, 6
-; RV32I-WITHFP-NEXT:    addi a7, zero, 7
-; RV32I-WITHFP-NEXT:    mv a4, zero
-; RV32I-WITHFP-NEXT:    call callee_many_scalars
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_many_scalars(i8 1, i16 2, i32 3, i64 4, i32 5, i32 6, i64 7, i32 8)
-  ret i32 %1
-}
-
-; Check passing of coerced integer arrays
-
-%struct.small = type { i32, i32* }
-
-define i32 @callee_small_coerced_struct([2 x i32] %a.coerce) nounwind {
-; RV32I-FPELIM-LABEL: callee_small_coerced_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    xor a0, a0, a1
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_coerced_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    xor a0, a0, a1
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = extractvalue [2 x i32] %a.coerce, 0
-  %2 = extractvalue [2 x i32] %a.coerce, 1
-  %3 = icmp eq i32 %1, %2
-  %4 = zext i1 %3 to i32
-  ret i32 %4
-}
-
-define i32 @caller_small_coerced_struct() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_coerced_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    call callee_small_coerced_struct
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_coerced_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    call callee_small_coerced_struct
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_small_coerced_struct([2 x i32] [i32 1, i32 2])
-  ret i32 %1
-}
-
-; Check large struct arguments, which are passed byval
-
-%struct.large = type { i32, i32, i32, i32 }
-
-define i32 @callee_large_struct(%struct.large* byval align 4 %a) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 0
-  %2 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 3
-  %3 = load i32, i32* %1
-  %4 = load i32, i32* %2
-  %5 = add i32 %3, %4
-  ret i32 %5
-}
-
-define i32 @caller_large_struct() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 2
-; RV32I-FPELIM-NEXT:    sw a0, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 3
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 4
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    call callee_large_struct
-; RV32I-FPELIM-NEXT:    lw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 48
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -40(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 2
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 3
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 4
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -40
-; RV32I-WITHFP-NEXT:    call callee_large_struct
-; RV32I-WITHFP-NEXT:    lw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %ls = alloca %struct.large, align 4
-  %1 = bitcast %struct.large* %ls to i8*
-  %a = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 0
-  store i32 1, i32* %a
-  %b = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 1
-  store i32 2, i32* %b
-  %c = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 2
-  store i32 3, i32* %c
-  %d = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 3
-  store i32 4, i32* %d
-  %2 = call i32 @callee_large_struct(%struct.large* byval align 4 %ls)
-  ret i32 %2
-}
-
-; Check 2x*xlen values are aligned appropriately when passed on the stack
-; Must keep define on a single line due to an update_llc_test_checks.py limitation
-define i32 @callee_aligned_stack(i32 %a, i32 %b, fp128 %c, i32 %d, i32 %e, i64 %f, i32 %g, i32 %h, double %i, i32 %j, [2 x i32] %k) nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-FPELIM-LABEL: callee_aligned_stack:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a0, 0(a2)
-; RV32I-FPELIM-NEXT:    add a0, a0, a7
-; RV32I-FPELIM-NEXT:    lw a1, 0(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 8(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 16(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_aligned_stack:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a0, 0(a2)
-; RV32I-WITHFP-NEXT:    add a0, a0, a7
-; RV32I-WITHFP-NEXT:    lw a1, 0(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 8(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 16(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 20(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = bitcast fp128 %c to i128
-  %2 = trunc i128 %1 to i32
-  %3 = add i32 %2, %g
-  %4 = add i32 %3, %h
-  %5 = bitcast double %i to i64
-  %6 = trunc i64 %5 to i32
-  %7 = add i32 %4, %6
-  %8 = add i32 %7, %j
-  %9 = extractvalue [2 x i32] %k, 0
-  %10 = add i32 %8, %9
-  ret i32 %10
-}
-
-define void @caller_aligned_stack() nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-FPELIM-LABEL: caller_aligned_stack:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 18
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 17
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 16
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262236
-; RV32I-FPELIM-NEXT:    addi a0, a0, 655
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 377487
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1475
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 15
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262153
-; RV32I-FPELIM-NEXT:    addi a0, a0, 491
-; RV32I-FPELIM-NEXT:    sw a0, 44(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 545260
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1967
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 964690
-; RV32I-FPELIM-NEXT:    addi a0, a0, -328
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 335544
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1311
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 688509
-; RV32I-FPELIM-NEXT:    addi a5, a0, -2048
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 11
-; RV32I-FPELIM-NEXT:    addi a2, sp, 32
-; RV32I-FPELIM-NEXT:    addi a3, zero, 12
-; RV32I-FPELIM-NEXT:    addi a4, zero, 13
-; RV32I-FPELIM-NEXT:    addi a6, zero, 4
-; RV32I-FPELIM-NEXT:    addi a7, zero, 14
-; RV32I-FPELIM-NEXT:    call callee_aligned_stack
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_aligned_stack:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, zero, 18
-; RV32I-WITHFP-NEXT:    sw a0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 17
-; RV32I-WITHFP-NEXT:    sw a0, 20(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 16
-; RV32I-WITHFP-NEXT:    sw a0, 16(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262236
-; RV32I-WITHFP-NEXT:    addi a0, a0, 655
-; RV32I-WITHFP-NEXT:    sw a0, 12(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 377487
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1475
-; RV32I-WITHFP-NEXT:    sw a0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 15
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262153
-; RV32I-WITHFP-NEXT:    addi a0, a0, 491
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 545260
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1967
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 964690
-; RV32I-WITHFP-NEXT:    addi a0, a0, -328
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 335544
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1311
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 688509
-; RV32I-WITHFP-NEXT:    addi a5, a0, -2048
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 11
-; RV32I-WITHFP-NEXT:    addi a2, s0, -32
-; RV32I-WITHFP-NEXT:    addi a3, zero, 12
-; RV32I-WITHFP-NEXT:    addi a4, zero, 13
-; RV32I-WITHFP-NEXT:    addi a6, zero, 4
-; RV32I-WITHFP-NEXT:    addi a7, zero, 14
-; RV32I-WITHFP-NEXT:    call callee_aligned_stack
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_aligned_stack(i32 1, i32 11,
-    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13,
-    i64 20000000000, i32 14, i32 15, double 2.720000e+00, i32 16,
-    [2 x i32] [i32 17, i32 18])
-  ret void
-}
-
-; Check return of 2x xlen scalars
-
-define i64 @callee_small_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_small_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a0, 466866
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1677
-; RV32I-FPELIM-NEXT:    addi a1, zero, 287
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 466866
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1677
-; RV32I-WITHFP-NEXT:    addi a1, zero, 287
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret i64 1234567898765
-}
-
-define i32 @caller_small_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 56
-; RV32I-FPELIM-NEXT:    addi s1, a0, 580
-; RV32I-FPELIM-NEXT:    call callee_small_scalar_ret
-; RV32I-FPELIM-NEXT:    xor a1, a1, s1
-; RV32I-FPELIM-NEXT:    lui a2, 200614
-; RV32I-FPELIM-NEXT:    addi a2, a2, 647
-; RV32I-FPELIM-NEXT:    xor a0, a0, a2
-; RV32I-FPELIM-NEXT:    or a0, a0, a1
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    lw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 56
-; RV32I-WITHFP-NEXT:    addi s1, a0, 580
-; RV32I-WITHFP-NEXT:    call callee_small_scalar_ret
-; RV32I-WITHFP-NEXT:    xor a1, a1, s1
-; RV32I-WITHFP-NEXT:    lui a2, 200614
-; RV32I-WITHFP-NEXT:    addi a2, a2, 647
-; RV32I-WITHFP-NEXT:    xor a0, a0, a2
-; RV32I-WITHFP-NEXT:    or a0, a0, a1
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i64 @callee_small_scalar_ret()
-  %2 = icmp eq i64 987654321234567, %1
-  %3 = zext i1 %2 to i32
-  ret i32 %3
-}
-
-; Check return of 2x xlen structs
-
-define %struct.small @callee_small_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_small_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    mv a1, zero
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    mv a1, zero
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret %struct.small { i32 1, i32* null }
-}
-
-define i32 @caller_small_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    call callee_small_struct_ret
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    call callee_small_struct_ret
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call %struct.small @callee_small_struct_ret()
-  %2 = extractvalue %struct.small %1, 0
-  %3 = extractvalue %struct.small %1, 1
-  %4 = ptrtoint i32* %3 to i32
-  %5 = add i32 %2, %4
-  ret i32 %5
-}
-
-; Check return of >2x xlen scalars
-
-define fp128 @callee_large_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_large_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a1, 524272
-; RV32I-FPELIM-NEXT:    sw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 8(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 4(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 0(a0)
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a1, 524272
-; RV32I-WITHFP-NEXT:    sw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 8(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 4(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 0(a0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret fp128 0xL00000000000000007FFF000000000000
-}
-
-define void @caller_large_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    mv a0, sp
-; RV32I-FPELIM-NEXT:    call callee_large_scalar_ret
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    addi a0, s0, -32
-; RV32I-WITHFP-NEXT:    call callee_large_scalar_ret
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call fp128 @callee_large_scalar_ret()
-  ret void
-}
-
-; Check return of >2x xlen structs
-
-define void @callee_large_struct_ret(%struct.large* noalias sret %agg.result) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi a1, zero, 4
-; RV32I-FPELIM-NEXT:    sw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 3
-; RV32I-FPELIM-NEXT:    sw a1, 8(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    sw a1, 4(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 1
-; RV32I-FPELIM-NEXT:    sw a1, 0(a0)
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a1, zero, 4
-; RV32I-WITHFP-NEXT:    sw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 3
-; RV32I-WITHFP-NEXT:    sw a1, 8(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    sw a1, 4(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 1
-; RV32I-WITHFP-NEXT:    sw a1, 0(a0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %a = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 0
-  store i32 1, i32* %a, align 4
-  %b = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 1
-  store i32 2, i32* %b, align 4
-  %c = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 2
-  store i32 3, i32* %c, align 4
-  %d = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 3
-  store i32 4, i32* %d, align 4
-  ret void
-}
-
-define i32 @caller_large_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    call callee_large_struct_ret
-; RV32I-FPELIM-NEXT:    lw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 8(sp)
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    call callee_large_struct_ret
-; RV32I-WITHFP-NEXT:    lw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a1, -24(s0)
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = alloca %struct.large
-  call void @callee_large_struct_ret(%struct.large* sret %1)
-  %2 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 0
-  %3 = load i32, i32* %2
-  %4 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 3
-  %5 = load i32, i32* %4
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
diff --git a/test/CodeGen/RISCV/calls.ll b/test/CodeGen/RISCV/calls.ll
deleted file mode 100644
index 4ef32fb7afb..00000000000
--- a/test/CodeGen/RISCV/calls.ll
+++ /dev/null
@@ -1,146 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-declare i32 @external_function(i32)
-
-define i32 @test_call_external(i32 %a) nounwind {
-; RV32I-LABEL: test_call_external:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call external_function
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @external_function(i32 %a)
-  ret i32 %1
-}
-
-define i32 @defined_function(i32 %a) nounwind {
-; RV32I-LABEL: defined_function:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @test_call_defined(i32 %a) nounwind {
-; RV32I-LABEL: test_call_defined:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call defined_function
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @defined_function(i32 %a)
-  ret i32 %1
-}
-
-define i32 @test_call_indirect(i32 (i32)* %a, i32 %b) nounwind {
-; RV32I-LABEL: test_call_indirect:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 %a(i32 %b)
-  ret i32 %1
-}
-
-; Ensure that calls to fastcc functions aren't rejected. Such calls may be
-; introduced when compiling with optimisation.
-
-define fastcc i32 @fastcc_function(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: fastcc_function:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
- %1 = add i32 %a, %b
- ret i32 %1
-}
-
-define i32 @test_call_fastcc(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: test_call_fastcc:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s1, 8(sp)
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    call fastcc_function
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    lw s1, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call fastcc i32 @fastcc_function(i32 %a, i32 %b)
-  ret i32 %a
-}
-
-declare i32 @external_many_args(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) nounwind
-
-define i32 @test_call_external_many_args(i32 %a) nounwind {
-; RV32I-LABEL: test_call_external_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s1, 8(sp)
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    sw a0, 4(sp)
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    mv a3, a0
-; RV32I-NEXT:    mv a4, a0
-; RV32I-NEXT:    mv a5, a0
-; RV32I-NEXT:    mv a6, a0
-; RV32I-NEXT:    mv a7, a0
-; RV32I-NEXT:    call external_many_args
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    lw s1, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @external_many_args(i32 %a, i32 %a, i32 %a, i32 %a, i32 %a,
-                                    i32 %a, i32 %a, i32 %a, i32 %a, i32 %a)
-  ret i32 %a
-}
-
-define i32 @defined_many_args(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 %j) nounwind {
-; RV32I-LABEL: defined_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a0, 4(sp)
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-  %added = add i32 %j, 1
-  ret i32 %added
-}
-
-define i32 @test_call_defined_many_args(i32 %a) nounwind {
-; RV32I-LABEL: test_call_defined_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a0, 4(sp)
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    mv a3, a0
-; RV32I-NEXT:    mv a4, a0
-; RV32I-NEXT:    mv a5, a0
-; RV32I-NEXT:    mv a6, a0
-; RV32I-NEXT:    mv a7, a0
-; RV32I-NEXT:    call defined_many_args
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @defined_many_args(i32 %a, i32 %a, i32 %a, i32 %a, i32 %a,
-                                   i32 %a, i32 %a, i32 %a, i32 %a, i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/compress-inline-asm.ll b/test/CodeGen/RISCV/compress-inline-asm.ll
deleted file mode 100644
index 9b84bdeaf5d..00000000000
--- a/test/CodeGen/RISCV/compress-inline-asm.ll
+++ /dev/null
@@ -1,15 +0,0 @@
-; RUN: llc -mtriple=riscv32 -mattr=+c  -filetype=obj < %s\
-; RUN: | llvm-objdump -triple=riscv32 -mattr=+c -d -riscv-no-aliases -\
-; RUN: | FileCheck -check-prefix=CHECK %s
-
-@ext = external global i32
-
-define i32 @compress_test(i32 %a) {
-; CHECK-LABEL: compress_test:
-; CHECK:    c.add a0, a1
-; CHECK-NEXT:    c.jr ra
-  %1 = load i32, i32* @ext
-  %2 = tail call i32 asm "add $0, $1, $2", "=r,r,r"(i32 %a, i32 %1)
-  ret i32 %2
-}
-
diff --git a/test/CodeGen/RISCV/compress.ll b/test/CodeGen/RISCV/compress.ll
deleted file mode 100644
index 2f0d4e9f257..00000000000
--- a/test/CodeGen/RISCV/compress.ll
+++ /dev/null
@@ -1,165 +0,0 @@
-; RUN: llc -mtriple=riscv32 -mattr=+c -filetype=obj \
-; RUN:   -disable-block-placement < %s \
-; RUN:   | llvm-objdump -d -triple=riscv32 -mattr=+c -riscv-no-aliases - \
-; RUN:   | FileCheck -check-prefix=RV32IC %s
-
-; This acts as a sanity check for the codegen instruction compression path,
-; verifying that the assembled file contains compressed instructions when
-; expected. Handling of the compressed ISA is implemented so the same
-; transformation patterns should be used whether compressing an input .s file or
-; compressing codegen output. This file contains sanity checks to ensure that is
-; working as expected. Particular care should be taken to test pseudo
-; instructions.
-
-; Note: TODOs in this file are only appropriate if they highlight a case where
-; a generated instruction that can be compressed by an existing pattern isn't.
-; It may be useful to have tests that indicate where better compression would be
-; possible if alternative codegen choices were made, but they belong in a
-; different test file.
-
-define i32 @simple_arith(i32 %a, i32 %b) nounwind {
-; RV32IC-LABEL: simple_arith:
-; RV32IC:         c.srai a1, 9
-; RV32IC-NEXT:    addi a2, a0, 1
-; RV32IC-NEXT:    c.andi a2, 11
-; RV32IC-NEXT:    c.slli a2, 7
-; RV32IC-NEXT:    c.add a1, a2
-; RV32IC-NEXT:    sub a0, a1, a0
-; RV32IC-NEXT:    c.jr ra
-  %1 = add i32 %a, 1
-  %2 = and i32 %1, 11
-  %3 = shl i32 %2, 7
-  %4 = ashr i32 %b, 9
-  %5 = add i32 %3, %4
-  %6 = sub i32 %5, %a
-  ret i32 %6
-}
-
-define i32 @select(i32 %a, i32 *%b) nounwind {
-; RV32IC-LABEL: select:
-; RV32IC:         c.lw a2, 0(a1)
-; RV32IC-NEXT:    c.beqz a2, 4
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    c.bnez a2, 4
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    bltu a2, a0, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    bgeu a0, a2, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    bltu a0, a2, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    bgeu a2, a0, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    blt a2, a0, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    bge a0, a2, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a2, 0(a1)
-; RV32IC-NEXT:    blt a0, a2, 6
-; RV32IC-NEXT:    c.mv a0, a2
-; RV32IC-NEXT:    c.lw a1, 0(a1)
-; RV32IC-NEXT:    bge a1, a0, 6
-; RV32IC-NEXT:    c.mv a0, a1
-; RV32IC-NEXT:    c.jr ra
-  %val1 = load volatile i32, i32* %b
-  %tst1 = icmp eq i32 0, %val1
-  %val2 = select i1 %tst1, i32 %a, i32 %val1
-
-  %val3 = load volatile i32, i32* %b
-  %tst2 = icmp ne i32 0, %val3
-  %val4 = select i1 %tst2, i32 %val2, i32 %val3
-
-  %val5 = load volatile i32, i32* %b
-  %tst3 = icmp ugt i32 %val4, %val5
-  %val6 = select i1 %tst3, i32 %val4, i32 %val5
-
-  %val7 = load volatile i32, i32* %b
-  %tst4 = icmp uge i32 %val6, %val7
-  %val8 = select i1 %tst4, i32 %val6, i32 %val7
-
-  %val9 = load volatile i32, i32* %b
-  %tst5 = icmp ult i32 %val8, %val9
-  %val10 = select i1 %tst5, i32 %val8, i32 %val9
-
-  %val11 = load volatile i32, i32* %b
-  %tst6 = icmp ule i32 %val10, %val11
-  %val12 = select i1 %tst6, i32 %val10, i32 %val11
-
-  %val13 = load volatile i32, i32* %b
-  %tst7 = icmp sgt i32 %val12, %val13
-  %val14 = select i1 %tst7, i32 %val12, i32 %val13
-
-  %val15 = load volatile i32, i32* %b
-  %tst8 = icmp sge i32 %val14, %val15
-  %val16 = select i1 %tst8, i32 %val14, i32 %val15
-
-  %val17 = load volatile i32, i32* %b
-  %tst9 = icmp slt i32 %val16, %val17
-  %val18 = select i1 %tst9, i32 %val16, i32 %val17
-
-  %val19 = load volatile i32, i32* %b
-  %tst10 = icmp sle i32 %val18, %val19
-  %val20 = select i1 %tst10, i32 %val18, i32 %val19
-
-  ret i32 %val20
-}
-
-define i32 @pos_tiny() nounwind {
-; RV32IC-LABEL: pos_tiny:
-; RV32IC:         c.li a0, 18
-; RV32IC-NEXT:    c.jr ra
-  ret i32 18
-}
-
-define i32 @pos_i32() nounwind {
-; RV32IC-LABEL: pos_i32:
-; RV32IC:         lui a0, 423811
-; RV32IC-NEXT:    addi a0, a0, -1297
-; RV32IC-NEXT:    c.jr ra
-  ret i32 1735928559
-}
-
-define i32 @pos_i32_half_compressible() nounwind {
-; RV32IC-LABEL: pos_i32_half_compressible:
-; RV32IC:         lui a0, 423810
-; RV32IC-NEXT:    c.addi  a0, 28
-; RV32IC-NEXT:    c.jr    ra
-  ret i32 1735925788
-}
-
-
-define i32 @neg_tiny() nounwind {
-; RV32IC-LABEL: neg_tiny:
-; RV32IC:       c.li a0, -19
-; RV32IC-NEXT:  c.jr ra
-  ret i32 -19
-}
-
-define i32 @neg_i32() nounwind {
-; RV32IC-LABEL: neg_i32:
-; RV32IC:       lui a0, 912092
-; RV32IC-NEXT:  addi a0, a0, -273
-; RV32IC-NEXT:  c.jr ra
-  ret i32 -559038737
-}
-
-define i32 @pos_i32_hi20_only() nounwind {
-; RV32IC-LABEL: pos_i32_hi20_only:
-; RV32IC:       c.lui a0, 16
-; RV32IC-NEXT:  c.jr ra
-  ret i32 65536
-}
-
-define i32 @neg_i32_hi20_only() nounwind {
-; RV32IC-LABEL: neg_i32_hi20_only:
-; RV32IC:       c.lui a0, 1048560
-; RV32IC-NEXT:  c.jr ra
-  ret i32 -65536
-}
diff --git a/test/CodeGen/RISCV/disable-tail-calls.ll b/test/CodeGen/RISCV/disable-tail-calls.ll
deleted file mode 100644
index 6ed5c2abc19..00000000000
--- a/test/CodeGen/RISCV/disable-tail-calls.ll
+++ /dev/null
@@ -1,56 +0,0 @@
-; Check that command line option "-disable-tail-calls" overrides function
-; attribute "disable-tail-calls".
-
-; RUN: llc < %s -mtriple=riscv32-unknown-elf \
-; RUN: | FileCheck %s --check-prefixes=CALLER1,NOTAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls \
-; RUN: | FileCheck %s --check-prefixes=CALLER1,NOTAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls=false \
-; RUN: | FileCheck %s --check-prefixes=CALLER1,TAIL
-
-; RUN: llc < %s -mtriple=riscv32-unknown-elf \
-; RUN: | FileCheck %s --check-prefixes=CALLER2,TAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls \
-; RUN: | FileCheck %s --check-prefixes=CALLER2,NOTAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls=false \
-; RUN: | FileCheck %s --check-prefixes=CALLER2,TAIL
-
-; RUN: llc < %s -mtriple=riscv32-unknown-elf \
-; RUN: | FileCheck %s --check-prefixes=CALLER3,TAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls \
-; RUN: | FileCheck %s --check-prefixes=CALLER3,NOTAIL
-; RUN: llc < %s -mtriple=riscv32-unknown-elf -disable-tail-calls=false \
-; RUN: | FileCheck %s --check-prefixes=CALLER3,TAIL
-
-; CALLER1-LABEL: {{\_?}}caller1
-; CALLER2-LABEL: {{\_?}}caller2
-; CALLER3-LABEL: {{\_?}}caller3
-; NOTAIL-NOT: tail callee
-; NOTAIL: call callee
-; TAIL: tail callee
-; TAIL-NOT: call callee
-
-; Function with attribute #0 = { "disable-tail-calls"="true" }
-define i32 @caller1(i32 %a) #0 {
-entry:
-  %call = tail call i32 @callee(i32 %a)
-  ret i32 %call
-}
-
-; Function with attribute #1 = { "disable-tail-calls"="false" }
-define i32 @caller2(i32 %a) #0 {
-entry:
-  %call = tail call i32 @callee(i32 %a)
-  ret i32 %call
-}
-
-define i32 @caller3(i32 %a) {
-entry:
-  %call = tail call i32 @callee(i32 %a)
-  ret i32 %call
-}
-
-declare i32 @callee(i32)
-
-attributes #0 = { "disable-tail-calls"="true" }
-attributes #1 = { "disable-tail-calls"="false" }
diff --git a/test/CodeGen/RISCV/div.ll b/test/CodeGen/RISCV/div.ll
deleted file mode 100644
index da9df17ccd4..00000000000
--- a/test/CodeGen/RISCV/div.ll
+++ /dev/null
@@ -1,217 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @udiv(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: udiv:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __udivsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    divu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @udiv_constant(i32 %a) nounwind {
-; RV32I-LABEL: udiv_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __udivsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    lui a1, 838861
-; RV32IM-NEXT:    addi a1, a1, -819
-; RV32IM-NEXT:    mulhu a0, a0, a1
-; RV32IM-NEXT:    srli a0, a0, 2
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @udiv_pow2(i32 %a) nounwind {
-; RV32I-LABEL: udiv_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    srli a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @udiv64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: udiv64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __udivdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    call __udivdi3
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = udiv i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @udiv64_constant(i64 %a) nounwind {
-; RV32I-LABEL: udiv64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __udivdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mv a3, zero
-; RV32IM-NEXT:    call __udivdi3
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = udiv i64 %a, 5
-  ret i64 %1
-}
-
-define i32 @sdiv(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sdiv:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __divsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    div a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sdiv_constant(i32 %a) nounwind {
-; RV32I-LABEL: sdiv_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __divsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    lui a1, 419430
-; RV32IM-NEXT:    addi a1, a1, 1639
-; RV32IM-NEXT:    mulh a0, a0, a1
-; RV32IM-NEXT:    srli a1, a0, 31
-; RV32IM-NEXT:    srai a0, a0, 1
-; RV32IM-NEXT:    add a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @sdiv_pow2(i32 %a) nounwind {
-; RV32I-LABEL: sdiv_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    srli a1, a1, 29
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    srai a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    srai a1, a0, 31
-; RV32IM-NEXT:    srli a1, a1, 29
-; RV32IM-NEXT:    add a0, a0, a1
-; RV32IM-NEXT:    srai a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @sdiv64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: sdiv64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __divdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    call __divdi3
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = sdiv i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @sdiv64_constant(i64 %a) nounwind {
-; RV32I-LABEL: sdiv64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __divdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mv a3, zero
-; RV32IM-NEXT:    call __divdi3
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = sdiv i64 %a, 5
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/double-arith.ll b/test/CodeGen/RISCV/double-arith.ll
deleted file mode 100644
index cd3a1d96378..00000000000
--- a/test/CodeGen/RISCV/double-arith.ll
+++ /dev/null
@@ -1,398 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-; These tests are each targeted at a particular RISC-V FPU instruction. Most
-; other files in this folder exercise LLVM IR instructions that don't directly
-; match a RISC-V instruction.
-
-define double @fadd_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fadd_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %a, %b
-  ret double %1
-}
-
-define double @fsub_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fsub_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fsub.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fsub double %a, %b
-  ret double %1
-}
-
-define double @fmul_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fmul_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmul.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fmul double %a, %b
-  ret double %1
-}
-
-define double @fdiv_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fdiv_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fdiv.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fdiv double %a, %b
-  ret double %1
-}
-
-declare double @llvm.sqrt.f32(double)
-
-define double @fsqrt_d(double %a) nounwind {
-; RV32IFD-LABEL: fsqrt_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fsqrt.d ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.sqrt.f32(double %a)
-  ret double %1
-}
-
-declare double @llvm.copysign.f32(double, double)
-
-define double @fsgnj_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fsgnj_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fsgnj.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.copysign.f32(double %a, double %b)
-  ret double %1
-}
-
-define double @fneg_d(double %a) nounwind {
-; RV32IFD-LABEL: fneg_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fneg.d ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fsub double -0.0, %a
-  ret double %1
-}
-
-define double @fsgnjn_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fsgnjn_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fsgnjn.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fsub double -0.0, %b
-  %2 = call double @llvm.copysign.f32(double %a, double %1)
-  ret double %2
-}
-
-declare double @llvm.fabs.f32(double)
-
-define double @fabs_d(double %a) nounwind {
-; RV32IFD-LABEL: fabs_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fabs.d ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.fabs.f32(double %a)
-  ret double %1
-}
-
-declare double @llvm.minnum.f32(double, double)
-
-define double @fmin_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fmin_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmin.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.minnum.f32(double %a, double %b)
-  ret double %1
-}
-
-declare double @llvm.maxnum.f32(double, double)
-
-define double @fmax_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fmax_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmax.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.maxnum.f32(double %a, double %b)
-  ret double %1
-}
-
-define i32 @feq_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: feq_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oeq double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @flt_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: flt_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp olt double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fle_d(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fle_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ole double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-declare double @llvm.fma.f64(double, double, double)
-
-define double @fmadd_d(double %a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fmadd_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft2, 8(sp)
-; RV32IFD-NEXT:    fmadd.d ft0, ft2, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.fma.f64(double %a, double %b, double %c)
-  ret double %1
-}
-
-define double @fmsub_d(double %a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fmsub_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft2, 8(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI15_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI15_0)
-; RV32IFD-NEXT:    fld ft3, 0(a0)
-; RV32IFD-NEXT:    fadd.d ft2, ft2, ft3
-; RV32IFD-NEXT:    fmsub.d ft0, ft1, ft0, ft2
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %c_ = fadd double 0.0, %c ; avoid negation using xor
-  %negc = fsub double -0.0, %c_
-  %1 = call double @llvm.fma.f64(double %a, double %b, double %negc)
-  ret double %1
-}
-
-define double @fnmadd_d(double %a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fnmadd_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft2, 8(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI16_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI16_0)
-; RV32IFD-NEXT:    fld ft3, 0(a0)
-; RV32IFD-NEXT:    fadd.d ft2, ft2, ft3
-; RV32IFD-NEXT:    fadd.d ft1, ft1, ft3
-; RV32IFD-NEXT:    fnmadd.d ft0, ft1, ft0, ft2
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %a_ = fadd double 0.0, %a
-  %c_ = fadd double 0.0, %c
-  %nega = fsub double -0.0, %a_
-  %negc = fsub double -0.0, %c_
-  %1 = call double @llvm.fma.f64(double %nega, double %b, double %negc)
-  ret double %1
-}
-
-define double @fnmsub_d(double %a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fnmsub_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft2, 8(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI17_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI17_0)
-; RV32IFD-NEXT:    fld ft3, 0(a0)
-; RV32IFD-NEXT:    fadd.d ft2, ft2, ft3
-; RV32IFD-NEXT:    fnmsub.d ft0, ft2, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %a_ = fadd double 0.0, %a
-  %nega = fsub double -0.0, %a_
-  %1 = call double @llvm.fma.f64(double %nega, double %b, double %c)
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-br-fcmp.ll b/test/CodeGen/RISCV/double-br-fcmp.ll
deleted file mode 100644
index d1055c66586..00000000000
--- a/test/CodeGen/RISCV/double-br-fcmp.ll
+++ /dev/null
@@ -1,500 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-declare void @abort()
-declare void @exit(i32)
-
-define void @br_fcmp_false(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_false:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    addi a0, zero, 1
-; RV32IFD-NEXT:    bnez a0, .LBB0_2
-; RV32IFD-NEXT:  # %bb.1: # %if.then
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB0_2: # %if.else
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp false double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.then:
-  ret void
-if.else:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_oeq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_oeq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB1_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB1_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp oeq double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-; TODO: generated code quality for this is very poor due to
-; DAGCombiner::visitXOR converting the legal setoeq to setune, which requires
-; expansion.
-define void @br_fcmp_oeq_alt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_oeq_alt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    beqz a0, .LBB2_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB2_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp oeq double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.then:
-  tail call void @abort()
-  unreachable
-if.else:
-  ret void
-}
-
-define void @br_fcmp_ogt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ogt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB3_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB3_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ogt double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_oge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_oge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB4_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB4_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp oge double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_olt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_olt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB5_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB5_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp olt double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ole(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ole:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB6_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB6_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ole double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-; TODO: feq.s+sltiu+bne -> feq.s+beq
-define void @br_fcmp_one(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_one:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft1
-; RV32IFD-NEXT:    not a1, a1
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    bnez a0, .LBB7_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB7_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp one double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ord(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ord:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB8_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB8_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ord double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ueq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ueq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    feq.d a2, ft1, ft1
-; RV32IFD-NEXT:    and a1, a2, a1
-; RV32IFD-NEXT:    seqz a1, a1
-; RV32IFD-NEXT:    or a0, a0, a1
-; RV32IFD-NEXT:    bnez a0, .LBB9_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB9_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ueq double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ugt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ugt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB10_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB10_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ugt double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_uge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_uge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB11_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB11_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp uge double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ult(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ult:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB12_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB12_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ult double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ule(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_ule:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB13_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB13_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp ule double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_une(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_une:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB14_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB14_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp une double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_uno(double %a, double %b) nounwind {
-; TODO: sltiu+bne -> beq
-; RV32IFD-LABEL: br_fcmp_uno:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw a2, 0(sp)
-; RV32IFD-NEXT:    sw a3, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    bnez a0, .LBB15_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB15_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp uno double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_true(double %a, double %b) nounwind {
-; RV32IFD-LABEL: br_fcmp_true:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    addi a0, zero, 1
-; RV32IFD-NEXT:    bnez a0, .LBB16_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; RV32IFD-NEXT:  .LBB16_2: # %if.then
-; RV32IFD-NEXT:    call abort
-  %1 = fcmp true double %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
diff --git a/test/CodeGen/RISCV/double-calling-conv.ll b/test/CodeGen/RISCV/double-calling-conv.ll
deleted file mode 100644
index 5e9382fdf69..00000000000
--- a/test/CodeGen/RISCV/double-calling-conv.ll
+++ /dev/null
@@ -1,154 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-; Sanity checks for calling convention lowering for RV32D. This can be
-; somewhat error-prone for soft-float RV32D due to the fact that f64 is legal
-; but i64 is not, and there is no instruction to move values directly between
-; the GPRs and 64-bit FPRs.
-
-define double @callee_double_inreg(double %a, double %b) nounwind {
-; RV32IFD-LABEL: callee_double_inreg:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %a, %b
-  ret double %1
-}
-
-; TODO: code quality for loading and then passing f64 constants is poor.
-
-define double @caller_double_inreg() nounwind {
-; RV32IFD-LABEL: caller_double_inreg:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI1_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI1_0)
-; RV32IFD-NEXT:    fld ft0, 0(a0)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI1_1)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI1_1)
-; RV32IFD-NEXT:    fld ft1, 0(a0)
-; RV32IFD-NEXT:    fsd ft1, 0(sp)
-; RV32IFD-NEXT:    lw a0, 0(sp)
-; RV32IFD-NEXT:    lw a1, 4(sp)
-; RV32IFD-NEXT:    fsd ft0, 0(sp)
-; RV32IFD-NEXT:    lw a2, 0(sp)
-; RV32IFD-NEXT:    lw a3, 4(sp)
-; RV32IFD-NEXT:    call callee_double_inreg
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @callee_double_inreg(double 2.720000e+00, double 3.720000e+00)
-  ret double %1
-}
-
-define double @callee_double_split_reg_stack(i32 %a, i64 %b, i64 %c, double %d, double %e) nounwind {
-; RV32IFD-LABEL: callee_double_split_reg_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    lw a0, 16(sp)
-; RV32IFD-NEXT:    sw a7, 8(sp)
-; RV32IFD-NEXT:    sw a0, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a5, 8(sp)
-; RV32IFD-NEXT:    sw a6, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %d, %e
-  ret double %1
-}
-
-define double @caller_double_split_reg_stack() nounwind {
-; RV32IFD-LABEL: caller_double_split_reg_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI3_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI3_0)
-; RV32IFD-NEXT:    fld ft0, 0(a0)
-; RV32IFD-NEXT:    fsd ft0, 16(sp)
-; RV32IFD-NEXT:    lw a7, 16(sp)
-; RV32IFD-NEXT:    lw a0, 20(sp)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI3_1)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI3_1)
-; RV32IFD-NEXT:    fld ft0, 0(a0)
-; RV32IFD-NEXT:    fsd ft0, 16(sp)
-; RV32IFD-NEXT:    lw a5, 16(sp)
-; RV32IFD-NEXT:    lw a6, 20(sp)
-; RV32IFD-NEXT:    addi a0, zero, 1
-; RV32IFD-NEXT:    addi a1, zero, 2
-; RV32IFD-NEXT:    addi a3, zero, 3
-; RV32IFD-NEXT:    mv a2, zero
-; RV32IFD-NEXT:    mv a4, zero
-; RV32IFD-NEXT:    call callee_double_split_reg_stack
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-  %1 = call double @callee_double_split_reg_stack(i32 1, i64 2, i64 3, double 4.72, double 5.72)
-  ret double %1
-}
-
-define double @callee_double_stack(i64 %a, i64 %b, i64 %c, i64 %d, double %e, double %f) nounwind {
-; RV32IFD-LABEL: callee_double_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    fld ft0, 24(sp)
-; RV32IFD-NEXT:    fld ft1, 16(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %e, %f
-  ret double %1
-}
-
-define double @caller_double_stack() nounwind {
-; RV32IFD-LABEL: caller_double_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    lui a0, 262510
-; RV32IFD-NEXT:    addi a0, a0, 327
-; RV32IFD-NEXT:    sw a0, 4(sp)
-; RV32IFD-NEXT:    lui a0, 262574
-; RV32IFD-NEXT:    addi a0, a0, 327
-; RV32IFD-NEXT:    sw a0, 12(sp)
-; RV32IFD-NEXT:    lui a0, 713032
-; RV32IFD-NEXT:    addi a0, a0, -1311
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    addi a0, zero, 1
-; RV32IFD-NEXT:    addi a2, zero, 2
-; RV32IFD-NEXT:    addi a4, zero, 3
-; RV32IFD-NEXT:    addi a6, zero, 4
-; RV32IFD-NEXT:    mv a1, zero
-; RV32IFD-NEXT:    mv a3, zero
-; RV32IFD-NEXT:    mv a5, zero
-; RV32IFD-NEXT:    mv a7, zero
-; RV32IFD-NEXT:    call callee_double_stack
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-  %1 = call double @callee_double_stack(i64 1, i64 2, i64 3, i64 4, double 5.72, double 6.72)
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-convert.ll b/test/CodeGen/RISCV/double-convert.ll
deleted file mode 100644
index 44de78dc740..00000000000
--- a/test/CodeGen/RISCV/double-convert.ll
+++ /dev/null
@@ -1,89 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define float @fcvt_s_d(double %a) nounwind {
-; RV32IFD-LABEL: fcvt_s_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fcvt.s.d ft0, ft0
-; RV32IFD-NEXT:    fmv.x.w a0, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fptrunc double %a to float
-  ret float %1
-}
-
-define double @fcvt_d_s(float %a) nounwind {
-; RV32IFD-LABEL: fcvt_d_s:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    fmv.w.x ft0, a0
-; RV32IFD-NEXT:    fcvt.d.s ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fpext float %a to double
-  ret double %1
-}
-
-define i32 @fcvt_w_d(double %a) nounwind {
-; RV32IFD-LABEL: fcvt_w_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fcvt.w.d a0, ft0, rtz
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fptosi double %a to i32
-  ret i32 %1
-}
-
-define i32 @fcvt_wu_d(double %a) nounwind {
-; RV32IFD-LABEL: fcvt_wu_d:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fcvt.wu.d a0, ft0, rtz
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fptoui double %a to i32
-  ret i32 %1
-}
-
-define double @fcvt_d_w(i32 %a) nounwind {
-; RV32IFD-LABEL: fcvt_d_w:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    fcvt.d.w ft0, a0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = sitofp i32 %a to double
-  ret double %1
-}
-
-define double @fcvt_d_wu(i32 %a) nounwind {
-; RV32IFD-LABEL: fcvt_d_wu:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    fcvt.d.wu ft0, a0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = uitofp i32 %a to double
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-fcmp.ll b/test/CodeGen/RISCV/double-fcmp.ll
deleted file mode 100644
index adcd804122b..00000000000
--- a/test/CodeGen/RISCV/double-fcmp.ll
+++ /dev/null
@@ -1,299 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define i32 @fcmp_false(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_false:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    mv a0, zero
-; RV32IFD-NEXT:    ret
-  %1 = fcmp false double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_oeq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_oeq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oeq double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ogt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ogt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ogt double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_oge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_oge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oge double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_olt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_olt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp olt double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ole(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ole:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ole double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_one(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_one:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft1
-; RV32IFD-NEXT:    not a1, a1
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp one double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ord(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ord:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ord double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ueq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ueq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    feq.d a2, ft1, ft1
-; RV32IFD-NEXT:    and a1, a2, a1
-; RV32IFD-NEXT:    seqz a1, a1
-; RV32IFD-NEXT:    or a0, a0, a1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ueq double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ugt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ugt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ugt double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_uge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_uge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp uge double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ult(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ult:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ult double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ule(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_ule:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ule double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_une(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_une:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp une double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_uno(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_uno:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp uno double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_true(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fcmp_true:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi a0, zero, 1
-; RV32IFD-NEXT:    ret
-  %1 = fcmp true double %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/double-frem.ll b/test/CodeGen/RISCV/double-frem.ll
deleted file mode 100644
index 07f84ac11ce..00000000000
--- a/test/CodeGen/RISCV/double-frem.ll
+++ /dev/null
@@ -1,16 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32ID %s
-
-define double @frem_f64(double %a, double %b) nounwind {
-; RV32ID-LABEL: frem_f64:
-; RV32ID:       # %bb.0:
-; RV32ID-NEXT:    addi sp, sp, -16
-; RV32ID-NEXT:    sw ra, 12(sp)
-; RV32ID-NEXT:    call fmod
-; RV32ID-NEXT:    lw ra, 12(sp)
-; RV32ID-NEXT:    addi sp, sp, 16
-; RV32ID-NEXT:    ret
-  %1 = frem double %a, %b
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-imm.ll b/test/CodeGen/RISCV/double-imm.ll
deleted file mode 100644
index a652d862175..00000000000
--- a/test/CodeGen/RISCV/double-imm.ll
+++ /dev/null
@@ -1,38 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define double @double_imm() nounwind {
-; RV32IFD-LABEL: double_imm:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI0_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI0_0)
-; RV32IFD-NEXT:    fld ft0, 0(a0)
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  ret double 3.1415926535897931159979634685441851615905761718750
-}
-
-define double @double_imm_op(double %a) nounwind {
-; RV32IFD-LABEL: double_imm_op:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI1_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI1_0)
-; RV32IFD-NEXT:    fld ft1, 0(a0)
-; RV32IFD-NEXT:    fadd.d ft0, ft0, ft1
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %a, 1.0
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-intrinsics.ll b/test/CodeGen/RISCV/double-intrinsics.ll
deleted file mode 100644
index cd14c1932d4..00000000000
--- a/test/CodeGen/RISCV/double-intrinsics.ll
+++ /dev/null
@@ -1,442 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-declare double @llvm.sqrt.f64(double)
-
-define double @sqrt_f64(double %a) nounwind {
-; RV32IFD-LABEL: sqrt_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fsqrt.d ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.sqrt.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.powi.f64(double, i32)
-
-define double @powi_f64(double %a, i32 %b) nounwind {
-; RV32IFD-LABEL: powi_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call __powidf2
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.powi.f64(double %a, i32 %b)
-  ret double %1
-}
-
-declare double @llvm.sin.f64(double)
-
-define double @sin_f64(double %a) nounwind {
-; RV32IFD-LABEL: sin_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call sin
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.sin.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.cos.f64(double)
-
-define double @cos_f64(double %a) nounwind {
-; RV32IFD-LABEL: cos_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call cos
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.cos.f64(double %a)
-  ret double %1
-}
-
-; The sin+cos combination results in an FSINCOS SelectionDAG node.
-define double @sincos_f64(double %a) nounwind {
-; RV32IFD-LABEL: sincos_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    sw s1, 24(sp)
-; RV32IFD-NEXT:    sw s2, 20(sp)
-; RV32IFD-NEXT:    sw s3, 16(sp)
-; RV32IFD-NEXT:    sw s4, 12(sp)
-; RV32IFD-NEXT:    mv s2, a1
-; RV32IFD-NEXT:    mv s1, a0
-; RV32IFD-NEXT:    call sin
-; RV32IFD-NEXT:    mv s3, a0
-; RV32IFD-NEXT:    mv s4, a1
-; RV32IFD-NEXT:    mv a0, s1
-; RV32IFD-NEXT:    mv a1, s2
-; RV32IFD-NEXT:    call cos
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    sw s3, 0(sp)
-; RV32IFD-NEXT:    sw s4, 4(sp)
-; RV32IFD-NEXT:    fld ft1, 0(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 0(sp)
-; RV32IFD-NEXT:    lw a0, 0(sp)
-; RV32IFD-NEXT:    lw a1, 4(sp)
-; RV32IFD-NEXT:    lw s4, 12(sp)
-; RV32IFD-NEXT:    lw s3, 16(sp)
-; RV32IFD-NEXT:    lw s2, 20(sp)
-; RV32IFD-NEXT:    lw s1, 24(sp)
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.sin.f64(double %a)
-  %2 = call double @llvm.cos.f64(double %a)
-  %3 = fadd double %1, %2
-  ret double %3
-}
-
-declare double @llvm.pow.f64(double, double)
-
-define double @pow_f64(double %a, double %b) nounwind {
-; RV32IFD-LABEL: pow_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call pow
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.pow.f64(double %a, double %b)
-  ret double %1
-}
-
-declare double @llvm.exp.f64(double)
-
-define double @exp_f64(double %a) nounwind {
-; RV32IFD-LABEL: exp_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call exp
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.exp.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.exp2.f64(double)
-
-define double @exp2_f64(double %a) nounwind {
-; RV32IFD-LABEL: exp2_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call exp2
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.exp2.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.log.f64(double)
-
-define double @log_f64(double %a) nounwind {
-; RV32IFD-LABEL: log_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call log
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.log.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.log10.f64(double)
-
-define double @log10_f64(double %a) nounwind {
-; RV32IFD-LABEL: log10_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call log10
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.log10.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.log2.f64(double)
-
-define double @log2_f64(double %a) nounwind {
-; RV32IFD-LABEL: log2_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call log2
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.log2.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.fma.f64(double, double, double)
-
-define double @fma_f64(double %a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fma_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft2, 8(sp)
-; RV32IFD-NEXT:    fmadd.d ft0, ft2, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.fma.f64(double %a, double %b, double %c)
-  ret double %1
-}
-
-declare double @llvm.fmuladd.f64(double, double, double)
-
-define double @fmuladd_f64(double %a, double %b, double %c) nounwind {
-; Use of fmadd depends on TargetLowering::isFMAFasterthanFMulAndFAdd
-; RV32IFD-LABEL: fmuladd_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmul.d ft0, ft1, ft0
-; RV32IFD-NEXT:    sw a4, 8(sp)
-; RV32IFD-NEXT:    sw a5, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft0, ft1
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.fmuladd.f64(double %a, double %b, double %c)
-  ret double %1
-}
-
-declare double @llvm.fabs.f64(double)
-
-define double @fabs_f64(double %a) nounwind {
-; RV32IFD-LABEL: fabs_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fabs.d ft0, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.fabs.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.minnum.f64(double, double)
-
-define double @minnum_f64(double %a, double %b) nounwind {
-; RV32IFD-LABEL: minnum_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmin.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.minnum.f64(double %a, double %b)
-  ret double %1
-}
-
-declare double @llvm.maxnum.f64(double, double)
-
-define double @maxnum_f64(double %a, double %b) nounwind {
-; RV32IFD-LABEL: maxnum_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fmax.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.maxnum.f64(double %a, double %b)
-  ret double %1
-}
-
-; TODO: FMINNAN and FMAXNAN aren't handled in
-; SelectionDAGLegalize::ExpandNode.
-
-; declare double @llvm.minimum.f64(double, double)
-
-; define double @fminimum_f64(double %a, double %b) nounwind {
-;   %1 = call double @llvm.minimum.f64(double %a, double %b)
-;   ret double %1
-; }
-
-; declare double @llvm.maximum.f64(double, double)
-
-; define double @fmaximum_f64(double %a, double %b) nounwind {
-;   %1 = call double @llvm.maximum.f64(double %a, double %b)
-;   ret double %1
-; }
-
-declare double @llvm.copysign.f64(double, double)
-
-define double @copysign_f64(double %a, double %b) nounwind {
-; RV32IFD-LABEL: copysign_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fsgnj.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.copysign.f64(double %a, double %b)
-  ret double %1
-}
-
-declare double @llvm.floor.f64(double)
-
-define double @floor_f64(double %a) nounwind {
-; RV32IFD-LABEL: floor_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call floor
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.floor.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.ceil.f64(double)
-
-define double @ceil_f64(double %a) nounwind {
-; RV32IFD-LABEL: ceil_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call ceil
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.ceil.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.trunc.f64(double)
-
-define double @trunc_f64(double %a) nounwind {
-; RV32IFD-LABEL: trunc_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call trunc
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.trunc.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.rint.f64(double)
-
-define double @rint_f64(double %a) nounwind {
-; RV32IFD-LABEL: rint_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call rint
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.rint.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.nearbyint.f64(double)
-
-define double @nearbyint_f64(double %a) nounwind {
-; RV32IFD-LABEL: nearbyint_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call nearbyint
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.nearbyint.f64(double %a)
-  ret double %1
-}
-
-declare double @llvm.round.f64(double)
-
-define double @round_f64(double %a) nounwind {
-; RV32IFD-LABEL: round_f64:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    call round
-; RV32IFD-NEXT:    lw ra, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = call double @llvm.round.f64(double %a)
-  ret double %1
-}
diff --git a/test/CodeGen/RISCV/double-mem.ll b/test/CodeGen/RISCV/double-mem.ll
deleted file mode 100644
index 5b20447ed73..00000000000
--- a/test/CodeGen/RISCV/double-mem.ll
+++ /dev/null
@@ -1,185 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define double @fld(double *%a) nounwind {
-; RV32IFD-LABEL: fld:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    fld ft0, 24(a0)
-; RV32IFD-NEXT:    fld ft1, 0(a0)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = load double, double* %a
-  %2 = getelementptr double, double* %a, i32 3
-  %3 = load double, double* %2
-; Use both loaded values in an FP op to ensure an fld is used, even for the
-; soft float ABI
-  %4 = fadd double %1, %3
-  ret double %4
-}
-
-define void @fsd(double *%a, double %b, double %c) nounwind {
-; RV32IFD-LABEL: fsd:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a3, 8(sp)
-; RV32IFD-NEXT:    sw a4, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 8(sp)
-; RV32IFD-NEXT:    sw a2, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 64(a0)
-; RV32IFD-NEXT:    fsd ft0, 0(a0)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; Use %b and %c in an FP op to ensure floating point registers are used, even
-; for the soft float ABI
-  %1 = fadd double %b, %c
-  store double %1, double* %a
-  %2 = getelementptr double, double* %a, i32 8
-  store double %1, double* %2
-  ret void
-}
-
-; Check load and store to a global
-@G = global double 0.0
-
-define double @fld_fsd_global(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fld_fsd_global:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    lui a0, %hi(G)
-; RV32IFD-NEXT:    fld ft1, %lo(G)(a0)
-; RV32IFD-NEXT:    fsd ft0, %lo(G)(a0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(G)
-; RV32IFD-NEXT:    fld ft1, 72(a0)
-; RV32IFD-NEXT:    fsd ft0, 72(a0)
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-; Use %a and %b in an FP op to ensure floating point registers are used, even
-; for the soft float ABI
-  %1 = fadd double %a, %b
-  %2 = load volatile double, double* @G
-  store double %1, double* @G
-  %3 = getelementptr double, double* @G, i32 9
-  %4 = load volatile double, double* %3
-  store double %1, double* %3
-  ret double %1
-}
-
-; Ensure that 1 is added to the high 20 bits if bit 11 of the low part is 1
-define double @fld_fsd_constant(double %a) nounwind {
-; RV32IFD-LABEL: fld_fsd_constant:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    lui a0, 912092
-; RV32IFD-NEXT:    fld ft1, -273(a0)
-; RV32IFD-NEXT:    fadd.d ft0, ft0, ft1
-; RV32IFD-NEXT:    fsd ft0, -273(a0)
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = inttoptr i32 3735928559 to double*
-  %2 = load volatile double, double* %1
-  %3 = fadd double %a, %2
-  store double %3, double* %1
-  ret double %3
-}
-
-declare void @notdead(i8*)
-
-define double @fld_stack(double %a) nounwind {
-; RV32IFD-LABEL: fld_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    sw s1, 24(sp)
-; RV32IFD-NEXT:    sw s2, 20(sp)
-; RV32IFD-NEXT:    mv s2, a1
-; RV32IFD-NEXT:    mv s1, a0
-; RV32IFD-NEXT:    addi a0, sp, 8
-; RV32IFD-NEXT:    call notdead
-; RV32IFD-NEXT:    sw s1, 0(sp)
-; RV32IFD-NEXT:    sw s2, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 0(sp)
-; RV32IFD-NEXT:    lw a0, 0(sp)
-; RV32IFD-NEXT:    lw a1, 4(sp)
-; RV32IFD-NEXT:    lw s2, 20(sp)
-; RV32IFD-NEXT:    lw s1, 24(sp)
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-  %1 = alloca double, align 8
-  %2 = bitcast double* %1 to i8*
-  call void @notdead(i8* %2)
-  %3 = load double, double* %1
-  %4 = fadd double %3, %a ; force load in to FPR64
-  ret double %4
-}
-
-define void @fsd_stack(double %a, double %b) nounwind {
-; RV32IFD-LABEL: fsd_stack:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft1, ft0
-; RV32IFD-NEXT:    fsd ft0, 16(sp)
-; RV32IFD-NEXT:    addi a0, sp, 16
-; RV32IFD-NEXT:    call notdead
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-  %1 = fadd double %a, %b ; force store from FPR64
-  %2 = alloca double, align 8
-  store double %1, double* %2
-  %3 = bitcast double* %2 to i8*
-  call void @notdead(i8* %3)
-  ret void
-}
-
-; Test selection of store<ST4[%a], trunc to f32>, ..
-define void @fsd_trunc(float* %a, double %b) nounwind noinline optnone {
-; RV32IFD-LABEL: fsd_trunc:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a1, 8(sp)
-; RV32IFD-NEXT:    sw a2, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    fcvt.s.d ft0, ft0
-; RV32IFD-NEXT:    fsw ft0, 0(a0)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fptrunc double %b to float
-  store float %1, float* %a, align 4
-  ret void
-}
diff --git a/test/CodeGen/RISCV/double-previous-failure.ll b/test/CodeGen/RISCV/double-previous-failure.ll
deleted file mode 100644
index 3a07e5d5858..00000000000
--- a/test/CodeGen/RISCV/double-previous-failure.ll
+++ /dev/null
@@ -1,65 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define double @test(double %a) nounwind {
-; RV32IFD-LABEL: test:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    ret
-  ret double %a
-}
-
-; This previously failed complaining of multiple vreg defs due to an ABI
-; lowering issue.
-
-define i32 @main() nounwind {
-; RV32IFD-LABEL: main:
-; RV32IFD:       # %bb.0: # %entry
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw ra, 12(sp)
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI1_0)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI1_0)
-; RV32IFD-NEXT:    fld ft0, 0(a0)
-; RV32IFD-NEXT:    fsd ft0, 0(sp)
-; RV32IFD-NEXT:    lw a0, 0(sp)
-; RV32IFD-NEXT:    lw a1, 4(sp)
-; RV32IFD-NEXT:    call test
-; RV32IFD-NEXT:    lui a2, %hi(.LCPI1_1)
-; RV32IFD-NEXT:    addi a2, a2, %lo(.LCPI1_1)
-; RV32IFD-NEXT:    fld ft1, 0(a2)
-; RV32IFD-NEXT:    sw a0, 0(sp)
-; RV32IFD-NEXT:    sw a1, 4(sp)
-; RV32IFD-NEXT:    fld ft0, 0(sp)
-; RV32IFD-NEXT:    flt.d a0, ft0, ft1
-; RV32IFD-NEXT:    bnez a0, .LBB1_3
-; RV32IFD-NEXT:  # %bb.1: # %entry
-; RV32IFD-NEXT:    lui a0, %hi(.LCPI1_2)
-; RV32IFD-NEXT:    addi a0, a0, %lo(.LCPI1_2)
-; RV32IFD-NEXT:    fld ft1, 0(a0)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    beqz a0, .LBB1_3
-; RV32IFD-NEXT:  # %bb.2: # %if.end
-; RV32IFD-NEXT:    mv a0, zero
-; RV32IFD-NEXT:    call exit
-; RV32IFD-NEXT:  .LBB1_3: # %if.then
-; RV32IFD-NEXT:    call abort
-entry:
-  %call = call double @test(double 2.000000e+00)
-  %cmp = fcmp olt double %call, 2.400000e-01
-  %cmp2 = fcmp ogt double %call, 2.600000e-01
-  %or.cond = or i1 %cmp, %cmp2
-  br i1 %or.cond, label %if.then, label %if.end
-
-if.then:
-  call void @abort()
-  unreachable
-
-if.end:
-  call void @exit(i32 0)
-  unreachable
-}
-
-declare void @abort()
-
-declare void @exit(i32)
diff --git a/test/CodeGen/RISCV/double-select-fcmp.ll b/test/CodeGen/RISCV/double-select-fcmp.ll
deleted file mode 100644
index fa10ee25724..00000000000
--- a/test/CodeGen/RISCV/double-select-fcmp.ll
+++ /dev/null
@@ -1,423 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define double @select_fcmp_false(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_false:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    mv a1, a3
-; RV32IFD-NEXT:    mv a0, a2
-; RV32IFD-NEXT:    ret
-  %1 = fcmp false double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_oeq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_oeq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB1_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB1_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oeq double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ogt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ogt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB2_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB2_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ogt double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_oge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_oge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB3_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB3_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oge double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_olt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_olt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB4_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB4_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp olt double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ole(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ole:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB5_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB5_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ole double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_one(double %a, double %b) nounwind {
-; TODO: feq.s+sltiu+bne sequence could be optimised
-; RV32IFD-LABEL: select_fcmp_one:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft1
-; RV32IFD-NEXT:    not a1, a1
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    bnez a0, .LBB6_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB6_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp one double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ord(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ord:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB7_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB7_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ord double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ueq(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ueq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    feq.d a1, ft0, ft1
-; RV32IFD-NEXT:    or a0, a1, a0
-; RV32IFD-NEXT:    bnez a0, .LBB8_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB8_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ueq double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ugt(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ugt:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB9_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB9_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ugt double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_uge(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_uge:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB10_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB10_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp uge double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ult(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ult:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fle.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB11_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB11_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ult double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_ule(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_ule:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    flt.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB12_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB12_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp ule double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_une(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_une:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    xori a0, a0, 1
-; RV32IFD-NEXT:    bnez a0, .LBB13_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft1, ft0
-; RV32IFD-NEXT:  .LBB13_2:
-; RV32IFD-NEXT:    fsd ft1, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp une double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_uno(double %a, double %b) nounwind {
-; TODO: sltiu+bne could be optimized
-; RV32IFD-LABEL: select_fcmp_uno:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft1
-; RV32IFD-NEXT:    feq.d a1, ft0, ft0
-; RV32IFD-NEXT:    and a0, a1, a0
-; RV32IFD-NEXT:    seqz a0, a0
-; RV32IFD-NEXT:    bnez a0, .LBB14_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    fmv.d ft0, ft1
-; RV32IFD-NEXT:  .LBB14_2:
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    lw a0, 8(sp)
-; RV32IFD-NEXT:    lw a1, 12(sp)
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp uno double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-define double @select_fcmp_true(double %a, double %b) nounwind {
-; RV32IFD-LABEL: select_fcmp_true:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    ret
-  %1 = fcmp true double %a, %b
-  %2 = select i1 %1, double %a, double %b
-  ret double %2
-}
-
-; Ensure that ISel succeeds for a select+fcmp that has an i32 result type.
-define i32 @i32_select_fcmp_oeq(double %a, double %b, i32 %c, i32 %d) nounwind {
-; RV32IFD-LABEL: i32_select_fcmp_oeq:
-; RV32IFD:       # %bb.0:
-; RV32IFD-NEXT:    addi sp, sp, -16
-; RV32IFD-NEXT:    sw a2, 8(sp)
-; RV32IFD-NEXT:    sw a3, 12(sp)
-; RV32IFD-NEXT:    fld ft0, 8(sp)
-; RV32IFD-NEXT:    sw a0, 8(sp)
-; RV32IFD-NEXT:    sw a1, 12(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    feq.d a0, ft1, ft0
-; RV32IFD-NEXT:    bnez a0, .LBB16_2
-; RV32IFD-NEXT:  # %bb.1:
-; RV32IFD-NEXT:    mv a4, a5
-; RV32IFD-NEXT:  .LBB16_2:
-; RV32IFD-NEXT:    mv a0, a4
-; RV32IFD-NEXT:    addi sp, sp, 16
-; RV32IFD-NEXT:    ret
-  %1 = fcmp oeq double %a, %b
-  %2 = select i1 %1, i32 %c, i32 %d
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/double-stack-spill-restore.ll b/test/CodeGen/RISCV/double-stack-spill-restore.ll
deleted file mode 100644
index b5c0b991e6c..00000000000
--- a/test/CodeGen/RISCV/double-stack-spill-restore.ll
+++ /dev/null
@@ -1,45 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IFD %s
-
-define double @func(double %d, i32 %n) nounwind {
-; RV32IFD-LABEL: func:
-; RV32IFD:       # %bb.0: # %entry
-; RV32IFD-NEXT:    addi sp, sp, -32
-; RV32IFD-NEXT:    sw ra, 28(sp)
-; RV32IFD-NEXT:    sw a0, 16(sp)
-; RV32IFD-NEXT:    sw a1, 20(sp)
-; RV32IFD-NEXT:    fld ft0, 16(sp)
-; RV32IFD-NEXT:    beqz a2, .LBB0_2
-; RV32IFD-NEXT:  # %bb.1: # %if.else
-; RV32IFD-NEXT:    addi a2, a2, -1
-; RV32IFD-NEXT:    fsd ft0, 16(sp)
-; RV32IFD-NEXT:    lw a0, 16(sp)
-; RV32IFD-NEXT:    lw a1, 20(sp)
-; RV32IFD-NEXT:    fsd ft0, 8(sp)
-; RV32IFD-NEXT:    call func
-; RV32IFD-NEXT:    sw a0, 16(sp)
-; RV32IFD-NEXT:    sw a1, 20(sp)
-; RV32IFD-NEXT:    fld ft0, 16(sp)
-; RV32IFD-NEXT:    fld ft1, 8(sp)
-; RV32IFD-NEXT:    fadd.d ft0, ft0, ft1
-; RV32IFD-NEXT:  .LBB0_2: # %return
-; RV32IFD-NEXT:    fsd ft0, 16(sp)
-; RV32IFD-NEXT:    lw a0, 16(sp)
-; RV32IFD-NEXT:    lw a1, 20(sp)
-; RV32IFD-NEXT:    lw ra, 28(sp)
-; RV32IFD-NEXT:    addi sp, sp, 32
-; RV32IFD-NEXT:    ret
-entry:
-  %cmp = icmp eq i32 %n, 0
-  br i1 %cmp, label %return, label %if.else
-
-if.else:
-  %sub = add i32 %n, -1
-  %call = tail call double @func(double %d, i32 %sub)
-  %add = fadd double %call, %d
-  ret double %add
-
-return:
-  ret double %d
-}
diff --git a/test/CodeGen/RISCV/fixups-diff.ll b/test/CodeGen/RISCV/fixups-diff.ll
deleted file mode 100644
index 08dca52a345..00000000000
--- a/test/CodeGen/RISCV/fixups-diff.ll
+++ /dev/null
@@ -1,46 +0,0 @@
-; RUN: llc -filetype=obj -mtriple=riscv32 -mattr=+relax %s -o - \
-; RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX %s
-; RUN: llc -filetype=obj -mtriple=riscv32 -mattr=-relax %s -o - \
-; RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX %s
-
-; Check that a difference between two symbols in the same fragment
-; causes relocations to be emitted if and only if relaxation is enabled.
-;
-; This specific test is checking that the size of the function in
-; the debug information is represented by a relocation. This isn't
-; an assembly test as the assembler takes a different path through
-; LLVM, which is already covered by the fixups-expr.s test.
-
-source_filename = "tmp.c"
-target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
-target triple = "riscv32"
-
-define i32 @main() !dbg !7 {
-entry:
-  %retval = alloca i32, align 4
-  store i32 0, i32* %retval, align 4
-  ret i32 0
-}
-
-; RELAX: 0x22 R_RISCV_ADD32 - 0x0
-; RELAX: 0x22 R_RISCV_SUB32 - 0x0
-; RELAX: 0x2B R_RISCV_ADD32 - 0x0
-; RELAX: 0x2B R_RISCV_SUB32 - 0x0
-; NORELAX-NOT: R_RISCV_ADD32
-
-!llvm.dbg.cu = !{!0}
-!llvm.module.flags = !{!3, !4, !5}
-!llvm.ident = !{!6}
-
-!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
-!1 = !DIFile(filename: "fixups-diff.ll", directory: "test/MC/RISCV")
-!2 = !{}
-!3 = !{i32 2, !"Dwarf Version", i32 4}
-!4 = !{i32 2, !"Debug Info Version", i32 3}
-!5 = !{i32 1, !"wchar_size", i32 4}
-!6 = !{!"clang"}
-!7 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 1, type: !8, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0)
-!8 = !DISubroutineType(types: !9)
-!9 = !{!10}
-!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
-!11 = !DILocation(line: 2, column: 3, scope: !7)
diff --git a/test/CodeGen/RISCV/fixups-relax-diff.ll b/test/CodeGen/RISCV/fixups-relax-diff.ll
deleted file mode 100644
index d574a8af338..00000000000
--- a/test/CodeGen/RISCV/fixups-relax-diff.ll
+++ /dev/null
@@ -1,20 +0,0 @@
-; RUN: llc -filetype=obj -mtriple=riscv32 -mattr=+relax %s -o - \
-; RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX %s
-; RUN: llc -filetype=obj -mtriple=riscv32 -mattr=-relax %s -o - \
-; RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX %s
-
-; This test checks that a diff inserted via inline assembly only causes
-; relocations when relaxation is enabled. This isn't an assembly test
-; as the assembler takes a different path through LLVM, which is
-; already covered by the fixups-expr.s test.
-
-define i32 @main() {
-entry:
-  %retval = alloca i32, align 4
-  store i32 0, i32* %retval, align 4
-  ; RELAX: R_RISCV_ADD64 b
-  ; RELAX: R_RISCV_SUB64 a
-  ; NORELAX-NOT: R_RISCV
-  call void asm sideeffect "a:\0Ab:\0A.dword b-a", ""()
-  ret i32 0
-}
diff --git a/test/CodeGen/RISCV/float-arith.ll b/test/CodeGen/RISCV/float-arith.ll
deleted file mode 100644
index ab874476541..00000000000
--- a/test/CodeGen/RISCV/float-arith.ll
+++ /dev/null
@@ -1,267 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-; These tests are each targeted at a particular RISC-V FPU instruction. Most
-; other files in this folder exercise LLVM IR instructions that don't directly
-; match a RISC-V instruction.
-
-define float @fadd_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fadd_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fadd float %a, %b
-  ret float %1
-}
-
-define float @fsub_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fsub_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fsub.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fsub float %a, %b
-  ret float %1
-}
-
-define float @fmul_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fmul_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmul.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fmul float %a, %b
-  ret float %1
-}
-
-define float @fdiv_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fdiv_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fdiv.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fdiv float %a, %b
-  ret float %1
-}
-
-declare float @llvm.sqrt.f32(float)
-
-define float @fsqrt_s(float %a) nounwind {
-; RV32IF-LABEL: fsqrt_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fsqrt.s ft0, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.sqrt.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.copysign.f32(float, float)
-
-define float @fsgnj_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fsgnj_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fsgnj.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.copysign.f32(float %a, float %b)
-  ret float %1
-}
-
-define float @fneg_s(float %a) nounwind {
-; TODO: doesn't test the fneg selection pattern because
-; DAGCombiner::visitBITCAST will generate a xor on the incoming integer
-; argument
-; RV32IF-LABEL: fneg_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lui a1, 524288
-; RV32IF-NEXT:    xor a0, a0, a1
-; RV32IF-NEXT:    ret
-  %1 = fsub float -0.0, %a
-  ret float %1
-}
-
-define float @fsgnjn_s(float %a, float %b) nounwind {
-; TODO: fsgnjn.s isn't selected because DAGCombiner::visitBITCAST will convert
-; (bitconvert (fneg x)) to a xor
-; RV32IF-LABEL: fsgnjn_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lui a2, 524288
-; RV32IF-NEXT:    xor a1, a1, a2
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fsgnj.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fsub float -0.0, %b
-  %2 = call float @llvm.copysign.f32(float %a, float %1)
-  ret float %2
-}
-
-declare float @llvm.fabs.f32(float)
-
-define float @fabs_s(float %a) nounwind {
-; TODO: doesn't test the fabs selection pattern because
-; DAGCombiner::visitBITCAST will generate an and on the incoming integer
-; argument
-; RV32IF-LABEL: fabs_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lui a1, 524288
-; RV32IF-NEXT:    addi a1, a1, -1
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.fabs.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.minnum.f32(float, float)
-
-define float @fmin_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fmin_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmin.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.minnum.f32(float %a, float %b)
-  ret float %1
-}
-
-declare float @llvm.maxnum.f32(float, float)
-
-define float @fmax_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fmax_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmax.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.maxnum.f32(float %a, float %b)
-  ret float %1
-}
-
-define i32 @feq_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: feq_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp oeq float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @flt_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: flt_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp olt float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fle_s(float %a, float %b) nounwind {
-; RV32IF-LABEL: fle_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ole float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-declare float @llvm.fma.f32(float, float, float)
-
-define float @fmadd_s(float %a, float %b, float %c) nounwind {
-; RV32IF-LABEL: fmadd_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a2
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft2, a0
-; RV32IF-NEXT:    fmadd.s ft0, ft2, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.fma.f32(float %a, float %b, float %c)
-  ret float %1
-}
-
-define float @fmsub_s(float %a, float %b, float %c) nounwind {
-; RV32IF-LABEL: fmsub_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a2
-; RV32IF-NEXT:    lui a2, %hi(.LCPI15_0)
-; RV32IF-NEXT:    addi a2, a2, %lo(.LCPI15_0)
-; RV32IF-NEXT:    flw ft1, 0(a2)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft2, a0
-; RV32IF-NEXT:    fmsub.s ft0, ft2, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %c_ = fadd float 0.0, %c ; avoid negation using xor
-  %negc = fsub float -0.0, %c_
-  %1 = call float @llvm.fma.f32(float %a, float %b, float %negc)
-  ret float %1
-}
-
-define float @fnmadd_s(float %a, float %b, float %c) nounwind {
-; RV32IF-LABEL: fnmadd_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a2
-; RV32IF-NEXT:    lui a2, %hi(.LCPI16_0)
-; RV32IF-NEXT:    addi a2, a2, %lo(.LCPI16_0)
-; RV32IF-NEXT:    flw ft1, 0(a2)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fmv.w.x ft2, a0
-; RV32IF-NEXT:    fadd.s ft1, ft2, ft1
-; RV32IF-NEXT:    fmv.w.x ft2, a1
-; RV32IF-NEXT:    fnmadd.s ft0, ft1, ft2, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %a_ = fadd float 0.0, %a
-  %c_ = fadd float 0.0, %c
-  %nega = fsub float -0.0, %a_
-  %negc = fsub float -0.0, %c_
-  %1 = call float @llvm.fma.f32(float %nega, float %b, float %negc)
-  ret float %1
-}
-
-define float @fnmsub_s(float %a, float %b, float %c) nounwind {
-; RV32IF-LABEL: fnmsub_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    lui a0, %hi(.LCPI17_0)
-; RV32IF-NEXT:    addi a0, a0, %lo(.LCPI17_0)
-; RV32IF-NEXT:    flw ft1, 0(a0)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fmv.w.x ft1, a2
-; RV32IF-NEXT:    fmv.w.x ft2, a1
-; RV32IF-NEXT:    fnmsub.s ft0, ft0, ft2, ft1
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %a_ = fadd float 0.0, %a
-  %nega = fsub float -0.0, %a_
-  %1 = call float @llvm.fma.f32(float %nega, float %b, float %c)
-  ret float %1
-}
diff --git a/test/CodeGen/RISCV/float-br-fcmp.ll b/test/CodeGen/RISCV/float-br-fcmp.ll
deleted file mode 100644
index 5804bd0fd1f..00000000000
--- a/test/CodeGen/RISCV/float-br-fcmp.ll
+++ /dev/null
@@ -1,494 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-declare void @abort()
-declare void @exit(i32)
-declare float @dummy(float)
-
-define void @br_fcmp_false(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_false:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    addi a0, zero, 1
-; RV32IF-NEXT:    bnez a0, .LBB0_2
-; RV32IF-NEXT:  # %bb.1: # %if.then
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB0_2: # %if.else
-; RV32IF-NEXT:    call abort
-  %1 = fcmp false float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.then:
-  ret void
-if.else:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_oeq(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_oeq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB1_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB1_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp oeq float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-; TODO: generated code quality for this is very poor due to
-; DAGCombiner::visitXOR converting the legal setoeq to setune, which requires
-; expansion.
-define void @br_fcmp_oeq_alt(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_oeq_alt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    beqz a0, .LBB2_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB2_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp oeq float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.then:
-  tail call void @abort()
-  unreachable
-if.else:
-  ret void
-}
-
-define void @br_fcmp_ogt(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ogt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB3_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB3_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ogt float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_oge(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_oge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB4_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB4_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp oge float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_olt(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_olt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB5_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB5_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp olt float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ole(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ole:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB6_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB6_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ole float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-; TODO: feq.s+sltiu+bne -> feq.s+beq
-define void @br_fcmp_one(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_one:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    feq.s a1, ft0, ft1
-; RV32IF-NEXT:    not a1, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    bnez a0, .LBB7_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB7_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp one float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ord(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ord:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft0
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB8_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB8_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ord float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ueq(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ueq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    feq.s a2, ft1, ft1
-; RV32IF-NEXT:    and a1, a2, a1
-; RV32IF-NEXT:    seqz a1, a1
-; RV32IF-NEXT:    or a0, a0, a1
-; RV32IF-NEXT:    bnez a0, .LBB9_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB9_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ueq float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ugt(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ugt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB10_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB10_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ugt float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_uge(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_uge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB11_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB11_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp uge float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ult(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ult:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB12_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB12_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ult float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_ule(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_ule:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB13_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB13_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp ule float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_une(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_une:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB14_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB14_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp une float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_uno(float %a, float %b) nounwind {
-; TODO: sltiu+bne -> beq
-; RV32IF-LABEL: br_fcmp_uno:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft0
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    bnez a0, .LBB15_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB15_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp uno float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-define void @br_fcmp_true(float %a, float %b) nounwind {
-; RV32IF-LABEL: br_fcmp_true:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    addi a0, zero, 1
-; RV32IF-NEXT:    bnez a0, .LBB16_2
-; RV32IF-NEXT:  # %bb.1: # %if.else
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB16_2: # %if.then
-; RV32IF-NEXT:    call abort
-  %1 = fcmp true float %a, %b
-  br i1 %1, label %if.then, label %if.else
-if.else:
-  ret void
-if.then:
-  tail call void @abort()
-  unreachable
-}
-
-; This test exists primarily to trigger RISCVInstrInfo::storeRegToStackSlot
-; and RISCVInstrInfo::loadRegFromStackSlot
-define i32 @br_fcmp_store_load_stack_slot(float %a, float %b) nounwind {
-; TODO: addi %lo(.LCPI17_0) should be merged in to the following flw
-; RV32IF-LABEL: br_fcmp_store_load_stack_slot:
-; RV32IF:       # %bb.0: # %entry
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    mv a0, zero
-; RV32IF-NEXT:    call dummy
-; RV32IF-NEXT:    lui a1, %hi(.LCPI17_0)
-; RV32IF-NEXT:    addi a1, a1, %lo(.LCPI17_0)
-; RV32IF-NEXT:    flw ft1, 0(a1)
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fsw ft1, 8(sp)
-; RV32IF-NEXT:    feq.s a0, ft0, ft1
-; RV32IF-NEXT:    beqz a0, .LBB17_3
-; RV32IF-NEXT:  # %bb.1: # %if.end
-; RV32IF-NEXT:    mv a0, zero
-; RV32IF-NEXT:    call dummy
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    flw ft1, 8(sp)
-; RV32IF-NEXT:    feq.s a0, ft0, ft1
-; RV32IF-NEXT:    beqz a0, .LBB17_3
-; RV32IF-NEXT:  # %bb.2: # %if.end4
-; RV32IF-NEXT:    mv a0, zero
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-; RV32IF-NEXT:  .LBB17_3: # %if.then
-; RV32IF-NEXT:    call abort
-entry:
-  %call = call float @dummy(float 0.000000e+00)
-  %cmp = fcmp une float %call, 0.000000e+00
-  br i1 %cmp, label %if.then, label %if.end
-
-if.then:
-  call void @abort()
-  unreachable
-
-if.end:
-  %call1 = call float @dummy(float 0.000000e+00)
-  %cmp2 = fcmp une float %call1, 0.000000e+00
-  br i1 %cmp2, label %if.then3, label %if.end4
-
-if.then3:
-  call void @abort()
-  unreachable
-
-if.end4:
-  ret i32 0
-}
diff --git a/test/CodeGen/RISCV/float-convert.ll b/test/CodeGen/RISCV/float-convert.ll
deleted file mode 100644
index d6e67cc6a8e..00000000000
--- a/test/CodeGen/RISCV/float-convert.ll
+++ /dev/null
@@ -1,72 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define i32 @fcvt_w_s(float %a) nounwind {
-; RV32IF-LABEL: fcvt_w_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fcvt.w.s a0, ft0, rtz
-; RV32IF-NEXT:    ret
-  %1 = fptosi float %a to i32
-  ret i32 %1
-}
-
-define i32 @fcvt_wu_s(float %a) nounwind {
-; RV32IF-LABEL: fcvt_wu_s:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fcvt.wu.s a0, ft0, rtz
-; RV32IF-NEXT:    ret
-  %1 = fptoui float %a to i32
-  ret i32 %1
-}
-
-define i32 @fmv_x_w(float %a, float %b) nounwind {
-; RV32IF-LABEL: fmv_x_w:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-; Ensure fmv.x.w is generated even for a soft float calling convention
-  %1 = fadd float %a, %b
-  %2 = bitcast float %1 to i32
-  ret i32 %2
-}
-
-define float @fcvt_s_w(i32 %a) nounwind {
-; RV32IF-LABEL: fcvt_s_w:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fcvt.s.w ft0, a0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = sitofp i32 %a to float
-  ret float %1
-}
-
-define float @fcvt_s_wu(i32 %a) nounwind {
-; RV32IF-LABEL: fcvt_s_wu:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fcvt.s.wu ft0, a0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = uitofp i32 %a to float
-  ret float %1
-}
-
-define float @fmv_w_x(i32 %a, i32 %b) nounwind {
-; RV32IF-LABEL: fmv_w_x:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-; Ensure fmv.w.x is generated even for a soft float calling convention
-  %1 = bitcast i32 %a to float
-  %2 = bitcast i32 %b to float
-  %3 = fadd float %1, %2
-  ret float %3
-}
diff --git a/test/CodeGen/RISCV/float-fcmp.ll b/test/CodeGen/RISCV/float-fcmp.ll
deleted file mode 100644
index c8942a90eb7..00000000000
--- a/test/CodeGen/RISCV/float-fcmp.ll
+++ /dev/null
@@ -1,215 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define i32 @fcmp_false(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_false:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    mv a0, zero
-; RV32IF-NEXT:    ret
-  %1 = fcmp false float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_oeq(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_oeq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp oeq float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ogt(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ogt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ogt float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_oge(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_oge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp oge float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_olt(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_olt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp olt float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ole(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ole:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ole float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_one(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_one:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    feq.s a1, ft0, ft1
-; RV32IF-NEXT:    not a1, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    ret
-  %1 = fcmp one float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ord(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ord:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft0
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp ord float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ueq(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ueq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    feq.s a2, ft1, ft1
-; RV32IF-NEXT:    and a1, a2, a1
-; RV32IF-NEXT:    seqz a1, a1
-; RV32IF-NEXT:    or a0, a0, a1
-; RV32IF-NEXT:    ret
-  %1 = fcmp ueq float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ugt(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ugt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp ugt float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_uge(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_uge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp uge float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ult(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ult:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp ult float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_ule(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_ule:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp ule float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_une(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_une:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp une float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_uno(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_uno:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft0
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    ret
-  %1 = fcmp uno float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @fcmp_true(float %a, float %b) nounwind {
-; RV32IF-LABEL: fcmp_true:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi a0, zero, 1
-; RV32IF-NEXT:    ret
-  %1 = fcmp true float %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/float-frem.ll b/test/CodeGen/RISCV/float-frem.ll
deleted file mode 100644
index 95042c5fde6..00000000000
--- a/test/CodeGen/RISCV/float-frem.ll
+++ /dev/null
@@ -1,16 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define float @frem_f32(float %a, float %b) nounwind {
-; RV32IF-LABEL: frem_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call fmodf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = frem float %a, %b
-  ret float %1
-}
diff --git a/test/CodeGen/RISCV/float-imm.ll b/test/CodeGen/RISCV/float-imm.ll
deleted file mode 100644
index a8d032571e1..00000000000
--- a/test/CodeGen/RISCV/float-imm.ll
+++ /dev/null
@@ -1,27 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define float @float_imm() nounwind {
-; RV32IF-LABEL: float_imm:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lui a0, 263313
-; RV32IF-NEXT:    addi a0, a0, -37
-; RV32IF-NEXT:    ret
-  ret float 3.14159274101257324218750
-}
-
-define float @float_imm_op(float %a) nounwind {
-; TODO: addi should be folded in to the flw
-; RV32IF-LABEL: float_imm_op:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    lui a0, %hi(.LCPI1_0)
-; RV32IF-NEXT:    addi a0, a0, %lo(.LCPI1_0)
-; RV32IF-NEXT:    flw ft1, 0(a0)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fadd float %a, 1.0
-  ret float %1
-}
diff --git a/test/CodeGen/RISCV/float-intrinsics.ll b/test/CodeGen/RISCV/float-intrinsics.ll
deleted file mode 100644
index 57f3a28ee60..00000000000
--- a/test/CodeGen/RISCV/float-intrinsics.ll
+++ /dev/null
@@ -1,375 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-; RUN: llc -mtriple=riscv32 -mattr=+d -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-declare float @llvm.sqrt.f32(float)
-
-define float @sqrt_f32(float %a) nounwind {
-; RV32IF-LABEL: sqrt_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fsqrt.s ft0, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.sqrt.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.powi.f32(float, i32)
-
-define float @powi_f32(float %a, i32 %b) nounwind {
-; RV32IF-LABEL: powi_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call __powisf2
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.powi.f32(float %a, i32 %b)
-  ret float %1
-}
-
-declare float @llvm.sin.f32(float)
-
-define float @sin_f32(float %a) nounwind {
-; RV32IF-LABEL: sin_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call sinf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.sin.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.cos.f32(float)
-
-define float @cos_f32(float %a) nounwind {
-; RV32IF-LABEL: cos_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call cosf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.cos.f32(float %a)
-  ret float %1
-}
-
-; The sin+cos combination results in an FSINCOS SelectionDAG node.
-define float @sincos_f32(float %a) nounwind {
-; RV32IF-LABEL: sincos_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    sw s1, 8(sp)
-; RV32IF-NEXT:    sw s2, 4(sp)
-; RV32IF-NEXT:    mv s1, a0
-; RV32IF-NEXT:    call sinf
-; RV32IF-NEXT:    mv s2, a0
-; RV32IF-NEXT:    mv a0, s1
-; RV32IF-NEXT:    call cosf
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, s2
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    lw s2, 4(sp)
-; RV32IF-NEXT:    lw s1, 8(sp)
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.sin.f32(float %a)
-  %2 = call float @llvm.cos.f32(float %a)
-  %3 = fadd float %1, %2
-  ret float %3
-}
-
-declare float @llvm.pow.f32(float, float)
-
-define float @pow_f32(float %a, float %b) nounwind {
-; RV32IF-LABEL: pow_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call powf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.pow.f32(float %a, float %b)
-  ret float %1
-}
-
-declare float @llvm.exp.f32(float)
-
-define float @exp_f32(float %a) nounwind {
-; RV32IF-LABEL: exp_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call expf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.exp.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.exp2.f32(float)
-
-define float @exp2_f32(float %a) nounwind {
-; RV32IF-LABEL: exp2_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call exp2f
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.exp2.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.log.f32(float)
-
-define float @log_f32(float %a) nounwind {
-; RV32IF-LABEL: log_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call logf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.log.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.log10.f32(float)
-
-define float @log10_f32(float %a) nounwind {
-; RV32IF-LABEL: log10_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call log10f
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.log10.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.log2.f32(float)
-
-define float @log2_f32(float %a) nounwind {
-; RV32IF-LABEL: log2_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call log2f
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.log2.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.fma.f32(float, float, float)
-
-define float @fma_f32(float %a, float %b, float %c) nounwind {
-; RV32IF-LABEL: fma_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a2
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft2, a0
-; RV32IF-NEXT:    fmadd.s ft0, ft2, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.fma.f32(float %a, float %b, float %c)
-  ret float %1
-}
-
-declare float @llvm.fmuladd.f32(float, float, float)
-
-define float @fmuladd_f32(float %a, float %b, float %c) nounwind {
-; Use of fmadd depends on TargetLowering::isFMAFasterthanFMulAndFAdd
-; RV32IF-LABEL: fmuladd_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmul.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.w.x ft1, a2
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.fmuladd.f32(float %a, float %b, float %c)
-  ret float %1
-}
-
-declare float @llvm.fabs.f32(float)
-
-define float @fabs_f32(float %a) nounwind {
-; RV32IF-LABEL: fabs_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    lui a1, 524288
-; RV32IF-NEXT:    addi a1, a1, -1
-; RV32IF-NEXT:    and a0, a0, a1
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.fabs.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.minnum.f32(float, float)
-
-define float @minnum_f32(float %a, float %b) nounwind {
-; RV32IF-LABEL: minnum_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmin.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.minnum.f32(float %a, float %b)
-  ret float %1
-}
-
-declare float @llvm.maxnum.f32(float, float)
-
-define float @maxnum_f32(float %a, float %b) nounwind {
-; RV32IF-LABEL: maxnum_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fmax.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.maxnum.f32(float %a, float %b)
-  ret float %1
-}
-
-; TODO: FMINNAN and FMAXNAN aren't handled in
-; SelectionDAGLegalize::ExpandNode.
-
-; declare float @llvm.minimum.f32(float, float)
-
-; define float @fminimum_f32(float %a, float %b) nounwind {
-;   %1 = call float @llvm.minimum.f32(float %a, float %b)
-;   ret float %1
-; }
-
-; declare float @llvm.maximum.f32(float, float)
-
-; define float @fmaximum_f32(float %a, float %b) nounwind {
-;   %1 = call float @llvm.maximum.f32(float %a, float %b)
-;   ret float %1
-; }
-
-declare float @llvm.copysign.f32(float, float)
-
-define float @copysign_f32(float %a, float %b) nounwind {
-; RV32IF-LABEL: copysign_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fsgnj.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.copysign.f32(float %a, float %b)
-  ret float %1
-}
-
-declare float @llvm.floor.f32(float)
-
-define float @floor_f32(float %a) nounwind {
-; RV32IF-LABEL: floor_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call floorf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.floor.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.ceil.f32(float)
-
-define float @ceil_f32(float %a) nounwind {
-; RV32IF-LABEL: ceil_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call ceilf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.ceil.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.trunc.f32(float)
-
-define float @trunc_f32(float %a) nounwind {
-; RV32IF-LABEL: trunc_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call truncf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.trunc.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.rint.f32(float)
-
-define float @rint_f32(float %a) nounwind {
-; RV32IF-LABEL: rint_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call rintf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.rint.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.nearbyint.f32(float)
-
-define float @nearbyint_f32(float %a) nounwind {
-; RV32IF-LABEL: nearbyint_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call nearbyintf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.nearbyint.f32(float %a)
-  ret float %1
-}
-
-declare float @llvm.round.f32(float)
-
-define float @round_f32(float %a) nounwind {
-; RV32IF-LABEL: round_f32:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    call roundf
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = call float @llvm.round.f32(float %a)
-  ret float %1
-}
diff --git a/test/CodeGen/RISCV/float-mem.ll b/test/CodeGen/RISCV/float-mem.ll
deleted file mode 100644
index 95a9d73d5f7..00000000000
--- a/test/CodeGen/RISCV/float-mem.ll
+++ /dev/null
@@ -1,133 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define float @flw(float *%a) nounwind {
-; RV32IF-LABEL: flw:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    flw ft0, 12(a0)
-; RV32IF-NEXT:    flw ft1, 0(a0)
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = load float, float* %a
-  %2 = getelementptr float, float* %a, i32 3
-  %3 = load float, float* %2
-; Use both loaded values in an FP op to ensure an flw is used, even for the
-; soft float ABI
-  %4 = fadd float %1, %3
-  ret float %4
-}
-
-define void @fsw(float *%a, float %b, float %c) nounwind {
-; Use %b and %c in an FP op to ensure floating point registers are used, even
-; for the soft float ABI
-; RV32IF-LABEL: fsw:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a2
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fsw ft0, 32(a0)
-; RV32IF-NEXT:    fsw ft0, 0(a0)
-; RV32IF-NEXT:    ret
-  %1 = fadd float %b, %c
-  store float %1, float* %a
-  %2 = getelementptr float, float* %a, i32 8
-  store float %1, float* %2
-  ret void
-}
-
-; Check load and store to a global
-@G = global float 0.0
-
-define float @flw_fsw_global(float %a, float %b) nounwind {
-; Use %a and %b in an FP op to ensure floating point registers are used, even
-; for the soft float ABI
-; RV32IF-LABEL: flw_fsw_global:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    lui a0, %hi(G)
-; RV32IF-NEXT:    flw ft1, %lo(G)(a0)
-; RV32IF-NEXT:    fsw ft0, %lo(G)(a0)
-; RV32IF-NEXT:    addi a0, a0, %lo(G)
-; RV32IF-NEXT:    flw ft1, 36(a0)
-; RV32IF-NEXT:    fsw ft0, 36(a0)
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fadd float %a, %b
-  %2 = load volatile float, float* @G
-  store float %1, float* @G
-  %3 = getelementptr float, float* @G, i32 9
-  %4 = load volatile float, float* %3
-  store float %1, float* %3
-  ret float %1
-}
-
-; Ensure that 1 is added to the high 20 bits if bit 11 of the low part is 1
-define float @flw_fsw_constant(float %a) nounwind {
-; RV32IF-LABEL: flw_fsw_constant:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    lui a0, 912092
-; RV32IF-NEXT:    flw ft1, -273(a0)
-; RV32IF-NEXT:    fadd.s ft0, ft0, ft1
-; RV32IF-NEXT:    fsw ft0, -273(a0)
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = inttoptr i32 3735928559 to float*
-  %2 = load volatile float, float* %1
-  %3 = fadd float %a, %2
-  store float %3, float* %1
-  ret float %3
-}
-
-declare void @notdead(i8*)
-
-define float @flw_stack(float %a) nounwind {
-; RV32IF-LABEL: flw_stack:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    sw s1, 8(sp)
-; RV32IF-NEXT:    mv s1, a0
-; RV32IF-NEXT:    addi a0, sp, 4
-; RV32IF-NEXT:    call notdead
-; RV32IF-NEXT:    fmv.w.x ft0, s1
-; RV32IF-NEXT:    flw ft1, 4(sp)
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    lw s1, 8(sp)
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = alloca float, align 4
-  %2 = bitcast float* %1 to i8*
-  call void @notdead(i8* %2)
-  %3 = load float, float* %1
-  %4 = fadd float %3, %a ; force load in to FPR32
-  ret float %4
-}
-
-define void @fsw_stack(float %a, float %b) nounwind {
-; RV32IF-LABEL: fsw_stack:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    addi sp, sp, -16
-; RV32IF-NEXT:    sw ra, 12(sp)
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    fadd.s ft0, ft1, ft0
-; RV32IF-NEXT:    fsw ft0, 8(sp)
-; RV32IF-NEXT:    addi a0, sp, 8
-; RV32IF-NEXT:    call notdead
-; RV32IF-NEXT:    lw ra, 12(sp)
-; RV32IF-NEXT:    addi sp, sp, 16
-; RV32IF-NEXT:    ret
-  %1 = fadd float %a, %b ; force store from FPR32
-  %2 = alloca float, align 4
-  store float %1, float* %2
-  %3 = bitcast float* %2 to i8*
-  call void @notdead(i8* %3)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/float-select-fcmp.ll b/test/CodeGen/RISCV/float-select-fcmp.ll
deleted file mode 100644
index 59d4a3f078b..00000000000
--- a/test/CodeGen/RISCV/float-select-fcmp.ll
+++ /dev/null
@@ -1,304 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IF %s
-
-define float @select_fcmp_false(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_false:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    mv a0, a1
-; RV32IF-NEXT:    ret
-  %1 = fcmp false float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_oeq(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_oeq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft1
-; RV32IF-NEXT:    bnez a0, .LBB1_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB1_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp oeq float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ogt(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ogt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB2_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB2_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ogt float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_oge(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_oge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB3_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB3_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp oge float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_olt(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_olt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    flt.s a0, ft0, ft1
-; RV32IF-NEXT:    bnez a0, .LBB4_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB4_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp olt float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ole(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ole:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fle.s a0, ft0, ft1
-; RV32IF-NEXT:    bnez a0, .LBB5_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB5_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ole float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_one(float %a, float %b) nounwind {
-; TODO: feq.s+sltiu+bne sequence could be optimised
-; RV32IF-LABEL: select_fcmp_one:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    feq.s a1, ft0, ft1
-; RV32IF-NEXT:    not a1, a1
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    bnez a0, .LBB6_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB6_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp one float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ord(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ord:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB7_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB7_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ord float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ueq(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ueq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    feq.s a1, ft0, ft1
-; RV32IF-NEXT:    or a0, a1, a0
-; RV32IF-NEXT:    bnez a0, .LBB8_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB8_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ueq float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ugt(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ugt:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fle.s a0, ft0, ft1
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB9_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB9_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ugt float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_uge(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_uge:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    flt.s a0, ft0, ft1
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB10_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB10_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp uge float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ult(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ult:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fle.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB11_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB11_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ult float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_ule(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_ule:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    flt.s a0, ft1, ft0
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB12_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB12_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp ule float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_une(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_une:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    feq.s a0, ft0, ft1
-; RV32IF-NEXT:    xori a0, a0, 1
-; RV32IF-NEXT:    bnez a0, .LBB13_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB13_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp une float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_uno(float %a, float %b) nounwind {
-; TODO: sltiu+bne could be optimized
-; RV32IF-LABEL: select_fcmp_uno:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a0
-; RV32IF-NEXT:    fmv.w.x ft1, a1
-; RV32IF-NEXT:    feq.s a0, ft1, ft1
-; RV32IF-NEXT:    feq.s a1, ft0, ft0
-; RV32IF-NEXT:    and a0, a1, a0
-; RV32IF-NEXT:    seqz a0, a0
-; RV32IF-NEXT:    bnez a0, .LBB14_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    fmv.s ft0, ft1
-; RV32IF-NEXT:  .LBB14_2:
-; RV32IF-NEXT:    fmv.x.w a0, ft0
-; RV32IF-NEXT:    ret
-  %1 = fcmp uno float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-define float @select_fcmp_true(float %a, float %b) nounwind {
-; RV32IF-LABEL: select_fcmp_true:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    ret
-  %1 = fcmp true float %a, %b
-  %2 = select i1 %1, float %a, float %b
-  ret float %2
-}
-
-; Ensure that ISel succeeds for a select+fcmp that has an i32 result type.
-define i32 @i32_select_fcmp_oeq(float %a, float %b, i32 %c, i32 %d) nounwind {
-; RV32IF-LABEL: i32_select_fcmp_oeq:
-; RV32IF:       # %bb.0:
-; RV32IF-NEXT:    fmv.w.x ft0, a1
-; RV32IF-NEXT:    fmv.w.x ft1, a0
-; RV32IF-NEXT:    feq.s a0, ft1, ft0
-; RV32IF-NEXT:    bnez a0, .LBB16_2
-; RV32IF-NEXT:  # %bb.1:
-; RV32IF-NEXT:    mv a2, a3
-; RV32IF-NEXT:  .LBB16_2:
-; RV32IF-NEXT:    mv a0, a2
-; RV32IF-NEXT:    ret
-  %1 = fcmp oeq float %a, %b
-  %2 = select i1 %1, i32 %c, i32 %d
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/flt-rounds.ll b/test/CodeGen/RISCV/flt-rounds.ll
deleted file mode 100644
index cb6d166de4f..00000000000
--- a/test/CodeGen/RISCV/flt-rounds.ll
+++ /dev/null
@@ -1,21 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV64I %s
-
-declare i32 @llvm.flt.rounds()
-
-define i32 @test_flt_rounds() nounwind {
-; RV32I-LABEL: test_flt_rounds:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_flt_rounds:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 1
-; RV64I-NEXT:    ret
-  %1 = call i32 @llvm.flt.rounds()
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/fp128.ll b/test/CodeGen/RISCV/fp128.ll
deleted file mode 100644
index a928d69fe9e..00000000000
--- a/test/CodeGen/RISCV/fp128.ll
+++ /dev/null
@@ -1,97 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-@x = local_unnamed_addr global fp128 0xL00000000000000007FFF000000000000, align 16
-@y = local_unnamed_addr global fp128 0xL00000000000000007FFF000000000000, align 16
-
-; Besides anything else, these tests help verify that libcall ABI lowering
-; works correctly
-
-define i32 @test_load_and_cmp() nounwind {
-; RV32I-LABEL: test_load_and_cmp:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    lui a0, %hi(y)
-; RV32I-NEXT:    lw a1, %lo(y)(a0)
-; RV32I-NEXT:    sw a1, 8(sp)
-; RV32I-NEXT:    lui a1, %hi(x)
-; RV32I-NEXT:    lw a2, %lo(x)(a1)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    addi a0, a0, %lo(y)
-; RV32I-NEXT:    lw a2, 12(a0)
-; RV32I-NEXT:    sw a2, 20(sp)
-; RV32I-NEXT:    lw a2, 8(a0)
-; RV32I-NEXT:    sw a2, 16(sp)
-; RV32I-NEXT:    lw a0, 4(a0)
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    addi a0, a1, %lo(x)
-; RV32I-NEXT:    lw a1, 12(a0)
-; RV32I-NEXT:    sw a1, 36(sp)
-; RV32I-NEXT:    lw a1, 8(a0)
-; RV32I-NEXT:    sw a1, 32(sp)
-; RV32I-NEXT:    lw a0, 4(a0)
-; RV32I-NEXT:    sw a0, 28(sp)
-; RV32I-NEXT:    addi a0, sp, 24
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    call __netf2
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-  %1 = load fp128, fp128* @x, align 16
-  %2 = load fp128, fp128* @y, align 16
-  %cmp = fcmp une fp128 %1, %2
-  %3 = zext i1 %cmp to i32
-  ret i32 %3
-}
-
-define i32 @test_add_and_fptosi() nounwind {
-; RV32I-LABEL: test_add_and_fptosi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -80
-; RV32I-NEXT:    sw ra, 76(sp)
-; RV32I-NEXT:    lui a0, %hi(y)
-; RV32I-NEXT:    lw a1, %lo(y)(a0)
-; RV32I-NEXT:    sw a1, 24(sp)
-; RV32I-NEXT:    lui a1, %hi(x)
-; RV32I-NEXT:    lw a2, %lo(x)(a1)
-; RV32I-NEXT:    sw a2, 40(sp)
-; RV32I-NEXT:    addi a0, a0, %lo(y)
-; RV32I-NEXT:    lw a2, 12(a0)
-; RV32I-NEXT:    sw a2, 36(sp)
-; RV32I-NEXT:    lw a2, 8(a0)
-; RV32I-NEXT:    sw a2, 32(sp)
-; RV32I-NEXT:    lw a0, 4(a0)
-; RV32I-NEXT:    sw a0, 28(sp)
-; RV32I-NEXT:    addi a0, a1, %lo(x)
-; RV32I-NEXT:    lw a1, 12(a0)
-; RV32I-NEXT:    sw a1, 52(sp)
-; RV32I-NEXT:    lw a1, 8(a0)
-; RV32I-NEXT:    sw a1, 48(sp)
-; RV32I-NEXT:    lw a0, 4(a0)
-; RV32I-NEXT:    sw a0, 44(sp)
-; RV32I-NEXT:    addi a0, sp, 56
-; RV32I-NEXT:    addi a1, sp, 40
-; RV32I-NEXT:    addi a2, sp, 24
-; RV32I-NEXT:    call __addtf3
-; RV32I-NEXT:    lw a0, 68(sp)
-; RV32I-NEXT:    sw a0, 20(sp)
-; RV32I-NEXT:    lw a0, 64(sp)
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    lw a0, 60(sp)
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lw a0, 56(sp)
-; RV32I-NEXT:    sw a0, 8(sp)
-; RV32I-NEXT:    addi a0, sp, 8
-; RV32I-NEXT:    call __fixtfsi
-; RV32I-NEXT:    lw ra, 76(sp)
-; RV32I-NEXT:    addi sp, sp, 80
-; RV32I-NEXT:    ret
-  %1 = load fp128, fp128* @x, align 16
-  %2 = load fp128, fp128* @y, align 16
-  %3 = fadd fp128 %1, %2
-  %4 = fptosi fp128 %3 to i32
-  ret i32 %4
-}
diff --git a/test/CodeGen/RISCV/frame.ll b/test/CodeGen/RISCV/frame.ll
deleted file mode 100644
index a1f58095188..00000000000
--- a/test/CodeGen/RISCV/frame.ll
+++ /dev/null
@@ -1,54 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -disable-fp-elim -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-%struct.key_t = type { i32, [16 x i8] }
-
-define i32 @test() nounwind {
-; RV32I-FPELIM-LABEL: test:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 24(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 20(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 16(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 12(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 12
-; RV32I-FPELIM-NEXT:    call test1
-; RV32I-FPELIM-NEXT:    mv a0, zero
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -24(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -28(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -32(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -28
-; RV32I-WITHFP-NEXT:    call test1
-; RV32I-WITHFP-NEXT:    mv a0, zero
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %key = alloca %struct.key_t, align 4
-  %1 = bitcast %struct.key_t* %key to i8*
-  call void @llvm.memset.p0i8.i64(i8* align 4 %1, i8 0, i64 20, i1 false)
-  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
-  call void @test1(i8* %2) #3
-  ret i32 0
-}
-
-declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i1)
-
-declare void @test1(i8*)
diff --git a/test/CodeGen/RISCV/frameaddr-returnaddr.ll b/test/CodeGen/RISCV/frameaddr-returnaddr.ll
deleted file mode 100644
index 255bf715539..00000000000
--- a/test/CodeGen/RISCV/frameaddr-returnaddr.ll
+++ /dev/null
@@ -1,152 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV64I %s
-
-declare void @notdead(i8*)
-declare i8* @llvm.frameaddress(i32)
-declare i8* @llvm.returnaddress(i32)
-
-define i8* @test_frameaddress_0() nounwind {
-; RV32I-LABEL: test_frameaddress_0:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    mv a0, s0
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_frameaddress_0:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi sp, sp, -16
-; RV64I-NEXT:    sd ra, 8(sp)
-; RV64I-NEXT:    sd s0, 0(sp)
-; RV64I-NEXT:    addi s0, sp, 16
-; RV64I-NEXT:    mv a0, s0
-; RV64I-NEXT:    ld s0, 0(sp)
-; RV64I-NEXT:    ld ra, 8(sp)
-; RV64I-NEXT:    addi sp, sp, 16
-; RV64I-NEXT:    ret
-  %1 = call i8* @llvm.frameaddress(i32 0)
-  ret i8* %1
-}
-
-define i8* @test_frameaddress_2() nounwind {
-; RV32I-LABEL: test_frameaddress_2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_frameaddress_2:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi sp, sp, -16
-; RV64I-NEXT:    sd ra, 8(sp)
-; RV64I-NEXT:    sd s0, 0(sp)
-; RV64I-NEXT:    addi s0, sp, 16
-; RV64I-NEXT:    ld a0, -16(s0)
-; RV64I-NEXT:    ld a0, -16(a0)
-; RV64I-NEXT:    ld s0, 0(sp)
-; RV64I-NEXT:    ld ra, 8(sp)
-; RV64I-NEXT:    addi sp, sp, 16
-; RV64I-NEXT:    ret
-  %1 = call i8* @llvm.frameaddress(i32 2)
-  ret i8* %1
-}
-
-define i8* @test_frameaddress_3_alloca() nounwind {
-; RV32I-LABEL: test_frameaddress_3_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -112
-; RV32I-NEXT:    sw ra, 108(sp)
-; RV32I-NEXT:    sw s0, 104(sp)
-; RV32I-NEXT:    addi s0, sp, 112
-; RV32I-NEXT:    addi a0, s0, -108
-; RV32I-NEXT:    call notdead
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw s0, 104(sp)
-; RV32I-NEXT:    lw ra, 108(sp)
-; RV32I-NEXT:    addi sp, sp, 112
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_frameaddress_3_alloca:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi sp, sp, -128
-; RV64I-NEXT:    sd ra, 120(sp)
-; RV64I-NEXT:    sd s0, 112(sp)
-; RV64I-NEXT:    addi s0, sp, 128
-; RV64I-NEXT:    addi a0, s0, -116
-; RV64I-NEXT:    call notdead
-; RV64I-NEXT:    ld a0, -16(s0)
-; RV64I-NEXT:    ld a0, -16(a0)
-; RV64I-NEXT:    ld a0, -16(a0)
-; RV64I-NEXT:    ld s0, 112(sp)
-; RV64I-NEXT:    ld ra, 120(sp)
-; RV64I-NEXT:    addi sp, sp, 128
-; RV64I-NEXT:    ret
-  %1 = alloca [100 x i8]
-  %2 = bitcast [100 x i8]* %1 to i8*
-  call void @notdead(i8* %2)
-  %3 = call i8* @llvm.frameaddress(i32 3)
-  ret i8* %3
-}
-
-define i8* @test_returnaddress_0() nounwind {
-; RV32I-LABEL: test_returnaddress_0:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a0, ra
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_returnaddress_0:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    mv a0, ra
-; RV64I-NEXT:    ret
-  %1 = call i8* @llvm.returnaddress(i32 0)
-  ret i8* %1
-}
-
-define i8* @test_returnaddress_2() nounwind {
-; RV32I-LABEL: test_returnaddress_2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw a0, -4(a0)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_returnaddress_2:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi sp, sp, -16
-; RV64I-NEXT:    sd ra, 8(sp)
-; RV64I-NEXT:    sd s0, 0(sp)
-; RV64I-NEXT:    addi s0, sp, 16
-; RV64I-NEXT:    ld a0, -16(s0)
-; RV64I-NEXT:    ld a0, -16(a0)
-; RV64I-NEXT:    ld a0, -8(a0)
-; RV64I-NEXT:    ld s0, 0(sp)
-; RV64I-NEXT:    ld ra, 8(sp)
-; RV64I-NEXT:    addi sp, sp, 16
-; RV64I-NEXT:    ret
-  %1 = call i8* @llvm.returnaddress(i32 2)
-  ret i8* %1
-}
diff --git a/test/CodeGen/RISCV/get-setcc-result-type.ll b/test/CodeGen/RISCV/get-setcc-result-type.ll
deleted file mode 100644
index 507f04822b8..00000000000
--- a/test/CodeGen/RISCV/get-setcc-result-type.ll
+++ /dev/null
@@ -1,31 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define void @getSetCCResultType(<4 x i32>* %p, <4 x i32>* %q) {
-; RV32I-LABEL: getSetCCResultType:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lw a1, 12(a0)
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 12(a0)
-; RV32I-NEXT:    lw a1, 8(a0)
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 8(a0)
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 4(a0)
-; RV32I-NEXT:    lw a1, 0(a0)
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 0(a0)
-; RV32I-NEXT:    ret
-entry:
-  %0 = load <4 x i32>, <4 x i32>* %p, align 16
-  %cmp = icmp eq <4 x i32> %0, zeroinitializer
-  %sext = sext <4 x i1> %cmp to <4 x i32>
-  store <4 x i32> %sext, <4 x i32>* %p, align 16
-  ret void
-}
diff --git a/test/CodeGen/RISCV/hoist-global-addr-base.ll b/test/CodeGen/RISCV/hoist-global-addr-base.ll
deleted file mode 100644
index 2a1d5ed1a08..00000000000
--- a/test/CodeGen/RISCV/hoist-global-addr-base.ll
+++ /dev/null
@@ -1,169 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32  < %s | FileCheck  %s
-
-%struct.S = type { [40 x i32], i32, i32, i32, [4100 x i32], i32, i32, i32 }
-@s = common dso_local global %struct.S zeroinitializer, align 4
-@foo = global [6 x i16] [i16 1, i16 2, i16 3, i16 4, i16 5, i16 0], align 2
-@g = global [1048576 x i8] zeroinitializer, align 1
-
-
-define dso_local void @multiple_stores() local_unnamed_addr {
-; CHECK-LABEL: multiple_stores:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s)
-; CHECK-NEXT:    addi a0, a0, %lo(s)
-; CHECK-NEXT:    addi a1, zero, 20
-; CHECK-NEXT:    sw a1, 164(a0)
-; CHECK-NEXT:    addi a1, zero, 10
-; CHECK-NEXT:    sw a1, 160(a0)
-; CHECK-NEXT:    ret
-entry:
-  store i32 10, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 1), align 4
-  store i32 20, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 2), align 4
-  ret void
-}
-
-define dso_local void @control_flow_with_mem_access() local_unnamed_addr #0 {
-; CHECK-LABEL: control_flow_with_mem_access:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s)
-; CHECK-NEXT:    addi a0, a0, %lo(s)
-; CHECK-NEXT:    lw a1, 164(a0)
-; CHECK-NEXT:    addi a2, zero, 1
-; CHECK-NEXT:    blt a1, a2, .LBB1_2
-; CHECK-NEXT:  # %bb.1: # %if.then
-; CHECK-NEXT:    addi a1, zero, 10
-; CHECK-NEXT:    sw a1, 160(a0)
-; CHECK-NEXT:  .LBB1_2: # %if.end
-; CHECK-NEXT:    ret
-entry:
-  %0 = load i32, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 2), align 4
-  %cmp = icmp sgt i32 %0, 0
-  br i1 %cmp, label %if.then, label %if.end
-
-if.then:                                          ; preds = %entry
-  store i32 10, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 1), align 4
-  br label %if.end
-
-if.end:                                           ; preds = %if.then, %entry
-  ret void
-}
-
-; This test checks that the offset is reconstructed correctly when
-; "addi" of the big offset has a negative immediate.
-; without peephole this generates:
-; lui  a1, %hi(g)
-; addi a1, a0, %lo(g)
-; lui  a0, 18     ---> offset
-; addi a0, a0, -160
-; add  a0, a0, a1  ---> base + offset.
-define i8* @big_offset_neg_addi() {
-; CHECK-LABEL: big_offset_neg_addi:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    lui a0, %hi(g+73568)
-; CHECK-NEXT:    addi a0, a0, %lo(g+73568)
-; CHECK-NEXT:    ret
-  ret i8* getelementptr inbounds ([1048576 x i8], [1048576 x i8]* @g, i32 0, i32 73568)
-}
-
-; This test checks for the case where the offset is only an LUI.
-; without peephole this generates:
-; lui  a0, %hi(g)
-; addi a0, a0, %lo(g)
-; lui  a1, 128     ---> offset
-; add  a0, a0, a1  ---> base + offset.
-define i8* @big_offset_lui_tail() {
-; CHECK-LABEL: big_offset_lui_tail:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    lui a0, %hi(g+524288)
-; CHECK-NEXT:    addi a0, a0, %lo(g+524288)
-; CHECK-NEXT:    ret
-  ret i8* getelementptr inbounds ([1048576 x i8], [1048576 x i8]* @g, i32 0, i32 524288)
-}
-
-define dso_local i32* @big_offset_one_use() local_unnamed_addr {
-; CHECK-LABEL: big_offset_one_use:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s+16572)
-; CHECK-NEXT:    addi a0, a0, %lo(s+16572)
-; CHECK-NEXT:    ret
-entry:
-  ret i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 5)
-}
-
-define dso_local i32* @small_offset_one_use() local_unnamed_addr {
-; CHECK-LABEL: small_offset_one_use:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s+160)
-; CHECK-NEXT:    addi a0, a0, %lo(s+160)
-; CHECK-NEXT:    ret
-entry:
-  ret i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 1)
-}
-
-; Function Attrs: norecurse nounwind optsize readonly
-define dso_local i32* @control_flow_no_mem(i32 %n) local_unnamed_addr #1 {
-; CHECK-LABEL: control_flow_no_mem:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s)
-; CHECK-NEXT:    addi a0, a0, %lo(s)
-; CHECK-NEXT:    lw a1, 164(a0)
-; CHECK-NEXT:    beqz a1, .LBB6_2
-; CHECK-NEXT:  # %bb.1: # %if.end
-; CHECK-NEXT:    addi a0, a0, 168
-; CHECK-NEXT:    ret
-; CHECK-NEXT:  .LBB6_2: # %if.then
-; CHECK-NEXT:    addi a0, a0, 160
-; CHECK-NEXT:    ret
-entry:
-  %0 = load i32, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 2), align 4
-  %cmp = icmp eq i32 %0, 0
-  br i1 %cmp, label %if.then, label %if.end
-if.then:                                          ; preds = %entry
-  ret i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 1)
-if.end:                                           ; preds = %if.then, %entry
-  ret i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 3)
-}
-
-define dso_local i32 @load_half() nounwind {
-; CHECK-LABEL: load_half:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    addi sp, sp, -16
-; CHECK-NEXT:    sw ra, 12(sp)
-; CHECK-NEXT:    lui a0, %hi(foo+8)
-; CHECK-NEXT:    lhu a0, %lo(foo+8)(a0)
-; CHECK-NEXT:    addi a1, zero, 140
-; CHECK-NEXT:    bne a0, a1, .LBB7_2
-; CHECK-NEXT:  # %bb.1: # %if.end
-; CHECK-NEXT:    mv a0, zero
-; CHECK-NEXT:    lw ra, 12(sp)
-; CHECK-NEXT:    addi sp, sp, 16
-; CHECK-NEXT:    ret
-; CHECK-NEXT:  .LBB7_2: # %if.then
-; CHECK-NEXT:    call abort
-entry:
-  %0 = load i16, i16* getelementptr inbounds ([6 x i16], [6 x i16]* @foo, i32 0, i32 4), align 2
-  %cmp = icmp eq i16 %0, 140
-  br i1 %cmp, label %if.end, label %if.then
-
-if.then:
-  tail call void @abort()
-  unreachable
-
-if.end:
-  ret i32 0
-}
-
-declare void @abort()
-
-define dso_local void @one_store() local_unnamed_addr {
-; CHECK-LABEL: one_store:
-; CHECK:       # %bb.0: # %entry
-; CHECK-NEXT:    lui a0, %hi(s+160)
-; CHECK-NEXT:    addi a1, zero, 10
-; CHECK-NEXT:    sw a1, %lo(s+160)(a0)
-; CHECK-NEXT:    ret
-entry:
-  store i32 10, i32* getelementptr inbounds (%struct.S, %struct.S* @s, i32 0, i32 1), align 4
-  ret void
-}
diff --git a/test/CodeGen/RISCV/i32-icmp.ll b/test/CodeGen/RISCV/i32-icmp.ll
deleted file mode 100644
index 3b89504bbc0..00000000000
--- a/test/CodeGen/RISCV/i32-icmp.ll
+++ /dev/null
@@ -1,134 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; TODO: check the generated instructions for the equivalent of seqz, snez,
-; sltz, sgtz map to something simple
-
-define i32 @icmp_eq(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_eq:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    seqz a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp eq i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_eqz(i32 %a) nounwind {
-; RV32I-LABEL: icmp_eqz:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    seqz a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp eq i32 %a, 0
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ne(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ne:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp ne i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_nez(i32 %a) nounwind {
-; RV32I-LABEL: icmp_nez:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp ne i32 %a, 0
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ugt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ugt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a1, a0
-; RV32I-NEXT:    ret
-  %1 = icmp ugt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_uge(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_uge:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp uge i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ult(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ult:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp ult i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ule(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ule:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a1, a0
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp ule i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sgt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sgt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a1, a0
-; RV32I-NEXT:    ret
-  %1 = icmp sgt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sge(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sge:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp sge i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_slt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp slt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sle(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sle:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a1, a0
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp sle i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-; TODO: check variants with an immediate?
diff --git a/test/CodeGen/RISCV/imm-cse.ll b/test/CodeGen/RISCV/imm-cse.ll
deleted file mode 100644
index 7ece29d5316..00000000000
--- a/test/CodeGen/RISCV/imm-cse.ll
+++ /dev/null
@@ -1,39 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-@src = global i32 0
-@dst = global i32 0
-
-; Tests that the common hi20 value (1) for the constants is used rather than
-; redundantly re-materialised.
-define void @imm32_cse() nounwind {
-; RV32I-LABEL: imm32_cse:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 1
-; RV32I-NEXT:    addi a1, a0, 1
-; RV32I-NEXT:    lui a2, %hi(src)
-; RV32I-NEXT:    lw a3, %lo(src)(a2)
-; RV32I-NEXT:    add a1, a3, a1
-; RV32I-NEXT:    lui a3, %hi(dst)
-; RV32I-NEXT:    sw a1, %lo(dst)(a3)
-; RV32I-NEXT:    addi a1, a0, 2
-; RV32I-NEXT:    lw a4, %lo(src)(a2)
-; RV32I-NEXT:    add a1, a4, a1
-; RV32I-NEXT:    sw a1, %lo(dst)(a3)
-; RV32I-NEXT:    addi a0, a0, 3
-; RV32I-NEXT:    lw a1, %lo(src)(a2)
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    sw a0, %lo(dst)(a3)
-; RV32I-NEXT:    ret
-  %1 = load volatile i32, i32* @src
-  %2 = add i32 %1, 4097
-  store volatile i32 %2, i32* @dst
-  %3 = load volatile i32, i32* @src
-  %4 = add i32 %3, 4098
-  store volatile i32 %4, i32* @dst
-  %5 = load volatile i32, i32* @src
-  %6 = add i32 %5, 4099
-  store volatile i32 %6, i32* @dst
-  ret void
-}
diff --git a/test/CodeGen/RISCV/imm.ll b/test/CodeGen/RISCV/imm.ll
deleted file mode 100644
index 872b6d5a986..00000000000
--- a/test/CodeGen/RISCV/imm.ll
+++ /dev/null
@@ -1,260 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; Materializing constants
-
-; TODO: It would be preferable if anyext constant returns were sign rather
-; than zero extended. See PR39092. For now, mark returns as explicitly signext
-; (this matches what Clang would generate for equivalent C/C++ anyway).
-
-define signext i32 @zero() nounwind {
-; RV32I-LABEL: zero:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zero:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    mv a0, zero
-; RV64I-NEXT:    ret
-  ret i32 0
-}
-
-define signext i32 @pos_small() nounwind {
-; RV32I-LABEL: pos_small:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, 2047
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: pos_small:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 2047
-; RV64I-NEXT:    ret
-  ret i32 2047
-}
-
-define signext i32 @neg_small() nounwind {
-; RV32I-LABEL: neg_small:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, -2048
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: neg_small:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, -2048
-; RV64I-NEXT:    ret
-  ret i32 -2048
-}
-
-define signext i32 @pos_i32() nounwind {
-; RV32I-LABEL: pos_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 423811
-; RV32I-NEXT:    addi a0, a0, -1297
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: pos_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 423811
-; RV64I-NEXT:    addiw a0, a0, -1297
-; RV64I-NEXT:    ret
-  ret i32 1735928559
-}
-
-define signext i32 @neg_i32() nounwind {
-; RV32I-LABEL: neg_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 912092
-; RV32I-NEXT:    addi a0, a0, -273
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: neg_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 912092
-; RV64I-NEXT:    addiw a0, a0, -273
-; RV64I-NEXT:    ret
-  ret i32 -559038737
-}
-
-define signext i32 @pos_i32_hi20_only() nounwind {
-; RV32I-LABEL: pos_i32_hi20_only:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 16
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: pos_i32_hi20_only:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 16
-; RV64I-NEXT:    ret
-  ret i32 65536
-}
-
-define signext i32 @neg_i32_hi20_only() nounwind {
-; RV32I-LABEL: neg_i32_hi20_only:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 1048560
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: neg_i32_hi20_only:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 1048560
-; RV64I-NEXT:    ret
-  ret i32 -65536
-}
-
-define i64 @imm64_1() nounwind {
-; RV32I-LABEL: imm64_1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 524288
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 1
-; RV64I-NEXT:    slli a0, a0, 31
-; RV64I-NEXT:    ret
-  ret i64 2147483648
-}
-
-; TODO: This and similar constants with all 0s in the upper bits and all 1s in
-; the lower bits could be lowered to addi a0, zero, -1 followed by a logical
-; right shift.
-define i64 @imm64_2() nounwind {
-; RV32I-LABEL: imm64_2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, -1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_2:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    addi a0, a0, -1
-; RV64I-NEXT:    ret
-  ret i64 4294967295
-}
-
-define i64 @imm64_3() nounwind {
-; RV32I-LABEL: imm64_3:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a1, zero, 1
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_3:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    ret
-  ret i64 4294967296
-}
-
-define i64 @imm64_4() nounwind {
-; RV32I-LABEL: imm64_4:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 524288
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_4:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, -1
-; RV64I-NEXT:    slli a0, a0, 63
-; RV64I-NEXT:    ret
-  ret i64 9223372036854775808
-}
-
-define i64 @imm64_5() nounwind {
-; RV32I-LABEL: imm64_5:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 524288
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_5:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, -1
-; RV64I-NEXT:    slli a0, a0, 63
-; RV64I-NEXT:    ret
-  ret i64 -9223372036854775808
-}
-
-define i64 @imm64_6() nounwind {
-; RV32I-LABEL: imm64_6:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 74565
-; RV32I-NEXT:    addi a1, a0, 1656
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_6:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 9321
-; RV64I-NEXT:    addiw a0, a0, -1329
-; RV64I-NEXT:    slli a0, a0, 35
-; RV64I-NEXT:    ret
-  ret i64 1311768464867721216
-}
-
-define i64 @imm64_7() nounwind {
-; RV32I-LABEL: imm64_7:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 45056
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    lui a1, 458752
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_7:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, 7
-; RV64I-NEXT:    slli a0, a0, 36
-; RV64I-NEXT:    addi a0, a0, 11
-; RV64I-NEXT:    slli a0, a0, 24
-; RV64I-NEXT:    addi a0, a0, 15
-; RV64I-NEXT:    ret
-  ret i64 8070450532432478223
-}
-
-; TODO: it can be preferable to put constants that are expensive to materialise
-; into the constant pool, especially for -Os.
-define i64 @imm64_8() nounwind {
-; RV32I-LABEL: imm64_8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 633806
-; RV32I-NEXT:    addi a0, a0, -272
-; RV32I-NEXT:    lui a1, 74565
-; RV32I-NEXT:    addi a1, a1, 1656
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a0, 583
-; RV64I-NEXT:    addiw a0, a0, -1875
-; RV64I-NEXT:    slli a0, a0, 14
-; RV64I-NEXT:    addi a0, a0, -947
-; RV64I-NEXT:    slli a0, a0, 12
-; RV64I-NEXT:    addi a0, a0, 1511
-; RV64I-NEXT:    slli a0, a0, 13
-; RV64I-NEXT:    addi a0, a0, -272
-; RV64I-NEXT:    ret
-  ret i64 1311768467463790320
-}
-
-define i64 @imm64_9() nounwind {
-; RV32I-LABEL: imm64_9:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, -1
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: imm64_9:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, zero, -1
-; RV64I-NEXT:    ret
-  ret i64 -1
-}
diff --git a/test/CodeGen/RISCV/indirectbr.ll b/test/CodeGen/RISCV/indirectbr.ll
deleted file mode 100644
index 1d916b8e108..00000000000
--- a/test/CodeGen/RISCV/indirectbr.ll
+++ /dev/null
@@ -1,40 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define i32 @indirectbr(i8* %target) nounwind {
-; RV32I-LABEL: indirectbr:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    jr a0
-; RV32I-NEXT:  .LBB0_1:
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  indirectbr i8* %target, [label %test_label]
-test_label:
-  br label %ret
-ret:
-  ret i32 0
-}
-
-define i32 @indirectbr_with_offset(i8* %a) nounwind {
-; RV32I-LABEL: indirectbr_with_offset:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    jalr zero, a0, 1380
-; RV32I-NEXT:  .LBB1_1:
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %target = getelementptr inbounds i8, i8* %a, i32 1380
-  indirectbr i8* %target, [label %test_label]
-test_label:
-  br label %ret
-ret:
-  ret i32 0
-}
diff --git a/test/CodeGen/RISCV/init-array.ll b/test/CodeGen/RISCV/init-array.ll
deleted file mode 100644
index 1927eeb6d11..00000000000
--- a/test/CodeGen/RISCV/init-array.ll
+++ /dev/null
@@ -1,30 +0,0 @@
-; RUN: llc -mtriple=riscv32-unknown-linux-gnu -verify-machineinstrs -o - %s \
-; RUN: | FileCheck --check-prefix=INITARRAY %s
-; RUN: llc -mtriple=riscv32-unknown-elf -verify-machineinstrs -o - %s \
-; RUN: | FileCheck --check-prefix=INITARRAY %s
-; RUN: llc -mtriple=riscv64-unknown-linux-gnu -verify-machineinstrs -o - %s \
-; RUN: | FileCheck --check-prefix=INITARRAY %s
-; RUN: llc -mtriple=riscv64-unknown-elf -verify-machineinstrs -o - %s \
-; RUN: | FileCheck --check-prefix=INITARRAY %s
-
-; RUN: llc -mtriple=riscv32-unknown-linux-gnu -verify-machineinstrs -use-ctors -o - %s \
-; RUN: | FileCheck --check-prefix=CTOR %s
-; RUN: llc -mtriple=riscv32-unknown-elf -verify-machineinstrs -use-ctors -o - %s \
-; RUN: | FileCheck --check-prefix=CTOR %s
-; RUN: llc -mtriple=riscv64-unknown-linux-gnu -verify-machineinstrs -use-ctors -o - %s \
-; RUN: | FileCheck --check-prefix=CTOR %s
-; RUN: llc -mtriple=riscv64-unknown-elf -verify-machineinstrs -use-ctors -o - %s \
-; RUN: | FileCheck --check-prefix=CTOR %s
-
-define internal void @_GLOBAL__I_a() section ".text.startup" {
-  ret void
-}
-
-@llvm.global_ctors = appending global [1 x { i32, void ()* }] [{ i32, void ()* } { i32 65535, void ()* @_GLOBAL__I_a }]
-
-;INITARRAY: section .init_array
-;INITARRAY-NOT: .section    .ctors
-
-;CTOR: .section .ctors
-;CTOR-NOT:  section .init_array
-
diff --git a/test/CodeGen/RISCV/inline-asm.ll b/test/CodeGen/RISCV/inline-asm.ll
deleted file mode 100644
index a16375be692..00000000000
--- a/test/CodeGen/RISCV/inline-asm.ll
+++ /dev/null
@@ -1,54 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-@gi = external global i32
-
-define i32 @constraint_r(i32 %a) {
-; RV32I-LABEL: constraint_r:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, %hi(gi)
-; RV32I-NEXT:    lw a1, %lo(gi)(a1)
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = load i32, i32* @gi
-  %2 = tail call i32 asm "add $0, $1, $2", "=r,r,r"(i32 %a, i32 %1)
-  ret i32 %2
-}
-
-define i32 @constraint_i(i32 %a) {
-; RV32I-LABEL: constraint_i:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    addi a0, a0, 113
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = load i32, i32* @gi
-  %2 = tail call i32 asm "addi $0, $1, $2", "=r,r,i"(i32 %a, i32 113)
-  ret i32 %2
-}
-
-define void @constraint_m(i32* %a) {
-; RV32I-LABEL: constraint_m:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  call void asm sideeffect "", "=*m"(i32* %a)
-  ret void
-}
-
-define i32 @constraint_m2(i32* %a) {
-; RV32I-LABEL: constraint_m2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = tail call i32 asm "lw $0, $1", "=r,*m"(i32* %a) nounwind
-  ret i32 %1
-}
-
-; TODO: expend tests for more complex constraints, out of range immediates etc
diff --git a/test/CodeGen/RISCV/interrupt-attr-args-error.ll b/test/CodeGen/RISCV/interrupt-attr-args-error.ll
deleted file mode 100644
index 5f246cd6629..00000000000
--- a/test/CodeGen/RISCV/interrupt-attr-args-error.ll
+++ /dev/null
@@ -1,11 +0,0 @@
-; RUN: not llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv64-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-
-; CHECK: LLVM ERROR: Functions with the interrupt attribute cannot have arguments!
-define i32 @isr_user(i8 %n) #0 {
-  ret i32 0
-}
-
-attributes #0 = { "interrupt"="user" }
diff --git a/test/CodeGen/RISCV/interrupt-attr-invalid.ll b/test/CodeGen/RISCV/interrupt-attr-invalid.ll
deleted file mode 100644
index bddca8af746..00000000000
--- a/test/CodeGen/RISCV/interrupt-attr-invalid.ll
+++ /dev/null
@@ -1,11 +0,0 @@
-; RUN: not llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv64-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-
-; CHECK: LLVM ERROR: Function interrupt attribute argument not supported!
-define void @isr_user() #0 {
-  ret void
-}
-
-attributes #0 = { "interrupt"="foo" }
diff --git a/test/CodeGen/RISCV/interrupt-attr-nocall.ll b/test/CodeGen/RISCV/interrupt-attr-nocall.ll
deleted file mode 100644
index b8f6100cdd6..00000000000
--- a/test/CodeGen/RISCV/interrupt-attr-nocall.ll
+++ /dev/null
@@ -1,217 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32
-; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32-F
-; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f,+d -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32-FD
-;
-; TODO: Add RV64 tests when we can lower global addresses.
-
-; Checking all registers that are used are being saved.
-; This includes Caller (arguments and temps) and
-; Callee saved registers.
-;
-; extern int a, b, c;
-; __attribute__((interrupt)) void foo_no_call(void) {
-;   c = a + b;
-; }
-;
-
-@a = external global i32
-@b = external global i32
-@c = external global i32
-
-define void @foo_i32() #0 {
-; CHECK-RV32-LABEL: foo_i32:
-; CHECK-RV32:       # %bb.0:
-; CHECK-RV32-NEXT:    addi sp, sp, -16
-; CHECK-RV32-NEXT:    sw a0, 12(sp)
-; CHECK-RV32-NEXT:    sw a1, 8(sp)
-; CHECK-RV32-NEXT:    lui a0, %hi(a)
-; CHECK-RV32-NEXT:    lw a0, %lo(a)(a0)
-; CHECK-RV32-NEXT:    lui a1, %hi(b)
-; CHECK-RV32-NEXT:    lw a1, %lo(b)(a1)
-; CHECK-RV32-NEXT:    add a0, a1, a0
-; CHECK-RV32-NEXT:    lui a1, %hi(c)
-; CHECK-RV32-NEXT:    sw a0, %lo(c)(a1)
-; CHECK-RV32-NEXT:    lw a1, 8(sp)
-; CHECK-RV32-NEXT:    lw a0, 12(sp)
-; CHECK-RV32-NEXT:    addi sp, sp, 16
-; CHECK-RV32-NEXT:    mret
-;
-  %1 = load i32, i32* @a
-  %2 = load i32, i32* @b
-  %add = add nsw i32 %2, %1
-  store i32 %add, i32* @c
-  ret void
-}
-
-;
-; Additionally check frame pointer and return address are properly saved.
-;
-
-define void @foo_fp_i32() #1 {
-; CHECK-RV32-LABEL: foo_fp_i32:
-; CHECK-RV32:       # %bb.0:
-; CHECK-RV32-NEXT:    addi sp, sp, -16
-; CHECK-RV32-NEXT:    sw ra, 12(sp)
-; CHECK-RV32-NEXT:    sw s0, 8(sp)
-; CHECK-RV32-NEXT:    sw a0, 4(sp)
-; CHECK-RV32-NEXT:    sw a1, 0(sp)
-; CHECK-RV32-NEXT:    addi s0, sp, 16
-; CHECK-RV32-NEXT:    lui a0, %hi(a)
-; CHECK-RV32-NEXT:    lw a0, %lo(a)(a0)
-; CHECK-RV32-NEXT:    lui a1, %hi(b)
-; CHECK-RV32-NEXT:    lw a1, %lo(b)(a1)
-; CHECK-RV32-NEXT:    add a0, a1, a0
-; CHECK-RV32-NEXT:    lui a1, %hi(c)
-; CHECK-RV32-NEXT:    sw a0, %lo(c)(a1)
-; CHECK-RV32-NEXT:    lw a1, 0(sp)
-; CHECK-RV32-NEXT:    lw a0, 4(sp)
-; CHECK-RV32-NEXT:    lw s0, 8(sp)
-; CHECK-RV32-NEXT:    lw ra, 12(sp)
-; CHECK-RV32-NEXT:    addi sp, sp, 16
-; CHECK-RV32-NEXT:    mret
-;
-  %1 = load i32, i32* @a
-  %2 = load i32, i32* @b
-  %add = add nsw i32 %2, %1
-  store i32 %add, i32* @c
-  ret void
-}
-
-@e = external global float
-@f = external global float
-@d = external global float
-
-define void @foo_float() #0 {
-; CHECK-RV32-F-LABEL: foo_float:
-; CHECK-RV32-F:       # %bb.0:
-; CHECK-RV32-F-NEXT:    addi sp, sp, -16
-; CHECK-RV32-F-NEXT:    sw a0, 12(sp)
-; CHECK-RV32-F-NEXT:    fsw ft0, 8(sp)
-; CHECK-RV32-F-NEXT:    fsw ft1, 4(sp)
-; CHECK-RV32-F-NEXT:    lui a0, %hi(f)
-; CHECK-RV32-F-NEXT:    flw ft0, %lo(f)(a0)
-; CHECK-RV32-F-NEXT:    lui a0, %hi(e)
-; CHECK-RV32-F-NEXT:    flw ft1, %lo(e)(a0)
-; CHECK-RV32-F-NEXT:    fadd.s ft0, ft1, ft0
-; CHECK-RV32-F-NEXT:    lui a0, %hi(d)
-; CHECK-RV32-F-NEXT:    fsw ft0, %lo(d)(a0)
-; CHECK-RV32-F-NEXT:    flw ft1, 4(sp)
-; CHECK-RV32-F-NEXT:    flw ft0, 8(sp)
-; CHECK-RV32-F-NEXT:    lw a0, 12(sp)
-; CHECK-RV32-F-NEXT:    addi sp, sp, 16
-; CHECK-RV32-F-NEXT:    mret
-;
-  %1 = load float, float* @e
-  %2 = load float, float* @f
-  %add = fadd float %1, %2
-  store float %add, float* @d
-  ret void
-}
-
-;
-; Additionally check frame pointer and return address are properly saved.
-;
-define void @foo_fp_float() #1 {
-; CHECK-RV32-F-LABEL: foo_fp_float:
-; CHECK-RV32-F:       # %bb.0:
-; CHECK-RV32-F-NEXT:    addi sp, sp, -32
-; CHECK-RV32-F-NEXT:    sw ra, 28(sp)
-; CHECK-RV32-F-NEXT:    sw s0, 24(sp)
-; CHECK-RV32-F-NEXT:    sw a0, 20(sp)
-; CHECK-RV32-F-NEXT:    fsw ft0, 16(sp)
-; CHECK-RV32-F-NEXT:    fsw ft1, 12(sp)
-; CHECK-RV32-F-NEXT:    addi s0, sp, 32
-; CHECK-RV32-F-NEXT:    lui a0, %hi(f)
-; CHECK-RV32-F-NEXT:    flw ft0, %lo(f)(a0)
-; CHECK-RV32-F-NEXT:    lui a0, %hi(e)
-; CHECK-RV32-F-NEXT:    flw ft1, %lo(e)(a0)
-; CHECK-RV32-F-NEXT:    fadd.s ft0, ft1, ft0
-; CHECK-RV32-F-NEXT:    lui a0, %hi(d)
-; CHECK-RV32-F-NEXT:    fsw ft0, %lo(d)(a0)
-; CHECK-RV32-F-NEXT:    flw ft1, 12(sp)
-; CHECK-RV32-F-NEXT:    flw ft0, 16(sp)
-; CHECK-RV32-F-NEXT:    lw a0, 20(sp)
-; CHECK-RV32-F-NEXT:    lw s0, 24(sp)
-; CHECK-RV32-F-NEXT:    lw ra, 28(sp)
-; CHECK-RV32-F-NEXT:    addi sp, sp, 32
-; CHECK-RV32-F-NEXT:    mret
-;
-  %1 = load float, float* @e
-  %2 = load float, float* @f
-  %add = fadd float %1, %2
-  store float %add, float* @d
-  ret void
-}
-
-@h = external global double
-@i = external global double
-@g = external global double
-
-define void @foo_double() #0 {
-; CHECK-RV32-FD-LABEL: foo_double:
-; CHECK-RV32-FD:       # %bb.0:
-; CHECK-RV32-FD-NEXT:    addi sp, sp, -32
-; CHECK-RV32-FD-NEXT:    sw a0, 28(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft0, 16(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft1, 8(sp)
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(i)
-; CHECK-RV32-FD-NEXT:    fld ft0, %lo(i)(a0)
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(h)
-; CHECK-RV32-FD-NEXT:    fld ft1, %lo(h)(a0)
-; CHECK-RV32-FD-NEXT:    fadd.d ft0, ft1, ft0
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(g)
-; CHECK-RV32-FD-NEXT:    fsd ft0, %lo(g)(a0)
-; CHECK-RV32-FD-NEXT:    fld ft1, 8(sp)
-; CHECK-RV32-FD-NEXT:    fld ft0, 16(sp)
-; CHECK-RV32-FD-NEXT:    lw a0, 28(sp)
-; CHECK-RV32-FD-NEXT:    addi sp, sp, 32
-; CHECK-RV32-FD-NEXT:    mret
-;
-  %1 = load double, double* @h
-  %2 = load double, double* @i
-  %add = fadd double %1, %2
-  store double %add, double* @g
-  ret void
-}
-
-;
-; Additionally check frame pointer and return address are properly saved.
-;
-define void @foo_fp_double() #1 {
-; CHECK-RV32-FD-LABEL: foo_fp_double:
-; CHECK-RV32-FD:       # %bb.0:
-; CHECK-RV32-FD-NEXT:    addi sp, sp, -32
-; CHECK-RV32-FD-NEXT:    sw ra, 28(sp)
-; CHECK-RV32-FD-NEXT:    sw s0, 24(sp)
-; CHECK-RV32-FD-NEXT:    sw a0, 20(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft0, 8(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft1, 0(sp)
-; CHECK-RV32-FD-NEXT:    addi s0, sp, 32
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(i)
-; CHECK-RV32-FD-NEXT:    fld ft0, %lo(i)(a0)
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(h)
-; CHECK-RV32-FD-NEXT:    fld ft1, %lo(h)(a0)
-; CHECK-RV32-FD-NEXT:    fadd.d ft0, ft1, ft0
-; CHECK-RV32-FD-NEXT:    lui a0, %hi(g)
-; CHECK-RV32-FD-NEXT:    fsd ft0, %lo(g)(a0)
-; CHECK-RV32-FD-NEXT:    fld ft1, 0(sp)
-; CHECK-RV32-FD-NEXT:    fld ft0, 8(sp)
-; CHECK-RV32-FD-NEXT:    lw a0, 20(sp)
-; CHECK-RV32-FD-NEXT:    lw s0, 24(sp)
-; CHECK-RV32-FD-NEXT:    lw ra, 28(sp)
-; CHECK-RV32-FD-NEXT:    addi sp, sp, 32
-; CHECK-RV32-FD-NEXT:    mret
-;
-  %1 = load double, double* @h
-  %2 = load double, double* @i
-  %add = fadd double %1, %2
-  store double %add, double* @g
-  ret void
-}
-
-attributes #0 = { "interrupt"="machine" }
-attributes #1 = { "interrupt"="machine" "no-frame-pointer-elim"="true" }
diff --git a/test/CodeGen/RISCV/interrupt-attr-ret-error.ll b/test/CodeGen/RISCV/interrupt-attr-ret-error.ll
deleted file mode 100644
index 58827a86060..00000000000
--- a/test/CodeGen/RISCV/interrupt-attr-ret-error.ll
+++ /dev/null
@@ -1,12 +0,0 @@
-; RUN: not llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv64-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-
-; CHECK: LLVM ERROR: Functions with the interrupt attribute must have void return type!
-define i32 @isr1_user() #0 {
-  ret i32 0
-}
-
-
-attributes #0 = { "interrupt"="user" }
diff --git a/test/CodeGen/RISCV/interrupt-attr.ll b/test/CodeGen/RISCV/interrupt-attr.ll
deleted file mode 100644
index f01eec0acfd..00000000000
--- a/test/CodeGen/RISCV/interrupt-attr.ll
+++ /dev/null
@@ -1,1066 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV32
-; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV32-F
-; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f,+d -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV32-FD
-;
-; RUN: llc -mtriple riscv64-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV64
-; RUN: llc -mtriple riscv64-unknown-elf -mattr=+f -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV64-F
-; RUN: llc -mtriple riscv64-unknown-elf -mattr=+f,+d -o - %s \
-; RUN: 2>&1 | FileCheck %s -check-prefix CHECK -check-prefix CHECK-RV64-FD
-
-;
-; Checking for special return instructions (uret, sret, mret).
-;
-define void @foo_user() #0 {
-; CHECK-LABEL: foo_user:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    uret
-  ret void
-}
-
-define void @foo_supervisor() #1 {
-; CHECK-LABEL: foo_supervisor:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    sret
-  ret void
-}
-
-define void @foo_machine() #2 {
-; CHECK-LABEL: foo_machine:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    mret
-  ret void
-}
-
-;
-; Checking all Caller saved registers (arguments and temps)
-; and FP registers are all saved when the handler calls another function.
-;
-; extern int otherfoo();
-;
-; __attribute__((interrupt)) void foo_with_call() {
-;   otherfoo();
-; }
-;
-
-declare i32 @otherfoo(...)
-define void @foo_with_call() #2 {
-;
-; CHECK-RV32-LABEL: foo_with_call:
-; CHECK-RV32:       # %bb.0:
-; CHECK-RV32-NEXT:    addi sp, sp, -64
-; CHECK-RV32-NEXT:    sw ra, 60(sp)
-; CHECK-RV32-NEXT:    sw t0, 56(sp)
-; CHECK-RV32-NEXT:    sw t1, 52(sp)
-; CHECK-RV32-NEXT:    sw t2, 48(sp)
-; CHECK-RV32-NEXT:    sw a0, 44(sp)
-; CHECK-RV32-NEXT:    sw a1, 40(sp)
-; CHECK-RV32-NEXT:    sw a2, 36(sp)
-; CHECK-RV32-NEXT:    sw a3, 32(sp)
-; CHECK-RV32-NEXT:    sw a4, 28(sp)
-; CHECK-RV32-NEXT:    sw a5, 24(sp)
-; CHECK-RV32-NEXT:    sw a6, 20(sp)
-; CHECK-RV32-NEXT:    sw a7, 16(sp)
-; CHECK-RV32-NEXT:    sw t3, 12(sp)
-; CHECK-RV32-NEXT:    sw t4, 8(sp)
-; CHECK-RV32-NEXT:    sw t5, 4(sp)
-; CHECK-RV32-NEXT:    sw t6, 0(sp)
-; CHECK-RV32-NEXT:    call otherfoo
-; CHECK-RV32-NEXT:    lw t6, 0(sp)
-; CHECK-RV32-NEXT:    lw t5, 4(sp)
-; CHECK-RV32-NEXT:    lw t4, 8(sp)
-; CHECK-RV32-NEXT:    lw t3, 12(sp)
-; CHECK-RV32-NEXT:    lw a7, 16(sp)
-; CHECK-RV32-NEXT:    lw a6, 20(sp)
-; CHECK-RV32-NEXT:    lw a5, 24(sp)
-; CHECK-RV32-NEXT:    lw a4, 28(sp)
-; CHECK-RV32-NEXT:    lw a3, 32(sp)
-; CHECK-RV32-NEXT:    lw a2, 36(sp)
-; CHECK-RV32-NEXT:    lw a1, 40(sp)
-; CHECK-RV32-NEXT:    lw a0, 44(sp)
-; CHECK-RV32-NEXT:    lw t2, 48(sp)
-; CHECK-RV32-NEXT:    lw t1, 52(sp)
-; CHECK-RV32-NEXT:    lw t0, 56(sp)
-; CHECK-RV32-NEXT:    lw ra, 60(sp)
-; CHECK-RV32-NEXT:    addi sp, sp, 64
-; CHECK-RV32-NEXT:    mret
-;
-; CHECK-RV32-F-LABEL: foo_with_call:
-; CHECK-RV32-F:       # %bb.0:
-; CHECK-RV32-F-NEXT:    addi sp, sp, -192
-; CHECK-RV32-F-NEXT:    sw ra, 188(sp)
-; CHECK-RV32-F-NEXT:    sw t0, 184(sp)
-; CHECK-RV32-F-NEXT:    sw t1, 180(sp)
-; CHECK-RV32-F-NEXT:    sw t2, 176(sp)
-; CHECK-RV32-F-NEXT:    sw a0, 172(sp)
-; CHECK-RV32-F-NEXT:    sw a1, 168(sp)
-; CHECK-RV32-F-NEXT:    sw a2, 164(sp)
-; CHECK-RV32-F-NEXT:    sw a3, 160(sp)
-; CHECK-RV32-F-NEXT:    sw a4, 156(sp)
-; CHECK-RV32-F-NEXT:    sw a5, 152(sp)
-; CHECK-RV32-F-NEXT:    sw a6, 148(sp)
-; CHECK-RV32-F-NEXT:    sw a7, 144(sp)
-; CHECK-RV32-F-NEXT:    sw t3, 140(sp)
-; CHECK-RV32-F-NEXT:    sw t4, 136(sp)
-; CHECK-RV32-F-NEXT:    sw t5, 132(sp)
-; CHECK-RV32-F-NEXT:    sw t6, 128(sp)
-; CHECK-RV32-F-NEXT:    fsw ft0, 124(sp)
-; CHECK-RV32-F-NEXT:    fsw ft1, 120(sp)
-; CHECK-RV32-F-NEXT:    fsw ft2, 116(sp)
-; CHECK-RV32-F-NEXT:    fsw ft3, 112(sp)
-; CHECK-RV32-F-NEXT:    fsw ft4, 108(sp)
-; CHECK-RV32-F-NEXT:    fsw ft5, 104(sp)
-; CHECK-RV32-F-NEXT:    fsw ft6, 100(sp)
-; CHECK-RV32-F-NEXT:    fsw ft7, 96(sp)
-; CHECK-RV32-F-NEXT:    fsw fa0, 92(sp)
-; CHECK-RV32-F-NEXT:    fsw fa1, 88(sp)
-; CHECK-RV32-F-NEXT:    fsw fa2, 84(sp)
-; CHECK-RV32-F-NEXT:    fsw fa3, 80(sp)
-; CHECK-RV32-F-NEXT:    fsw fa4, 76(sp)
-; CHECK-RV32-F-NEXT:    fsw fa5, 72(sp)
-; CHECK-RV32-F-NEXT:    fsw fa6, 68(sp)
-; CHECK-RV32-F-NEXT:    fsw fa7, 64(sp)
-; CHECK-RV32-F-NEXT:    fsw ft8, 60(sp)
-; CHECK-RV32-F-NEXT:    fsw ft9, 56(sp)
-; CHECK-RV32-F-NEXT:    fsw ft10, 52(sp)
-; CHECK-RV32-F-NEXT:    fsw ft11, 48(sp)
-; CHECK-RV32-F-NEXT:    fsw fs0, 44(sp)
-; CHECK-RV32-F-NEXT:    fsw fs1, 40(sp)
-; CHECK-RV32-F-NEXT:    fsw fs2, 36(sp)
-; CHECK-RV32-F-NEXT:    fsw fs3, 32(sp)
-; CHECK-RV32-F-NEXT:    fsw fs4, 28(sp)
-; CHECK-RV32-F-NEXT:    fsw fs5, 24(sp)
-; CHECK-RV32-F-NEXT:    fsw fs6, 20(sp)
-; CHECK-RV32-F-NEXT:    fsw fs7, 16(sp)
-; CHECK-RV32-F-NEXT:    fsw fs8, 12(sp)
-; CHECK-RV32-F-NEXT:    fsw fs9, 8(sp)
-; CHECK-RV32-F-NEXT:    fsw fs10, 4(sp)
-; CHECK-RV32-F-NEXT:    fsw fs11, 0(sp)
-; CHECK-RV32-F-NEXT:    call otherfoo
-; CHECK-RV32-F-NEXT:    flw fs11, 0(sp)
-; CHECK-RV32-F-NEXT:    flw fs10, 4(sp)
-; CHECK-RV32-F-NEXT:    flw fs9, 8(sp)
-; CHECK-RV32-F-NEXT:    flw fs8, 12(sp)
-; CHECK-RV32-F-NEXT:    flw fs7, 16(sp)
-; CHECK-RV32-F-NEXT:    flw fs6, 20(sp)
-; CHECK-RV32-F-NEXT:    flw fs5, 24(sp)
-; CHECK-RV32-F-NEXT:    flw fs4, 28(sp)
-; CHECK-RV32-F-NEXT:    flw fs3, 32(sp)
-; CHECK-RV32-F-NEXT:    flw fs2, 36(sp)
-; CHECK-RV32-F-NEXT:    flw fs1, 40(sp)
-; CHECK-RV32-F-NEXT:    flw fs0, 44(sp)
-; CHECK-RV32-F-NEXT:    flw ft11, 48(sp)
-; CHECK-RV32-F-NEXT:    flw ft10, 52(sp)
-; CHECK-RV32-F-NEXT:    flw ft9, 56(sp)
-; CHECK-RV32-F-NEXT:    flw ft8, 60(sp)
-; CHECK-RV32-F-NEXT:    flw fa7, 64(sp)
-; CHECK-RV32-F-NEXT:    flw fa6, 68(sp)
-; CHECK-RV32-F-NEXT:    flw fa5, 72(sp)
-; CHECK-RV32-F-NEXT:    flw fa4, 76(sp)
-; CHECK-RV32-F-NEXT:    flw fa3, 80(sp)
-; CHECK-RV32-F-NEXT:    flw fa2, 84(sp)
-; CHECK-RV32-F-NEXT:    flw fa1, 88(sp)
-; CHECK-RV32-F-NEXT:    flw fa0, 92(sp)
-; CHECK-RV32-F-NEXT:    flw ft7, 96(sp)
-; CHECK-RV32-F-NEXT:    flw ft6, 100(sp)
-; CHECK-RV32-F-NEXT:    flw ft5, 104(sp)
-; CHECK-RV32-F-NEXT:    flw ft4, 108(sp)
-; CHECK-RV32-F-NEXT:    flw ft3, 112(sp)
-; CHECK-RV32-F-NEXT:    flw ft2, 116(sp)
-; CHECK-RV32-F-NEXT:    flw ft1, 120(sp)
-; CHECK-RV32-F-NEXT:    flw ft0, 124(sp)
-; CHECK-RV32-F-NEXT:    lw t6, 128(sp)
-; CHECK-RV32-F-NEXT:    lw t5, 132(sp)
-; CHECK-RV32-F-NEXT:    lw t4, 136(sp)
-; CHECK-RV32-F-NEXT:    lw t3, 140(sp)
-; CHECK-RV32-F-NEXT:    lw a7, 144(sp)
-; CHECK-RV32-F-NEXT:    lw a6, 148(sp)
-; CHECK-RV32-F-NEXT:    lw a5, 152(sp)
-; CHECK-RV32-F-NEXT:    lw a4, 156(sp)
-; CHECK-RV32-F-NEXT:    lw a3, 160(sp)
-; CHECK-RV32-F-NEXT:    lw a2, 164(sp)
-; CHECK-RV32-F-NEXT:    lw a1, 168(sp)
-; CHECK-RV32-F-NEXT:    lw a0, 172(sp)
-; CHECK-RV32-F-NEXT:    lw t2, 176(sp)
-; CHECK-RV32-F-NEXT:    lw t1, 180(sp)
-; CHECK-RV32-F-NEXT:    lw t0, 184(sp)
-; CHECK-RV32-F-NEXT:    lw ra, 188(sp)
-; CHECK-RV32-F-NEXT:    addi sp, sp, 192
-; CHECK-RV32-F-NEXT:    mret
-;
-; CHECK-RV32-FD-LABEL: foo_with_call:
-; CHECK-RV32-FD:       # %bb.0:
-; CHECK-RV32-FD-NEXT:    addi sp, sp, -320
-; CHECK-RV32-FD-NEXT:    sw ra, 316(sp)
-; CHECK-RV32-FD-NEXT:    sw t0, 312(sp)
-; CHECK-RV32-FD-NEXT:    sw t1, 308(sp)
-; CHECK-RV32-FD-NEXT:    sw t2, 304(sp)
-; CHECK-RV32-FD-NEXT:    sw a0, 300(sp)
-; CHECK-RV32-FD-NEXT:    sw a1, 296(sp)
-; CHECK-RV32-FD-NEXT:    sw a2, 292(sp)
-; CHECK-RV32-FD-NEXT:    sw a3, 288(sp)
-; CHECK-RV32-FD-NEXT:    sw a4, 284(sp)
-; CHECK-RV32-FD-NEXT:    sw a5, 280(sp)
-; CHECK-RV32-FD-NEXT:    sw a6, 276(sp)
-; CHECK-RV32-FD-NEXT:    sw a7, 272(sp)
-; CHECK-RV32-FD-NEXT:    sw t3, 268(sp)
-; CHECK-RV32-FD-NEXT:    sw t4, 264(sp)
-; CHECK-RV32-FD-NEXT:    sw t5, 260(sp)
-; CHECK-RV32-FD-NEXT:    sw t6, 256(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft0, 248(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft1, 240(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft2, 232(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft3, 224(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft4, 216(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft5, 208(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft6, 200(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft7, 192(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa0, 184(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa1, 176(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa2, 168(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa3, 160(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa4, 152(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa5, 144(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa6, 136(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa7, 128(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft8, 120(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft9, 112(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft10, 104(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft11, 96(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs0, 88(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs1, 80(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs2, 72(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs3, 64(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs4, 56(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs5, 48(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs6, 40(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs7, 32(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs8, 24(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs9, 16(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs10, 8(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs11, 0(sp)
-; CHECK-RV32-FD-NEXT:    call otherfoo
-; CHECK-RV32-FD-NEXT:    fld fs11, 0(sp)
-; CHECK-RV32-FD-NEXT:    fld fs10, 8(sp)
-; CHECK-RV32-FD-NEXT:    fld fs9, 16(sp)
-; CHECK-RV32-FD-NEXT:    fld fs8, 24(sp)
-; CHECK-RV32-FD-NEXT:    fld fs7, 32(sp)
-; CHECK-RV32-FD-NEXT:    fld fs6, 40(sp)
-; CHECK-RV32-FD-NEXT:    fld fs5, 48(sp)
-; CHECK-RV32-FD-NEXT:    fld fs4, 56(sp)
-; CHECK-RV32-FD-NEXT:    fld fs3, 64(sp)
-; CHECK-RV32-FD-NEXT:    fld fs2, 72(sp)
-; CHECK-RV32-FD-NEXT:    fld fs1, 80(sp)
-; CHECK-RV32-FD-NEXT:    fld fs0, 88(sp)
-; CHECK-RV32-FD-NEXT:    fld ft11, 96(sp)
-; CHECK-RV32-FD-NEXT:    fld ft10, 104(sp)
-; CHECK-RV32-FD-NEXT:    fld ft9, 112(sp)
-; CHECK-RV32-FD-NEXT:    fld ft8, 120(sp)
-; CHECK-RV32-FD-NEXT:    fld fa7, 128(sp)
-; CHECK-RV32-FD-NEXT:    fld fa6, 136(sp)
-; CHECK-RV32-FD-NEXT:    fld fa5, 144(sp)
-; CHECK-RV32-FD-NEXT:    fld fa4, 152(sp)
-; CHECK-RV32-FD-NEXT:    fld fa3, 160(sp)
-; CHECK-RV32-FD-NEXT:    fld fa2, 168(sp)
-; CHECK-RV32-FD-NEXT:    fld fa1, 176(sp)
-; CHECK-RV32-FD-NEXT:    fld fa0, 184(sp)
-; CHECK-RV32-FD-NEXT:    fld ft7, 192(sp)
-; CHECK-RV32-FD-NEXT:    fld ft6, 200(sp)
-; CHECK-RV32-FD-NEXT:    fld ft5, 208(sp)
-; CHECK-RV32-FD-NEXT:    fld ft4, 216(sp)
-; CHECK-RV32-FD-NEXT:    fld ft3, 224(sp)
-; CHECK-RV32-FD-NEXT:    fld ft2, 232(sp)
-; CHECK-RV32-FD-NEXT:    fld ft1, 240(sp)
-; CHECK-RV32-FD-NEXT:    fld ft0, 248(sp)
-; CHECK-RV32-FD-NEXT:    lw t6, 256(sp)
-; CHECK-RV32-FD-NEXT:    lw t5, 260(sp)
-; CHECK-RV32-FD-NEXT:    lw t4, 264(sp)
-; CHECK-RV32-FD-NEXT:    lw t3, 268(sp)
-; CHECK-RV32-FD-NEXT:    lw a7, 272(sp)
-; CHECK-RV32-FD-NEXT:    lw a6, 276(sp)
-; CHECK-RV32-FD-NEXT:    lw a5, 280(sp)
-; CHECK-RV32-FD-NEXT:    lw a4, 284(sp)
-; CHECK-RV32-FD-NEXT:    lw a3, 288(sp)
-; CHECK-RV32-FD-NEXT:    lw a2, 292(sp)
-; CHECK-RV32-FD-NEXT:    lw a1, 296(sp)
-; CHECK-RV32-FD-NEXT:    lw a0, 300(sp)
-; CHECK-RV32-FD-NEXT:    lw t2, 304(sp)
-; CHECK-RV32-FD-NEXT:    lw t1, 308(sp)
-; CHECK-RV32-FD-NEXT:    lw t0, 312(sp)
-; CHECK-RV32-FD-NEXT:    lw ra, 316(sp)
-; CHECK-RV32-FD-NEXT:    addi sp, sp, 320
-; CHECK-RV32-FD-NEXT:    mret
-;
-; CHECK-RV64-LABEL: foo_with_call:
-; CHECK-RV64:       # %bb.0:
-; CHECK-RV64-NEXT:    addi sp, sp, -128
-; CHECK-RV64-NEXT:    sd ra, 120(sp)
-; CHECK-RV64-NEXT:    sd t0, 112(sp)
-; CHECK-RV64-NEXT:    sd t1, 104(sp)
-; CHECK-RV64-NEXT:    sd t2, 96(sp)
-; CHECK-RV64-NEXT:    sd a0, 88(sp)
-; CHECK-RV64-NEXT:    sd a1, 80(sp)
-; CHECK-RV64-NEXT:    sd a2, 72(sp)
-; CHECK-RV64-NEXT:    sd a3, 64(sp)
-; CHECK-RV64-NEXT:    sd a4, 56(sp)
-; CHECK-RV64-NEXT:    sd a5, 48(sp)
-; CHECK-RV64-NEXT:    sd a6, 40(sp)
-; CHECK-RV64-NEXT:    sd a7, 32(sp)
-; CHECK-RV64-NEXT:    sd t3, 24(sp)
-; CHECK-RV64-NEXT:    sd t4, 16(sp)
-; CHECK-RV64-NEXT:    sd t5, 8(sp)
-; CHECK-RV64-NEXT:    sd t6, 0(sp)
-; CHECK-RV64-NEXT:    call otherfoo
-; CHECK-RV64-NEXT:    ld t6, 0(sp)
-; CHECK-RV64-NEXT:    ld t5, 8(sp)
-; CHECK-RV64-NEXT:    ld t4, 16(sp)
-; CHECK-RV64-NEXT:    ld t3, 24(sp)
-; CHECK-RV64-NEXT:    ld a7, 32(sp)
-; CHECK-RV64-NEXT:    ld a6, 40(sp)
-; CHECK-RV64-NEXT:    ld a5, 48(sp)
-; CHECK-RV64-NEXT:    ld a4, 56(sp)
-; CHECK-RV64-NEXT:    ld a3, 64(sp)
-; CHECK-RV64-NEXT:    ld a2, 72(sp)
-; CHECK-RV64-NEXT:    ld a1, 80(sp)
-; CHECK-RV64-NEXT:    ld a0, 88(sp)
-; CHECK-RV64-NEXT:    ld t2, 96(sp)
-; CHECK-RV64-NEXT:    ld t1, 104(sp)
-; CHECK-RV64-NEXT:    ld t0, 112(sp)
-; CHECK-RV64-NEXT:    ld ra, 120(sp)
-; CHECK-RV64-NEXT:    addi sp, sp, 128
-; CHECK-RV64-NEXT:    mret
-;
-; CHECK-RV64-F-LABEL: foo_with_call:
-; CHECK-RV64-F:       # %bb.0:
-; CHECK-RV64-F-NEXT:    addi sp, sp, -256
-; CHECK-RV64-F-NEXT:    sd ra, 248(sp)
-; CHECK-RV64-F-NEXT:    sd t0, 240(sp)
-; CHECK-RV64-F-NEXT:    sd t1, 232(sp)
-; CHECK-RV64-F-NEXT:    sd t2, 224(sp)
-; CHECK-RV64-F-NEXT:    sd a0, 216(sp)
-; CHECK-RV64-F-NEXT:    sd a1, 208(sp)
-; CHECK-RV64-F-NEXT:    sd a2, 200(sp)
-; CHECK-RV64-F-NEXT:    sd a3, 192(sp)
-; CHECK-RV64-F-NEXT:    sd a4, 184(sp)
-; CHECK-RV64-F-NEXT:    sd a5, 176(sp)
-; CHECK-RV64-F-NEXT:    sd a6, 168(sp)
-; CHECK-RV64-F-NEXT:    sd a7, 160(sp)
-; CHECK-RV64-F-NEXT:    sd t3, 152(sp)
-; CHECK-RV64-F-NEXT:    sd t4, 144(sp)
-; CHECK-RV64-F-NEXT:    sd t5, 136(sp)
-; CHECK-RV64-F-NEXT:    sd t6, 128(sp)
-; CHECK-RV64-F-NEXT:    fsw ft0, 124(sp)
-; CHECK-RV64-F-NEXT:    fsw ft1, 120(sp)
-; CHECK-RV64-F-NEXT:    fsw ft2, 116(sp)
-; CHECK-RV64-F-NEXT:    fsw ft3, 112(sp)
-; CHECK-RV64-F-NEXT:    fsw ft4, 108(sp)
-; CHECK-RV64-F-NEXT:    fsw ft5, 104(sp)
-; CHECK-RV64-F-NEXT:    fsw ft6, 100(sp)
-; CHECK-RV64-F-NEXT:    fsw ft7, 96(sp)
-; CHECK-RV64-F-NEXT:    fsw fa0, 92(sp)
-; CHECK-RV64-F-NEXT:    fsw fa1, 88(sp)
-; CHECK-RV64-F-NEXT:    fsw fa2, 84(sp)
-; CHECK-RV64-F-NEXT:    fsw fa3, 80(sp)
-; CHECK-RV64-F-NEXT:    fsw fa4, 76(sp)
-; CHECK-RV64-F-NEXT:    fsw fa5, 72(sp)
-; CHECK-RV64-F-NEXT:    fsw fa6, 68(sp)
-; CHECK-RV64-F-NEXT:    fsw fa7, 64(sp)
-; CHECK-RV64-F-NEXT:    fsw ft8, 60(sp)
-; CHECK-RV64-F-NEXT:    fsw ft9, 56(sp)
-; CHECK-RV64-F-NEXT:    fsw ft10, 52(sp)
-; CHECK-RV64-F-NEXT:    fsw ft11, 48(sp)
-; CHECK-RV64-F-NEXT:    fsw fs0, 44(sp)
-; CHECK-RV64-F-NEXT:    fsw fs1, 40(sp)
-; CHECK-RV64-F-NEXT:    fsw fs2, 36(sp)
-; CHECK-RV64-F-NEXT:    fsw fs3, 32(sp)
-; CHECK-RV64-F-NEXT:    fsw fs4, 28(sp)
-; CHECK-RV64-F-NEXT:    fsw fs5, 24(sp)
-; CHECK-RV64-F-NEXT:    fsw fs6, 20(sp)
-; CHECK-RV64-F-NEXT:    fsw fs7, 16(sp)
-; CHECK-RV64-F-NEXT:    fsw fs8, 12(sp)
-; CHECK-RV64-F-NEXT:    fsw fs9, 8(sp)
-; CHECK-RV64-F-NEXT:    fsw fs10, 4(sp)
-; CHECK-RV64-F-NEXT:    fsw fs11, 0(sp)
-; CHECK-RV64-F-NEXT:    call otherfoo
-; CHECK-RV64-F-NEXT:    flw fs11, 0(sp)
-; CHECK-RV64-F-NEXT:    flw fs10, 4(sp)
-; CHECK-RV64-F-NEXT:    flw fs9, 8(sp)
-; CHECK-RV64-F-NEXT:    flw fs8, 12(sp)
-; CHECK-RV64-F-NEXT:    flw fs7, 16(sp)
-; CHECK-RV64-F-NEXT:    flw fs6, 20(sp)
-; CHECK-RV64-F-NEXT:    flw fs5, 24(sp)
-; CHECK-RV64-F-NEXT:    flw fs4, 28(sp)
-; CHECK-RV64-F-NEXT:    flw fs3, 32(sp)
-; CHECK-RV64-F-NEXT:    flw fs2, 36(sp)
-; CHECK-RV64-F-NEXT:    flw fs1, 40(sp)
-; CHECK-RV64-F-NEXT:    flw fs0, 44(sp)
-; CHECK-RV64-F-NEXT:    flw ft11, 48(sp)
-; CHECK-RV64-F-NEXT:    flw ft10, 52(sp)
-; CHECK-RV64-F-NEXT:    flw ft9, 56(sp)
-; CHECK-RV64-F-NEXT:    flw ft8, 60(sp)
-; CHECK-RV64-F-NEXT:    flw fa7, 64(sp)
-; CHECK-RV64-F-NEXT:    flw fa6, 68(sp)
-; CHECK-RV64-F-NEXT:    flw fa5, 72(sp)
-; CHECK-RV64-F-NEXT:    flw fa4, 76(sp)
-; CHECK-RV64-F-NEXT:    flw fa3, 80(sp)
-; CHECK-RV64-F-NEXT:    flw fa2, 84(sp)
-; CHECK-RV64-F-NEXT:    flw fa1, 88(sp)
-; CHECK-RV64-F-NEXT:    flw fa0, 92(sp)
-; CHECK-RV64-F-NEXT:    flw ft7, 96(sp)
-; CHECK-RV64-F-NEXT:    flw ft6, 100(sp)
-; CHECK-RV64-F-NEXT:    flw ft5, 104(sp)
-; CHECK-RV64-F-NEXT:    flw ft4, 108(sp)
-; CHECK-RV64-F-NEXT:    flw ft3, 112(sp)
-; CHECK-RV64-F-NEXT:    flw ft2, 116(sp)
-; CHECK-RV64-F-NEXT:    flw ft1, 120(sp)
-; CHECK-RV64-F-NEXT:    flw ft0, 124(sp)
-; CHECK-RV64-F-NEXT:    ld t6, 128(sp)
-; CHECK-RV64-F-NEXT:    ld t5, 136(sp)
-; CHECK-RV64-F-NEXT:    ld t4, 144(sp)
-; CHECK-RV64-F-NEXT:    ld t3, 152(sp)
-; CHECK-RV64-F-NEXT:    ld a7, 160(sp)
-; CHECK-RV64-F-NEXT:    ld a6, 168(sp)
-; CHECK-RV64-F-NEXT:    ld a5, 176(sp)
-; CHECK-RV64-F-NEXT:    ld a4, 184(sp)
-; CHECK-RV64-F-NEXT:    ld a3, 192(sp)
-; CHECK-RV64-F-NEXT:    ld a2, 200(sp)
-; CHECK-RV64-F-NEXT:    ld a1, 208(sp)
-; CHECK-RV64-F-NEXT:    ld a0, 216(sp)
-; CHECK-RV64-F-NEXT:    ld t2, 224(sp)
-; CHECK-RV64-F-NEXT:    ld t1, 232(sp)
-; CHECK-RV64-F-NEXT:    ld t0, 240(sp)
-; CHECK-RV64-F-NEXT:    ld ra, 248(sp)
-; CHECK-RV64-F-NEXT:    addi sp, sp, 256
-; CHECK-RV64-F-NEXT:    mret
-;
-; CHECK-RV64-FD-LABEL: foo_with_call:
-; CHECK-RV64-FD:       # %bb.0:
-; CHECK-RV64-FD-NEXT:    addi sp, sp, -384
-; CHECK-RV64-FD-NEXT:    sd ra, 376(sp)
-; CHECK-RV64-FD-NEXT:    sd t0, 368(sp)
-; CHECK-RV64-FD-NEXT:    sd t1, 360(sp)
-; CHECK-RV64-FD-NEXT:    sd t2, 352(sp)
-; CHECK-RV64-FD-NEXT:    sd a0, 344(sp)
-; CHECK-RV64-FD-NEXT:    sd a1, 336(sp)
-; CHECK-RV64-FD-NEXT:    sd a2, 328(sp)
-; CHECK-RV64-FD-NEXT:    sd a3, 320(sp)
-; CHECK-RV64-FD-NEXT:    sd a4, 312(sp)
-; CHECK-RV64-FD-NEXT:    sd a5, 304(sp)
-; CHECK-RV64-FD-NEXT:    sd a6, 296(sp)
-; CHECK-RV64-FD-NEXT:    sd a7, 288(sp)
-; CHECK-RV64-FD-NEXT:    sd t3, 280(sp)
-; CHECK-RV64-FD-NEXT:    sd t4, 272(sp)
-; CHECK-RV64-FD-NEXT:    sd t5, 264(sp)
-; CHECK-RV64-FD-NEXT:    sd t6, 256(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft0, 248(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft1, 240(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft2, 232(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft3, 224(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft4, 216(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft5, 208(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft6, 200(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft7, 192(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa0, 184(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa1, 176(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa2, 168(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa3, 160(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa4, 152(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa5, 144(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa6, 136(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa7, 128(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft8, 120(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft9, 112(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft10, 104(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft11, 96(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs0, 88(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs1, 80(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs2, 72(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs3, 64(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs4, 56(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs5, 48(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs6, 40(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs7, 32(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs8, 24(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs9, 16(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs10, 8(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs11, 0(sp)
-; CHECK-RV64-FD-NEXT:    call otherfoo
-; CHECK-RV64-FD-NEXT:    fld fs11, 0(sp)
-; CHECK-RV64-FD-NEXT:    fld fs10, 8(sp)
-; CHECK-RV64-FD-NEXT:    fld fs9, 16(sp)
-; CHECK-RV64-FD-NEXT:    fld fs8, 24(sp)
-; CHECK-RV64-FD-NEXT:    fld fs7, 32(sp)
-; CHECK-RV64-FD-NEXT:    fld fs6, 40(sp)
-; CHECK-RV64-FD-NEXT:    fld fs5, 48(sp)
-; CHECK-RV64-FD-NEXT:    fld fs4, 56(sp)
-; CHECK-RV64-FD-NEXT:    fld fs3, 64(sp)
-; CHECK-RV64-FD-NEXT:    fld fs2, 72(sp)
-; CHECK-RV64-FD-NEXT:    fld fs1, 80(sp)
-; CHECK-RV64-FD-NEXT:    fld fs0, 88(sp)
-; CHECK-RV64-FD-NEXT:    fld ft11, 96(sp)
-; CHECK-RV64-FD-NEXT:    fld ft10, 104(sp)
-; CHECK-RV64-FD-NEXT:    fld ft9, 112(sp)
-; CHECK-RV64-FD-NEXT:    fld ft8, 120(sp)
-; CHECK-RV64-FD-NEXT:    fld fa7, 128(sp)
-; CHECK-RV64-FD-NEXT:    fld fa6, 136(sp)
-; CHECK-RV64-FD-NEXT:    fld fa5, 144(sp)
-; CHECK-RV64-FD-NEXT:    fld fa4, 152(sp)
-; CHECK-RV64-FD-NEXT:    fld fa3, 160(sp)
-; CHECK-RV64-FD-NEXT:    fld fa2, 168(sp)
-; CHECK-RV64-FD-NEXT:    fld fa1, 176(sp)
-; CHECK-RV64-FD-NEXT:    fld fa0, 184(sp)
-; CHECK-RV64-FD-NEXT:    fld ft7, 192(sp)
-; CHECK-RV64-FD-NEXT:    fld ft6, 200(sp)
-; CHECK-RV64-FD-NEXT:    fld ft5, 208(sp)
-; CHECK-RV64-FD-NEXT:    fld ft4, 216(sp)
-; CHECK-RV64-FD-NEXT:    fld ft3, 224(sp)
-; CHECK-RV64-FD-NEXT:    fld ft2, 232(sp)
-; CHECK-RV64-FD-NEXT:    fld ft1, 240(sp)
-; CHECK-RV64-FD-NEXT:    fld ft0, 248(sp)
-; CHECK-RV64-FD-NEXT:    ld t6, 256(sp)
-; CHECK-RV64-FD-NEXT:    ld t5, 264(sp)
-; CHECK-RV64-FD-NEXT:    ld t4, 272(sp)
-; CHECK-RV64-FD-NEXT:    ld t3, 280(sp)
-; CHECK-RV64-FD-NEXT:    ld a7, 288(sp)
-; CHECK-RV64-FD-NEXT:    ld a6, 296(sp)
-; CHECK-RV64-FD-NEXT:    ld a5, 304(sp)
-; CHECK-RV64-FD-NEXT:    ld a4, 312(sp)
-; CHECK-RV64-FD-NEXT:    ld a3, 320(sp)
-; CHECK-RV64-FD-NEXT:    ld a2, 328(sp)
-; CHECK-RV64-FD-NEXT:    ld a1, 336(sp)
-; CHECK-RV64-FD-NEXT:    ld a0, 344(sp)
-; CHECK-RV64-FD-NEXT:    ld t2, 352(sp)
-; CHECK-RV64-FD-NEXT:    ld t1, 360(sp)
-; CHECK-RV64-FD-NEXT:    ld t0, 368(sp)
-; CHECK-RV64-FD-NEXT:    ld ra, 376(sp)
-; CHECK-RV64-FD-NEXT:    addi sp, sp, 384
-; CHECK-RV64-FD-NEXT:    mret
-  %call = call i32 bitcast (i32 (...)* @otherfoo to i32 ()*)()
-  ret void
-}
-
-;
-; Additionally check frame pointer and return address are properly saved.
-;
-define void @foo_fp_with_call() #3 {
-;
-; CHECK-RV32-LABEL: foo_fp_with_call:
-; CHECK-RV32:       # %bb.0:
-; CHECK-RV32-NEXT:    addi sp, sp, -80
-; CHECK-RV32-NEXT:    sw ra, 76(sp)
-; CHECK-RV32-NEXT:    sw t0, 72(sp)
-; CHECK-RV32-NEXT:    sw t1, 68(sp)
-; CHECK-RV32-NEXT:    sw t2, 64(sp)
-; CHECK-RV32-NEXT:    sw s0, 60(sp)
-; CHECK-RV32-NEXT:    sw a0, 56(sp)
-; CHECK-RV32-NEXT:    sw a1, 52(sp)
-; CHECK-RV32-NEXT:    sw a2, 48(sp)
-; CHECK-RV32-NEXT:    sw a3, 44(sp)
-; CHECK-RV32-NEXT:    sw a4, 40(sp)
-; CHECK-RV32-NEXT:    sw a5, 36(sp)
-; CHECK-RV32-NEXT:    sw a6, 32(sp)
-; CHECK-RV32-NEXT:    sw a7, 28(sp)
-; CHECK-RV32-NEXT:    sw t3, 24(sp)
-; CHECK-RV32-NEXT:    sw t4, 20(sp)
-; CHECK-RV32-NEXT:    sw t5, 16(sp)
-; CHECK-RV32-NEXT:    sw t6, 12(sp)
-; CHECK-RV32-NEXT:    addi s0, sp, 80
-; CHECK-RV32-NEXT:    call otherfoo
-; CHECK-RV32-NEXT:    lw t6, 12(sp)
-; CHECK-RV32-NEXT:    lw t5, 16(sp)
-; CHECK-RV32-NEXT:    lw t4, 20(sp)
-; CHECK-RV32-NEXT:    lw t3, 24(sp)
-; CHECK-RV32-NEXT:    lw a7, 28(sp)
-; CHECK-RV32-NEXT:    lw a6, 32(sp)
-; CHECK-RV32-NEXT:    lw a5, 36(sp)
-; CHECK-RV32-NEXT:    lw a4, 40(sp)
-; CHECK-RV32-NEXT:    lw a3, 44(sp)
-; CHECK-RV32-NEXT:    lw a2, 48(sp)
-; CHECK-RV32-NEXT:    lw a1, 52(sp)
-; CHECK-RV32-NEXT:    lw a0, 56(sp)
-; CHECK-RV32-NEXT:    lw s0, 60(sp)
-; CHECK-RV32-NEXT:    lw t2, 64(sp)
-; CHECK-RV32-NEXT:    lw t1, 68(sp)
-; CHECK-RV32-NEXT:    lw t0, 72(sp)
-; CHECK-RV32-NEXT:    lw ra, 76(sp)
-; CHECK-RV32-NEXT:    addi sp, sp, 80
-; CHECK-RV32-NEXT:    mret
-;
-; CHECK-RV32-F-LABEL: foo_fp_with_call:
-; CHECK-RV32-F:       # %bb.0:
-; CHECK-RV32-F-NEXT:    addi sp, sp, -208
-; CHECK-RV32-F-NEXT:    sw ra, 204(sp)
-; CHECK-RV32-F-NEXT:    sw t0, 200(sp)
-; CHECK-RV32-F-NEXT:    sw t1, 196(sp)
-; CHECK-RV32-F-NEXT:    sw t2, 192(sp)
-; CHECK-RV32-F-NEXT:    sw s0, 188(sp)
-; CHECK-RV32-F-NEXT:    sw a0, 184(sp)
-; CHECK-RV32-F-NEXT:    sw a1, 180(sp)
-; CHECK-RV32-F-NEXT:    sw a2, 176(sp)
-; CHECK-RV32-F-NEXT:    sw a3, 172(sp)
-; CHECK-RV32-F-NEXT:    sw a4, 168(sp)
-; CHECK-RV32-F-NEXT:    sw a5, 164(sp)
-; CHECK-RV32-F-NEXT:    sw a6, 160(sp)
-; CHECK-RV32-F-NEXT:    sw a7, 156(sp)
-; CHECK-RV32-F-NEXT:    sw t3, 152(sp)
-; CHECK-RV32-F-NEXT:    sw t4, 148(sp)
-; CHECK-RV32-F-NEXT:    sw t5, 144(sp)
-; CHECK-RV32-F-NEXT:    sw t6, 140(sp)
-; CHECK-RV32-F-NEXT:    fsw ft0, 136(sp)
-; CHECK-RV32-F-NEXT:    fsw ft1, 132(sp)
-; CHECK-RV32-F-NEXT:    fsw ft2, 128(sp)
-; CHECK-RV32-F-NEXT:    fsw ft3, 124(sp)
-; CHECK-RV32-F-NEXT:    fsw ft4, 120(sp)
-; CHECK-RV32-F-NEXT:    fsw ft5, 116(sp)
-; CHECK-RV32-F-NEXT:    fsw ft6, 112(sp)
-; CHECK-RV32-F-NEXT:    fsw ft7, 108(sp)
-; CHECK-RV32-F-NEXT:    fsw fa0, 104(sp)
-; CHECK-RV32-F-NEXT:    fsw fa1, 100(sp)
-; CHECK-RV32-F-NEXT:    fsw fa2, 96(sp)
-; CHECK-RV32-F-NEXT:    fsw fa3, 92(sp)
-; CHECK-RV32-F-NEXT:    fsw fa4, 88(sp)
-; CHECK-RV32-F-NEXT:    fsw fa5, 84(sp)
-; CHECK-RV32-F-NEXT:    fsw fa6, 80(sp)
-; CHECK-RV32-F-NEXT:    fsw fa7, 76(sp)
-; CHECK-RV32-F-NEXT:    fsw ft8, 72(sp)
-; CHECK-RV32-F-NEXT:    fsw ft9, 68(sp)
-; CHECK-RV32-F-NEXT:    fsw ft10, 64(sp)
-; CHECK-RV32-F-NEXT:    fsw ft11, 60(sp)
-; CHECK-RV32-F-NEXT:    fsw fs0, 56(sp)
-; CHECK-RV32-F-NEXT:    fsw fs1, 52(sp)
-; CHECK-RV32-F-NEXT:    fsw fs2, 48(sp)
-; CHECK-RV32-F-NEXT:    fsw fs3, 44(sp)
-; CHECK-RV32-F-NEXT:    fsw fs4, 40(sp)
-; CHECK-RV32-F-NEXT:    fsw fs5, 36(sp)
-; CHECK-RV32-F-NEXT:    fsw fs6, 32(sp)
-; CHECK-RV32-F-NEXT:    fsw fs7, 28(sp)
-; CHECK-RV32-F-NEXT:    fsw fs8, 24(sp)
-; CHECK-RV32-F-NEXT:    fsw fs9, 20(sp)
-; CHECK-RV32-F-NEXT:    fsw fs10, 16(sp)
-; CHECK-RV32-F-NEXT:    fsw fs11, 12(sp)
-; CHECK-RV32-F-NEXT:    addi s0, sp, 208
-; CHECK-RV32-F-NEXT:    call otherfoo
-; CHECK-RV32-F-NEXT:    flw fs11, 12(sp)
-; CHECK-RV32-F-NEXT:    flw fs10, 16(sp)
-; CHECK-RV32-F-NEXT:    flw fs9, 20(sp)
-; CHECK-RV32-F-NEXT:    flw fs8, 24(sp)
-; CHECK-RV32-F-NEXT:    flw fs7, 28(sp)
-; CHECK-RV32-F-NEXT:    flw fs6, 32(sp)
-; CHECK-RV32-F-NEXT:    flw fs5, 36(sp)
-; CHECK-RV32-F-NEXT:    flw fs4, 40(sp)
-; CHECK-RV32-F-NEXT:    flw fs3, 44(sp)
-; CHECK-RV32-F-NEXT:    flw fs2, 48(sp)
-; CHECK-RV32-F-NEXT:    flw fs1, 52(sp)
-; CHECK-RV32-F-NEXT:    flw fs0, 56(sp)
-; CHECK-RV32-F-NEXT:    flw ft11, 60(sp)
-; CHECK-RV32-F-NEXT:    flw ft10, 64(sp)
-; CHECK-RV32-F-NEXT:    flw ft9, 68(sp)
-; CHECK-RV32-F-NEXT:    flw ft8, 72(sp)
-; CHECK-RV32-F-NEXT:    flw fa7, 76(sp)
-; CHECK-RV32-F-NEXT:    flw fa6, 80(sp)
-; CHECK-RV32-F-NEXT:    flw fa5, 84(sp)
-; CHECK-RV32-F-NEXT:    flw fa4, 88(sp)
-; CHECK-RV32-F-NEXT:    flw fa3, 92(sp)
-; CHECK-RV32-F-NEXT:    flw fa2, 96(sp)
-; CHECK-RV32-F-NEXT:    flw fa1, 100(sp)
-; CHECK-RV32-F-NEXT:    flw fa0, 104(sp)
-; CHECK-RV32-F-NEXT:    flw ft7, 108(sp)
-; CHECK-RV32-F-NEXT:    flw ft6, 112(sp)
-; CHECK-RV32-F-NEXT:    flw ft5, 116(sp)
-; CHECK-RV32-F-NEXT:    flw ft4, 120(sp)
-; CHECK-RV32-F-NEXT:    flw ft3, 124(sp)
-; CHECK-RV32-F-NEXT:    flw ft2, 128(sp)
-; CHECK-RV32-F-NEXT:    flw ft1, 132(sp)
-; CHECK-RV32-F-NEXT:    flw ft0, 136(sp)
-; CHECK-RV32-F-NEXT:    lw t6, 140(sp)
-; CHECK-RV32-F-NEXT:    lw t5, 144(sp)
-; CHECK-RV32-F-NEXT:    lw t4, 148(sp)
-; CHECK-RV32-F-NEXT:    lw t3, 152(sp)
-; CHECK-RV32-F-NEXT:    lw a7, 156(sp)
-; CHECK-RV32-F-NEXT:    lw a6, 160(sp)
-; CHECK-RV32-F-NEXT:    lw a5, 164(sp)
-; CHECK-RV32-F-NEXT:    lw a4, 168(sp)
-; CHECK-RV32-F-NEXT:    lw a3, 172(sp)
-; CHECK-RV32-F-NEXT:    lw a2, 176(sp)
-; CHECK-RV32-F-NEXT:    lw a1, 180(sp)
-; CHECK-RV32-F-NEXT:    lw a0, 184(sp)
-; CHECK-RV32-F-NEXT:    lw s0, 188(sp)
-; CHECK-RV32-F-NEXT:    lw t2, 192(sp)
-; CHECK-RV32-F-NEXT:    lw t1, 196(sp)
-; CHECK-RV32-F-NEXT:    lw t0, 200(sp)
-; CHECK-RV32-F-NEXT:    lw ra, 204(sp)
-; CHECK-RV32-F-NEXT:    addi sp, sp, 208
-; CHECK-RV32-F-NEXT:    mret
-;
-; CHECK-RV32-FD-LABEL: foo_fp_with_call:
-; CHECK-RV32-FD:       # %bb.0:
-; CHECK-RV32-FD-NEXT:    addi sp, sp, -336
-; CHECK-RV32-FD-NEXT:    sw ra, 332(sp)
-; CHECK-RV32-FD-NEXT:    sw t0, 328(sp)
-; CHECK-RV32-FD-NEXT:    sw t1, 324(sp)
-; CHECK-RV32-FD-NEXT:    sw t2, 320(sp)
-; CHECK-RV32-FD-NEXT:    sw s0, 316(sp)
-; CHECK-RV32-FD-NEXT:    sw a0, 312(sp)
-; CHECK-RV32-FD-NEXT:    sw a1, 308(sp)
-; CHECK-RV32-FD-NEXT:    sw a2, 304(sp)
-; CHECK-RV32-FD-NEXT:    sw a3, 300(sp)
-; CHECK-RV32-FD-NEXT:    sw a4, 296(sp)
-; CHECK-RV32-FD-NEXT:    sw a5, 292(sp)
-; CHECK-RV32-FD-NEXT:    sw a6, 288(sp)
-; CHECK-RV32-FD-NEXT:    sw a7, 284(sp)
-; CHECK-RV32-FD-NEXT:    sw t3, 280(sp)
-; CHECK-RV32-FD-NEXT:    sw t4, 276(sp)
-; CHECK-RV32-FD-NEXT:    sw t5, 272(sp)
-; CHECK-RV32-FD-NEXT:    sw t6, 268(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft0, 256(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft1, 248(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft2, 240(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft3, 232(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft4, 224(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft5, 216(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft6, 208(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft7, 200(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa0, 192(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa1, 184(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa2, 176(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa3, 168(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa4, 160(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa5, 152(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa6, 144(sp)
-; CHECK-RV32-FD-NEXT:    fsd fa7, 136(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft8, 128(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft9, 120(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft10, 112(sp)
-; CHECK-RV32-FD-NEXT:    fsd ft11, 104(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs0, 96(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs1, 88(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs2, 80(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs3, 72(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs4, 64(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs5, 56(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs6, 48(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs7, 40(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs8, 32(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs9, 24(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs10, 16(sp)
-; CHECK-RV32-FD-NEXT:    fsd fs11, 8(sp)
-; CHECK-RV32-FD-NEXT:    addi s0, sp, 336
-; CHECK-RV32-FD-NEXT:    call otherfoo
-; CHECK-RV32-FD-NEXT:    fld fs11, 8(sp)
-; CHECK-RV32-FD-NEXT:    fld fs10, 16(sp)
-; CHECK-RV32-FD-NEXT:    fld fs9, 24(sp)
-; CHECK-RV32-FD-NEXT:    fld fs8, 32(sp)
-; CHECK-RV32-FD-NEXT:    fld fs7, 40(sp)
-; CHECK-RV32-FD-NEXT:    fld fs6, 48(sp)
-; CHECK-RV32-FD-NEXT:    fld fs5, 56(sp)
-; CHECK-RV32-FD-NEXT:    fld fs4, 64(sp)
-; CHECK-RV32-FD-NEXT:    fld fs3, 72(sp)
-; CHECK-RV32-FD-NEXT:    fld fs2, 80(sp)
-; CHECK-RV32-FD-NEXT:    fld fs1, 88(sp)
-; CHECK-RV32-FD-NEXT:    fld fs0, 96(sp)
-; CHECK-RV32-FD-NEXT:    fld ft11, 104(sp)
-; CHECK-RV32-FD-NEXT:    fld ft10, 112(sp)
-; CHECK-RV32-FD-NEXT:    fld ft9, 120(sp)
-; CHECK-RV32-FD-NEXT:    fld ft8, 128(sp)
-; CHECK-RV32-FD-NEXT:    fld fa7, 136(sp)
-; CHECK-RV32-FD-NEXT:    fld fa6, 144(sp)
-; CHECK-RV32-FD-NEXT:    fld fa5, 152(sp)
-; CHECK-RV32-FD-NEXT:    fld fa4, 160(sp)
-; CHECK-RV32-FD-NEXT:    fld fa3, 168(sp)
-; CHECK-RV32-FD-NEXT:    fld fa2, 176(sp)
-; CHECK-RV32-FD-NEXT:    fld fa1, 184(sp)
-; CHECK-RV32-FD-NEXT:    fld fa0, 192(sp)
-; CHECK-RV32-FD-NEXT:    fld ft7, 200(sp)
-; CHECK-RV32-FD-NEXT:    fld ft6, 208(sp)
-; CHECK-RV32-FD-NEXT:    fld ft5, 216(sp)
-; CHECK-RV32-FD-NEXT:    fld ft4, 224(sp)
-; CHECK-RV32-FD-NEXT:    fld ft3, 232(sp)
-; CHECK-RV32-FD-NEXT:    fld ft2, 240(sp)
-; CHECK-RV32-FD-NEXT:    fld ft1, 248(sp)
-; CHECK-RV32-FD-NEXT:    fld ft0, 256(sp)
-; CHECK-RV32-FD-NEXT:    lw t6, 268(sp)
-; CHECK-RV32-FD-NEXT:    lw t5, 272(sp)
-; CHECK-RV32-FD-NEXT:    lw t4, 276(sp)
-; CHECK-RV32-FD-NEXT:    lw t3, 280(sp)
-; CHECK-RV32-FD-NEXT:    lw a7, 284(sp)
-; CHECK-RV32-FD-NEXT:    lw a6, 288(sp)
-; CHECK-RV32-FD-NEXT:    lw a5, 292(sp)
-; CHECK-RV32-FD-NEXT:    lw a4, 296(sp)
-; CHECK-RV32-FD-NEXT:    lw a3, 300(sp)
-; CHECK-RV32-FD-NEXT:    lw a2, 304(sp)
-; CHECK-RV32-FD-NEXT:    lw a1, 308(sp)
-; CHECK-RV32-FD-NEXT:    lw a0, 312(sp)
-; CHECK-RV32-FD-NEXT:    lw s0, 316(sp)
-; CHECK-RV32-FD-NEXT:    lw t2, 320(sp)
-; CHECK-RV32-FD-NEXT:    lw t1, 324(sp)
-; CHECK-RV32-FD-NEXT:    lw t0, 328(sp)
-; CHECK-RV32-FD-NEXT:    lw ra, 332(sp)
-; CHECK-RV32-FD-NEXT:    addi sp, sp, 336
-; CHECK-RV32-FD-NEXT:    mret
-;
-; CHECK-RV64-LABEL: foo_fp_with_call:
-; CHECK-RV64:       # %bb.0:
-; CHECK-RV64-NEXT:    addi sp, sp, -144
-; CHECK-RV64-NEXT:    sd ra, 136(sp)
-; CHECK-RV64-NEXT:    sd t0, 128(sp)
-; CHECK-RV64-NEXT:    sd t1, 120(sp)
-; CHECK-RV64-NEXT:    sd t2, 112(sp)
-; CHECK-RV64-NEXT:    sd s0, 104(sp)
-; CHECK-RV64-NEXT:    sd a0, 96(sp)
-; CHECK-RV64-NEXT:    sd a1, 88(sp)
-; CHECK-RV64-NEXT:    sd a2, 80(sp)
-; CHECK-RV64-NEXT:    sd a3, 72(sp)
-; CHECK-RV64-NEXT:    sd a4, 64(sp)
-; CHECK-RV64-NEXT:    sd a5, 56(sp)
-; CHECK-RV64-NEXT:    sd a6, 48(sp)
-; CHECK-RV64-NEXT:    sd a7, 40(sp)
-; CHECK-RV64-NEXT:    sd t3, 32(sp)
-; CHECK-RV64-NEXT:    sd t4, 24(sp)
-; CHECK-RV64-NEXT:    sd t5, 16(sp)
-; CHECK-RV64-NEXT:    sd t6, 8(sp)
-; CHECK-RV64-NEXT:    addi s0, sp, 144
-; CHECK-RV64-NEXT:    call otherfoo
-; CHECK-RV64-NEXT:    ld t6, 8(sp)
-; CHECK-RV64-NEXT:    ld t5, 16(sp)
-; CHECK-RV64-NEXT:    ld t4, 24(sp)
-; CHECK-RV64-NEXT:    ld t3, 32(sp)
-; CHECK-RV64-NEXT:    ld a7, 40(sp)
-; CHECK-RV64-NEXT:    ld a6, 48(sp)
-; CHECK-RV64-NEXT:    ld a5, 56(sp)
-; CHECK-RV64-NEXT:    ld a4, 64(sp)
-; CHECK-RV64-NEXT:    ld a3, 72(sp)
-; CHECK-RV64-NEXT:    ld a2, 80(sp)
-; CHECK-RV64-NEXT:    ld a1, 88(sp)
-; CHECK-RV64-NEXT:    ld a0, 96(sp)
-; CHECK-RV64-NEXT:    ld s0, 104(sp)
-; CHECK-RV64-NEXT:    ld t2, 112(sp)
-; CHECK-RV64-NEXT:    ld t1, 120(sp)
-; CHECK-RV64-NEXT:    ld t0, 128(sp)
-; CHECK-RV64-NEXT:    ld ra, 136(sp)
-; CHECK-RV64-NEXT:    addi sp, sp, 144
-; CHECK-RV64-NEXT:    mret
-;
-; CHECK-RV64-F-LABEL: foo_fp_with_call:
-; CHECK-RV64-F:       # %bb.0:
-; CHECK-RV64-F-NEXT:    addi sp, sp, -272
-; CHECK-RV64-F-NEXT:    sd ra, 264(sp)
-; CHECK-RV64-F-NEXT:    sd t0, 256(sp)
-; CHECK-RV64-F-NEXT:    sd t1, 248(sp)
-; CHECK-RV64-F-NEXT:    sd t2, 240(sp)
-; CHECK-RV64-F-NEXT:    sd s0, 232(sp)
-; CHECK-RV64-F-NEXT:    sd a0, 224(sp)
-; CHECK-RV64-F-NEXT:    sd a1, 216(sp)
-; CHECK-RV64-F-NEXT:    sd a2, 208(sp)
-; CHECK-RV64-F-NEXT:    sd a3, 200(sp)
-; CHECK-RV64-F-NEXT:    sd a4, 192(sp)
-; CHECK-RV64-F-NEXT:    sd a5, 184(sp)
-; CHECK-RV64-F-NEXT:    sd a6, 176(sp)
-; CHECK-RV64-F-NEXT:    sd a7, 168(sp)
-; CHECK-RV64-F-NEXT:    sd t3, 160(sp)
-; CHECK-RV64-F-NEXT:    sd t4, 152(sp)
-; CHECK-RV64-F-NEXT:    sd t5, 144(sp)
-; CHECK-RV64-F-NEXT:    sd t6, 136(sp)
-; CHECK-RV64-F-NEXT:    fsw ft0, 132(sp)
-; CHECK-RV64-F-NEXT:    fsw ft1, 128(sp)
-; CHECK-RV64-F-NEXT:    fsw ft2, 124(sp)
-; CHECK-RV64-F-NEXT:    fsw ft3, 120(sp)
-; CHECK-RV64-F-NEXT:    fsw ft4, 116(sp)
-; CHECK-RV64-F-NEXT:    fsw ft5, 112(sp)
-; CHECK-RV64-F-NEXT:    fsw ft6, 108(sp)
-; CHECK-RV64-F-NEXT:    fsw ft7, 104(sp)
-; CHECK-RV64-F-NEXT:    fsw fa0, 100(sp)
-; CHECK-RV64-F-NEXT:    fsw fa1, 96(sp)
-; CHECK-RV64-F-NEXT:    fsw fa2, 92(sp)
-; CHECK-RV64-F-NEXT:    fsw fa3, 88(sp)
-; CHECK-RV64-F-NEXT:    fsw fa4, 84(sp)
-; CHECK-RV64-F-NEXT:    fsw fa5, 80(sp)
-; CHECK-RV64-F-NEXT:    fsw fa6, 76(sp)
-; CHECK-RV64-F-NEXT:    fsw fa7, 72(sp)
-; CHECK-RV64-F-NEXT:    fsw ft8, 68(sp)
-; CHECK-RV64-F-NEXT:    fsw ft9, 64(sp)
-; CHECK-RV64-F-NEXT:    fsw ft10, 60(sp)
-; CHECK-RV64-F-NEXT:    fsw ft11, 56(sp)
-; CHECK-RV64-F-NEXT:    fsw fs0, 52(sp)
-; CHECK-RV64-F-NEXT:    fsw fs1, 48(sp)
-; CHECK-RV64-F-NEXT:    fsw fs2, 44(sp)
-; CHECK-RV64-F-NEXT:    fsw fs3, 40(sp)
-; CHECK-RV64-F-NEXT:    fsw fs4, 36(sp)
-; CHECK-RV64-F-NEXT:    fsw fs5, 32(sp)
-; CHECK-RV64-F-NEXT:    fsw fs6, 28(sp)
-; CHECK-RV64-F-NEXT:    fsw fs7, 24(sp)
-; CHECK-RV64-F-NEXT:    fsw fs8, 20(sp)
-; CHECK-RV64-F-NEXT:    fsw fs9, 16(sp)
-; CHECK-RV64-F-NEXT:    fsw fs10, 12(sp)
-; CHECK-RV64-F-NEXT:    fsw fs11, 8(sp)
-; CHECK-RV64-F-NEXT:    addi s0, sp, 272
-; CHECK-RV64-F-NEXT:    call otherfoo
-; CHECK-RV64-F-NEXT:    flw fs11, 8(sp)
-; CHECK-RV64-F-NEXT:    flw fs10, 12(sp)
-; CHECK-RV64-F-NEXT:    flw fs9, 16(sp)
-; CHECK-RV64-F-NEXT:    flw fs8, 20(sp)
-; CHECK-RV64-F-NEXT:    flw fs7, 24(sp)
-; CHECK-RV64-F-NEXT:    flw fs6, 28(sp)
-; CHECK-RV64-F-NEXT:    flw fs5, 32(sp)
-; CHECK-RV64-F-NEXT:    flw fs4, 36(sp)
-; CHECK-RV64-F-NEXT:    flw fs3, 40(sp)
-; CHECK-RV64-F-NEXT:    flw fs2, 44(sp)
-; CHECK-RV64-F-NEXT:    flw fs1, 48(sp)
-; CHECK-RV64-F-NEXT:    flw fs0, 52(sp)
-; CHECK-RV64-F-NEXT:    flw ft11, 56(sp)
-; CHECK-RV64-F-NEXT:    flw ft10, 60(sp)
-; CHECK-RV64-F-NEXT:    flw ft9, 64(sp)
-; CHECK-RV64-F-NEXT:    flw ft8, 68(sp)
-; CHECK-RV64-F-NEXT:    flw fa7, 72(sp)
-; CHECK-RV64-F-NEXT:    flw fa6, 76(sp)
-; CHECK-RV64-F-NEXT:    flw fa5, 80(sp)
-; CHECK-RV64-F-NEXT:    flw fa4, 84(sp)
-; CHECK-RV64-F-NEXT:    flw fa3, 88(sp)
-; CHECK-RV64-F-NEXT:    flw fa2, 92(sp)
-; CHECK-RV64-F-NEXT:    flw fa1, 96(sp)
-; CHECK-RV64-F-NEXT:    flw fa0, 100(sp)
-; CHECK-RV64-F-NEXT:    flw ft7, 104(sp)
-; CHECK-RV64-F-NEXT:    flw ft6, 108(sp)
-; CHECK-RV64-F-NEXT:    flw ft5, 112(sp)
-; CHECK-RV64-F-NEXT:    flw ft4, 116(sp)
-; CHECK-RV64-F-NEXT:    flw ft3, 120(sp)
-; CHECK-RV64-F-NEXT:    flw ft2, 124(sp)
-; CHECK-RV64-F-NEXT:    flw ft1, 128(sp)
-; CHECK-RV64-F-NEXT:    flw ft0, 132(sp)
-; CHECK-RV64-F-NEXT:    ld t6, 136(sp)
-; CHECK-RV64-F-NEXT:    ld t5, 144(sp)
-; CHECK-RV64-F-NEXT:    ld t4, 152(sp)
-; CHECK-RV64-F-NEXT:    ld t3, 160(sp)
-; CHECK-RV64-F-NEXT:    ld a7, 168(sp)
-; CHECK-RV64-F-NEXT:    ld a6, 176(sp)
-; CHECK-RV64-F-NEXT:    ld a5, 184(sp)
-; CHECK-RV64-F-NEXT:    ld a4, 192(sp)
-; CHECK-RV64-F-NEXT:    ld a3, 200(sp)
-; CHECK-RV64-F-NEXT:    ld a2, 208(sp)
-; CHECK-RV64-F-NEXT:    ld a1, 216(sp)
-; CHECK-RV64-F-NEXT:    ld a0, 224(sp)
-; CHECK-RV64-F-NEXT:    ld s0, 232(sp)
-; CHECK-RV64-F-NEXT:    ld t2, 240(sp)
-; CHECK-RV64-F-NEXT:    ld t1, 248(sp)
-; CHECK-RV64-F-NEXT:    ld t0, 256(sp)
-; CHECK-RV64-F-NEXT:    ld ra, 264(sp)
-; CHECK-RV64-F-NEXT:    addi sp, sp, 272
-; CHECK-RV64-F-NEXT:    mret
-;
-; CHECK-RV64-FD-LABEL: foo_fp_with_call:
-; CHECK-RV64-FD:       # %bb.0:
-; CHECK-RV64-FD-NEXT:    addi sp, sp, -400
-; CHECK-RV64-FD-NEXT:    sd ra, 392(sp)
-; CHECK-RV64-FD-NEXT:    sd t0, 384(sp)
-; CHECK-RV64-FD-NEXT:    sd t1, 376(sp)
-; CHECK-RV64-FD-NEXT:    sd t2, 368(sp)
-; CHECK-RV64-FD-NEXT:    sd s0, 360(sp)
-; CHECK-RV64-FD-NEXT:    sd a0, 352(sp)
-; CHECK-RV64-FD-NEXT:    sd a1, 344(sp)
-; CHECK-RV64-FD-NEXT:    sd a2, 336(sp)
-; CHECK-RV64-FD-NEXT:    sd a3, 328(sp)
-; CHECK-RV64-FD-NEXT:    sd a4, 320(sp)
-; CHECK-RV64-FD-NEXT:    sd a5, 312(sp)
-; CHECK-RV64-FD-NEXT:    sd a6, 304(sp)
-; CHECK-RV64-FD-NEXT:    sd a7, 296(sp)
-; CHECK-RV64-FD-NEXT:    sd t3, 288(sp)
-; CHECK-RV64-FD-NEXT:    sd t4, 280(sp)
-; CHECK-RV64-FD-NEXT:    sd t5, 272(sp)
-; CHECK-RV64-FD-NEXT:    sd t6, 264(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft0, 256(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft1, 248(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft2, 240(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft3, 232(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft4, 224(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft5, 216(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft6, 208(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft7, 200(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa0, 192(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa1, 184(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa2, 176(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa3, 168(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa4, 160(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa5, 152(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa6, 144(sp)
-; CHECK-RV64-FD-NEXT:    fsd fa7, 136(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft8, 128(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft9, 120(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft10, 112(sp)
-; CHECK-RV64-FD-NEXT:    fsd ft11, 104(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs0, 96(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs1, 88(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs2, 80(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs3, 72(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs4, 64(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs5, 56(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs6, 48(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs7, 40(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs8, 32(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs9, 24(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs10, 16(sp)
-; CHECK-RV64-FD-NEXT:    fsd fs11, 8(sp)
-; CHECK-RV64-FD-NEXT:    addi s0, sp, 400
-; CHECK-RV64-FD-NEXT:    call otherfoo
-; CHECK-RV64-FD-NEXT:    fld fs11, 8(sp)
-; CHECK-RV64-FD-NEXT:    fld fs10, 16(sp)
-; CHECK-RV64-FD-NEXT:    fld fs9, 24(sp)
-; CHECK-RV64-FD-NEXT:    fld fs8, 32(sp)
-; CHECK-RV64-FD-NEXT:    fld fs7, 40(sp)
-; CHECK-RV64-FD-NEXT:    fld fs6, 48(sp)
-; CHECK-RV64-FD-NEXT:    fld fs5, 56(sp)
-; CHECK-RV64-FD-NEXT:    fld fs4, 64(sp)
-; CHECK-RV64-FD-NEXT:    fld fs3, 72(sp)
-; CHECK-RV64-FD-NEXT:    fld fs2, 80(sp)
-; CHECK-RV64-FD-NEXT:    fld fs1, 88(sp)
-; CHECK-RV64-FD-NEXT:    fld fs0, 96(sp)
-; CHECK-RV64-FD-NEXT:    fld ft11, 104(sp)
-; CHECK-RV64-FD-NEXT:    fld ft10, 112(sp)
-; CHECK-RV64-FD-NEXT:    fld ft9, 120(sp)
-; CHECK-RV64-FD-NEXT:    fld ft8, 128(sp)
-; CHECK-RV64-FD-NEXT:    fld fa7, 136(sp)
-; CHECK-RV64-FD-NEXT:    fld fa6, 144(sp)
-; CHECK-RV64-FD-NEXT:    fld fa5, 152(sp)
-; CHECK-RV64-FD-NEXT:    fld fa4, 160(sp)
-; CHECK-RV64-FD-NEXT:    fld fa3, 168(sp)
-; CHECK-RV64-FD-NEXT:    fld fa2, 176(sp)
-; CHECK-RV64-FD-NEXT:    fld fa1, 184(sp)
-; CHECK-RV64-FD-NEXT:    fld fa0, 192(sp)
-; CHECK-RV64-FD-NEXT:    fld ft7, 200(sp)
-; CHECK-RV64-FD-NEXT:    fld ft6, 208(sp)
-; CHECK-RV64-FD-NEXT:    fld ft5, 216(sp)
-; CHECK-RV64-FD-NEXT:    fld ft4, 224(sp)
-; CHECK-RV64-FD-NEXT:    fld ft3, 232(sp)
-; CHECK-RV64-FD-NEXT:    fld ft2, 240(sp)
-; CHECK-RV64-FD-NEXT:    fld ft1, 248(sp)
-; CHECK-RV64-FD-NEXT:    fld ft0, 256(sp)
-; CHECK-RV64-FD-NEXT:    ld t6, 264(sp)
-; CHECK-RV64-FD-NEXT:    ld t5, 272(sp)
-; CHECK-RV64-FD-NEXT:    ld t4, 280(sp)
-; CHECK-RV64-FD-NEXT:    ld t3, 288(sp)
-; CHECK-RV64-FD-NEXT:    ld a7, 296(sp)
-; CHECK-RV64-FD-NEXT:    ld a6, 304(sp)
-; CHECK-RV64-FD-NEXT:    ld a5, 312(sp)
-; CHECK-RV64-FD-NEXT:    ld a4, 320(sp)
-; CHECK-RV64-FD-NEXT:    ld a3, 328(sp)
-; CHECK-RV64-FD-NEXT:    ld a2, 336(sp)
-; CHECK-RV64-FD-NEXT:    ld a1, 344(sp)
-; CHECK-RV64-FD-NEXT:    ld a0, 352(sp)
-; CHECK-RV64-FD-NEXT:    ld s0, 360(sp)
-; CHECK-RV64-FD-NEXT:    ld t2, 368(sp)
-; CHECK-RV64-FD-NEXT:    ld t1, 376(sp)
-; CHECK-RV64-FD-NEXT:    ld t0, 384(sp)
-; CHECK-RV64-FD-NEXT:    ld ra, 392(sp)
-; CHECK-RV64-FD-NEXT:    addi sp, sp, 400
-; CHECK-RV64-FD-NEXT:    mret
-  %call = call i32 bitcast (i32 (...)* @otherfoo to i32 ()*)()
-  ret void
-}
-
-attributes #0 = { "interrupt"="user" }
-attributes #1 = { "interrupt"="supervisor" }
-attributes #2 = { "interrupt"="machine" }
-attributes #3 = { "interrupt"="machine" "no-frame-pointer-elim"="true" }
diff --git a/test/CodeGen/RISCV/jumptable.ll b/test/CodeGen/RISCV/jumptable.ll
deleted file mode 100644
index f54f51edada..00000000000
--- a/test/CodeGen/RISCV/jumptable.ll
+++ /dev/null
@@ -1,58 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define void @jt(i32 %in, i32* %out) {
-; RV32I-LABEL: jt:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    blt a2, a0, .LBB0_4
-; RV32I-NEXT:  # %bb.1: # %entry
-; RV32I-NEXT:    addi a3, zero, 1
-; RV32I-NEXT:    beq a0, a3, .LBB0_7
-; RV32I-NEXT:  # %bb.2: # %entry
-; RV32I-NEXT:    bne a0, a2, .LBB0_9
-; RV32I-NEXT:  # %bb.3: # %bb2
-; RV32I-NEXT:    addi a0, zero, 3
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_4: # %entry
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    beq a0, a3, .LBB0_8
-; RV32I-NEXT:  # %bb.5: # %entry
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    bne a0, a2, .LBB0_9
-; RV32I-NEXT:  # %bb.6: # %bb4
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_7: # %bb1
-; RV32I-NEXT:    addi a0, zero, 4
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_8: # %bb3
-; RV32I-NEXT:    sw a2, 0(a1)
-; RV32I-NEXT:  .LBB0_9: # %exit
-; RV32I-NEXT:    ret
-entry:
-  switch i32 %in, label %exit [
-    i32 1, label %bb1
-    i32 2, label %bb2
-    i32 3, label %bb3
-    i32 4, label %bb4
-  ]
-bb1:
-  store i32 4, i32* %out
-  br label %exit
-bb2:
-  store i32 3, i32* %out
-  br label %exit
-bb3:
-  store i32 2, i32* %out
-  br label %exit
-bb4:
-  store i32 1, i32* %out
-  br label %exit
-exit:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/large-stack.ll b/test/CodeGen/RISCV/large-stack.ll
deleted file mode 100644
index 51130fc2a94..00000000000
--- a/test/CodeGen/RISCV/large-stack.ll
+++ /dev/null
@@ -1,172 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-; TODO: the quality of the generated code is poor
-
-define void @test() nounwind {
-; RV32I-FPELIM-LABEL: test:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a0, 74565
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1664
-; RV32I-FPELIM-NEXT:    sub sp, sp, a0
-; RV32I-FPELIM-NEXT:    lui a0, 74565
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1664
-; RV32I-FPELIM-NEXT:    add sp, sp, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    sub sp, sp, a0
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1676
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    sw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1672
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    sw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    add s0, sp, a0
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1672
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1676
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    add sp, sp, a0
-; RV32I-WITHFP-NEXT:    ret
-  %tmp = alloca [ 305419896 x i8 ] , align 4
-  ret void
-}
-
-; This test case artificially produces register pressure which should force
-; use of the emergency spill slot.
-
-define void @test_emergency_spill_slot(i32 %a) nounwind {
-; RV32I-FPELIM-LABEL: test_emergency_spill_slot:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1392
-; RV32I-FPELIM-NEXT:    sub sp, sp, a1
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1396
-; RV32I-FPELIM-NEXT:    add a1, sp, a1
-; RV32I-FPELIM-NEXT:    sw s1, 0(a1)
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1400
-; RV32I-FPELIM-NEXT:    add a1, sp, a1
-; RV32I-FPELIM-NEXT:    sw s2, 0(a1)
-; RV32I-FPELIM-NEXT:    lui a1, 78
-; RV32I-FPELIM-NEXT:    addi a1, a1, 512
-; RV32I-FPELIM-NEXT:    addi a2, sp, 8
-; RV32I-FPELIM-NEXT:    add a1, a2, a1
-; RV32I-FPELIM-NEXT:    #APP
-; RV32I-FPELIM-NEXT:    nop
-; RV32I-FPELIM-NEXT:    #NO_APP
-; RV32I-FPELIM-NEXT:    sw a0, 0(a1)
-; RV32I-FPELIM-NEXT:    #APP
-; RV32I-FPELIM-NEXT:    nop
-; RV32I-FPELIM-NEXT:    #NO_APP
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1400
-; RV32I-FPELIM-NEXT:    add a0, sp, a0
-; RV32I-FPELIM-NEXT:    lw s2, 0(a0)
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1396
-; RV32I-FPELIM-NEXT:    add a0, sp, a0
-; RV32I-FPELIM-NEXT:    lw s1, 0(a0)
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1392
-; RV32I-FPELIM-NEXT:    add sp, sp, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test_emergency_spill_slot:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1376
-; RV32I-WITHFP-NEXT:    sub sp, sp, a1
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1380
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw ra, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1384
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s0, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1388
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s1, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1392
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s2, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1376
-; RV32I-WITHFP-NEXT:    add s0, sp, a1
-; RV32I-WITHFP-NEXT:    lui a1, 78
-; RV32I-WITHFP-NEXT:    addi a1, a1, 512
-; RV32I-WITHFP-NEXT:    lui a2, 1048478
-; RV32I-WITHFP-NEXT:    addi a2, a2, 1388
-; RV32I-WITHFP-NEXT:    add a2, s0, a2
-; RV32I-WITHFP-NEXT:    mv a2, a2
-; RV32I-WITHFP-NEXT:    add a1, a2, a1
-; RV32I-WITHFP-NEXT:    #APP
-; RV32I-WITHFP-NEXT:    nop
-; RV32I-WITHFP-NEXT:    #NO_APP
-; RV32I-WITHFP-NEXT:    sw a0, 0(a1)
-; RV32I-WITHFP-NEXT:    #APP
-; RV32I-WITHFP-NEXT:    nop
-; RV32I-WITHFP-NEXT:    #NO_APP
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1392
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s2, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1388
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s1, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1384
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1380
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1376
-; RV32I-WITHFP-NEXT:    add sp, sp, a0
-; RV32I-WITHFP-NEXT:    ret
-  %data = alloca [ 100000 x i32 ] , align 4
-  %ptr = getelementptr inbounds [100000 x i32], [100000 x i32]* %data, i32 0, i32 80000
-  %1 = tail call { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } asm sideeffect "nop", "=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r"()
-  %asmresult0 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 0
-  %asmresult1 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 1
-  %asmresult2 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 2
-  %asmresult3 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 3
-  %asmresult4 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 4
-  %asmresult5 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 5
-  %asmresult6 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 6
-  %asmresult7 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 7
-  %asmresult8 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 8
-  %asmresult9 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 9
-  %asmresult10 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 10
-  %asmresult11 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 11
-  %asmresult12 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 12
-  %asmresult13 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 13
-  %asmresult14 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 14
-  store volatile i32 %a, i32* %ptr
-  tail call void asm sideeffect "nop", "r,r,r,r,r,r,r,r,r,r,r,r,r,r,r"(i32 %asmresult0, i32 %asmresult1, i32 %asmresult2, i32 %asmresult3, i32 %asmresult4, i32 %asmresult5, i32 %asmresult6, i32 %asmresult7, i32 %asmresult8, i32 %asmresult9, i32 %asmresult10, i32 %asmresult11, i32 %asmresult12, i32 %asmresult13, i32 %asmresult14)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/lit.local.cfg b/test/CodeGen/RISCV/lit.local.cfg
deleted file mode 100644
index c63820126f8..00000000000
--- a/test/CodeGen/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
diff --git a/test/CodeGen/RISCV/lsr-legaladdimm.ll b/test/CodeGen/RISCV/lsr-legaladdimm.ll
deleted file mode 100644
index 2f4c821d883..00000000000
--- a/test/CodeGen/RISCV/lsr-legaladdimm.ll
+++ /dev/null
@@ -1,48 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-@a = global [4096 x i32] zeroinitializer, align 4
-@b = global [4096 x i32] zeroinitializer, align 4
-
-; This test demonstrates very slightly improved codegen in the case that
-; a correct isLegalAddImmediate is implemented, thanks to LoopStrengthReduce.
-
-define i32 @main() nounwind {
-; RV32I-LABEL: main:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lui a0, %hi(b)
-; RV32I-NEXT:    addi a0, a0, %lo(b)
-; RV32I-NEXT:    lui a1, %hi(a)
-; RV32I-NEXT:    addi a1, a1, %lo(a)
-; RV32I-NEXT:    lui a2, 1
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:  .LBB0_1: # %for.body
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    addi a4, a3, -2048
-; RV32I-NEXT:    sw a4, 0(a1)
-; RV32I-NEXT:    addi a1, a1, 4
-; RV32I-NEXT:    sw a3, 0(a0)
-; RV32I-NEXT:    addi a0, a0, 4
-; RV32I-NEXT:    addi a3, a3, 1
-; RV32I-NEXT:    bne a3, a2, .LBB0_1
-; RV32I-NEXT:  # %bb.2: # %for.end
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-entry:
-  br label %for.body
-
-for.body:
-  %i.08 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
-  %sub = add nsw i32 %i.08, -2048
-  %arrayidx = getelementptr inbounds [4096 x i32], [4096 x i32]* @a, i32 0, i32 %i.08
-  store i32 %sub, i32* %arrayidx, align 4
-  %arrayidx1 = getelementptr inbounds [4096 x i32], [4096 x i32]* @b, i32 0, i32 %i.08
-  store i32 %i.08, i32* %arrayidx1, align 4
-  %inc = add nuw nsw i32 %i.08, 1
-  %exitcond = icmp eq i32 %inc, 4096
-  br i1 %exitcond, label %for.end, label %for.body
-
-for.end:
-  ret i32 0
-}
diff --git a/test/CodeGen/RISCV/mem.ll b/test/CodeGen/RISCV/mem.ll
deleted file mode 100644
index f873e842829..00000000000
--- a/test/CodeGen/RISCV/mem.ll
+++ /dev/null
@@ -1,197 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Check indexed and unindexed, sext, zext and anyext loads
-
-define i32 @lb(i8 *%a) nounwind {
-; RV32I-LABEL: lb:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lb a0, 1(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 1
-  %2 = load i8, i8* %1
-  %3 = sext i8 %2 to i32
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i8, i8* %a
-  ret i32 %3
-}
-
-define i32 @lh(i16 *%a) nounwind {
-; RV32I-LABEL: lh:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lh a1, 0(a0)
-; RV32I-NEXT:    lh a0, 4(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 2
-  %2 = load i16, i16* %1
-  %3 = sext i16 %2 to i32
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i16, i16* %a
-  ret i32 %3
-}
-
-define i32 @lw(i32 *%a) nounwind {
-; RV32I-LABEL: lw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a1, 0(a0)
-; RV32I-NEXT:    lw a0, 12(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i32, i32* %a, i32 3
-  %2 = load i32, i32* %1
-  %3 = load volatile i32, i32* %a
-  ret i32 %2
-}
-
-define i32 @lbu(i8 *%a) nounwind {
-; RV32I-LABEL: lbu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lbu a1, 0(a0)
-; RV32I-NEXT:    lbu a0, 4(a0)
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 4
-  %2 = load i8, i8* %1
-  %3 = zext i8 %2 to i32
-  %4 = load volatile i8, i8* %a
-  %5 = zext i8 %4 to i32
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
-
-define i32 @lhu(i16 *%a) nounwind {
-; RV32I-LABEL: lhu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lhu a1, 0(a0)
-; RV32I-NEXT:    lhu a0, 10(a0)
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 5
-  %2 = load i16, i16* %1
-  %3 = zext i16 %2 to i32
-  %4 = load volatile i16, i16* %a
-  %5 = zext i16 %4 to i32
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
-
-; Check indexed and unindexed stores
-
-define void @sb(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: sb:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sb a1, 6(a0)
-; RV32I-NEXT:    sb a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i8 %b, i8* %a
-  %1 = getelementptr i8, i8* %a, i32 6
-  store i8 %b, i8* %1
-  ret void
-}
-
-define void @sh(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: sh:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sh a1, 14(a0)
-; RV32I-NEXT:    sh a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i16 %b, i16* %a
-  %1 = getelementptr i16, i16* %a, i32 7
-  store i16 %b, i16* %1
-  ret void
-}
-
-define void @sw(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: sw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sw a1, 32(a0)
-; RV32I-NEXT:    sw a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i32 %b, i32* %a
-  %1 = getelementptr i32, i32* %a, i32 8
-  store i32 %b, i32* %1
-  ret void
-}
-
-; Check load and store to an i1 location
-define i32 @load_sext_zext_anyext_i1(i1 *%a) nounwind {
-; RV32I-LABEL: load_sext_zext_anyext_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lbu a1, 1(a0)
-; RV32I-NEXT:    lbu a0, 2(a0)
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i32
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i32
-  %7 = add i32 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i32 %7
-}
-
-define i16 @load_sext_zext_anyext_i1_i16(i1 *%a) nounwind {
-; RV32I-LABEL: load_sext_zext_anyext_i1_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lbu a1, 1(a0)
-; RV32I-NEXT:    lbu a0, 2(a0)
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i16
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i16
-  %7 = add i16 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i16 %7
-}
-
-; Check load and store to a global
-@G = global i32 0
-
-define i32 @lw_sw_global(i32 %a) nounwind {
-; RV32I-LABEL: lw_sw_global:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, %hi(G)
-; RV32I-NEXT:    lw a1, %lo(G)(a2)
-; RV32I-NEXT:    sw a0, %lo(G)(a2)
-; RV32I-NEXT:    addi a2, a2, %lo(G)
-; RV32I-NEXT:    lw a3, 36(a2)
-; RV32I-NEXT:    sw a0, 36(a2)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = load volatile i32, i32* @G
-  store i32 %a, i32* @G
-  %2 = getelementptr i32, i32* @G, i32 9
-  %3 = load volatile i32, i32* %2
-  store i32 %a, i32* %2
-  ret i32 %1
-}
-
-; Ensure that 1 is added to the high 20 bits if bit 11 of the low part is 1
-define i32 @lw_sw_constant(i32 %a) nounwind {
-; RV32I-LABEL: lw_sw_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, 912092
-; RV32I-NEXT:    lw a1, -273(a2)
-; RV32I-NEXT:    sw a0, -273(a2)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = inttoptr i32 3735928559 to i32*
-  %2 = load volatile i32, i32* %1
-  store i32 %a, i32* %1
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/mem64.ll b/test/CodeGen/RISCV/mem64.ll
deleted file mode 100644
index 32669e8aef3..00000000000
--- a/test/CodeGen/RISCV/mem64.ll
+++ /dev/null
@@ -1,226 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV64I %s
-
-; Check indexed and unindexed, sext, zext and anyext loads
-
-define i64 @lb(i8 *%a) nounwind {
-; RV64I-LABEL: lb:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lb a1, 0(a0)
-; RV64I-NEXT:    lb a0, 1(a0)
-; RV64I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 1
-  %2 = load i8, i8* %1
-  %3 = sext i8 %2 to i64
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i8, i8* %a
-  ret i64 %3
-}
-
-define i64 @lh(i16 *%a) nounwind {
-; RV64I-LABEL: lh:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lh a1, 0(a0)
-; RV64I-NEXT:    lh a0, 4(a0)
-; RV64I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 2
-  %2 = load i16, i16* %1
-  %3 = sext i16 %2 to i64
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i16, i16* %a
-  ret i64 %3
-}
-
-define i64 @lw(i32 *%a) nounwind {
-; RV64I-LABEL: lw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lw a1, 0(a0)
-; RV64I-NEXT:    lw a0, 12(a0)
-; RV64I-NEXT:    ret
-  %1 = getelementptr i32, i32* %a, i32 3
-  %2 = load i32, i32* %1
-  %3 = sext i32 %2 to i64
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i32, i32* %a
-  ret i64 %3
-}
-
-define i64 @lbu(i8 *%a) nounwind {
-; RV64I-LABEL: lbu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lbu a1, 0(a0)
-; RV64I-NEXT:    lbu a0, 4(a0)
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 4
-  %2 = load i8, i8* %1
-  %3 = zext i8 %2 to i64
-  %4 = load volatile i8, i8* %a
-  %5 = zext i8 %4 to i64
-  %6 = add i64 %3, %5
-  ret i64 %6
-}
-
-define i64 @lhu(i16 *%a) nounwind {
-; RV64I-LABEL: lhu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lhu a1, 0(a0)
-; RV64I-NEXT:    lhu a0, 10(a0)
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 5
-  %2 = load i16, i16* %1
-  %3 = zext i16 %2 to i64
-  %4 = load volatile i16, i16* %a
-  %5 = zext i16 %4 to i64
-  %6 = add i64 %3, %5
-  ret i64 %6
-}
-
-define i64 @lwu(i32 *%a) nounwind {
-; RV64I-LABEL: lwu:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lwu a1, 0(a0)
-; RV64I-NEXT:    lwu a0, 24(a0)
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = getelementptr i32, i32* %a, i32 6
-  %2 = load i32, i32* %1
-  %3 = zext i32 %2 to i64
-  %4 = load volatile i32, i32* %a
-  %5 = zext i32 %4 to i64
-  %6 = add i64 %3, %5
-  ret i64 %6
-}
-
-; Check indexed and unindexed stores
-
-define void @sb(i8 *%a, i8 %b) nounwind {
-; RV64I-LABEL: sb:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sb a1, 7(a0)
-; RV64I-NEXT:    sb a1, 0(a0)
-; RV64I-NEXT:    ret
-  store i8 %b, i8* %a
-  %1 = getelementptr i8, i8* %a, i32 7
-  store i8 %b, i8* %1
-  ret void
-}
-
-define void @sh(i16 *%a, i16 %b) nounwind {
-; RV64I-LABEL: sh:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sh a1, 16(a0)
-; RV64I-NEXT:    sh a1, 0(a0)
-; RV64I-NEXT:    ret
-  store i16 %b, i16* %a
-  %1 = getelementptr i16, i16* %a, i32 8
-  store i16 %b, i16* %1
-  ret void
-}
-
-define void @sw(i32 *%a, i32 %b) nounwind {
-; RV64I-LABEL: sw:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sw a1, 36(a0)
-; RV64I-NEXT:    sw a1, 0(a0)
-; RV64I-NEXT:    ret
-  store i32 %b, i32* %a
-  %1 = getelementptr i32, i32* %a, i32 9
-  store i32 %b, i32* %1
-  ret void
-}
-
-; 64-bit loads and stores
-
-define i64 @ld(i64 *%a) nounwind {
-; RV64I-LABEL: ld:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ld a1, 0(a0)
-; RV64I-NEXT:    ld a0, 80(a0)
-; RV64I-NEXT:    ret
-  %1 = getelementptr i64, i64* %a, i32 10
-  %2 = load i64, i64* %1
-  %3 = load volatile i64, i64* %a
-  ret i64 %2
-}
-
-define void @sd(i64 *%a, i64 %b) nounwind {
-; RV64I-LABEL: sd:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sd a1, 88(a0)
-; RV64I-NEXT:    sd a1, 0(a0)
-; RV64I-NEXT:    ret
-  store i64 %b, i64* %a
-  %1 = getelementptr i64, i64* %a, i32 11
-  store i64 %b, i64* %1
-  ret void
-}
-
-; Check load and store to an i1 location
-define i64 @load_sext_zext_anyext_i1(i1 *%a) nounwind {
-; RV64I-LABEL: load_sext_zext_anyext_i1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lb a1, 0(a0)
-; RV64I-NEXT:    lbu a1, 1(a0)
-; RV64I-NEXT:    lbu a0, 2(a0)
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i64
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i64
-  %7 = add i64 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i64 %7
-}
-
-define i16 @load_sext_zext_anyext_i1_i16(i1 *%a) nounwind {
-; RV64I-LABEL: load_sext_zext_anyext_i1_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lb a1, 0(a0)
-; RV64I-NEXT:    lbu a1, 1(a0)
-; RV64I-NEXT:    lbu a0, 2(a0)
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i16
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i16
-  %7 = add i16 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i16 %7
-}
-
-; Check load and store to a global
-@G = global i64 0
-
-define i64 @ld_sd_global(i64 %a) nounwind {
-; RV64I-LABEL: ld_sd_global:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a2, %hi(G)
-; RV64I-NEXT:    ld a1, %lo(G)(a2)
-; RV64I-NEXT:    sd a0, %lo(G)(a2)
-; RV64I-NEXT:    addi a2, a2, %lo(G)
-; RV64I-NEXT:    ld a3, 72(a2)
-; RV64I-NEXT:    sd a0, 72(a2)
-; RV64I-NEXT:    mv a0, a1
-; RV64I-NEXT:    ret
-  %1 = load volatile i64, i64* @G
-  store i64 %a, i64* @G
-  %2 = getelementptr i64, i64* @G, i64 9
-  %3 = load volatile i64, i64* %2
-  store i64 %a, i64* %2
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/mul.ll b/test/CodeGen/RISCV/mul.ll
deleted file mode 100644
index 444a75f3751..00000000000
--- a/test/CodeGen/RISCV/mul.ll
+++ /dev/null
@@ -1,175 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @square(i32 %a) nounwind {
-; RV32I-LABEL: square:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: square:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a0, a0, a0
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, %a
-  ret i32 %1
-}
-
-define i32 @mul(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mul:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @mul_constant(i32 %a) nounwind {
-; RV32I-LABEL: mul_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    call __mulsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi a1, zero, 5
-; RV32IM-NEXT:    mul a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @mul_pow2(i32 %a) nounwind {
-; RV32I-LABEL: mul_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    slli a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @mul64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: mul64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __muldi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a3, a0, a3
-; RV32IM-NEXT:    mulhu a4, a0, a2
-; RV32IM-NEXT:    add a3, a4, a3
-; RV32IM-NEXT:    mul a1, a1, a2
-; RV32IM-NEXT:    add a1, a3, a1
-; RV32IM-NEXT:    mul a0, a0, a2
-; RV32IM-NEXT:    ret
-  %1 = mul i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @mul64_constant(i64 %a) nounwind {
-; RV32I-LABEL: mul64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __muldi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mul a1, a1, a2
-; RV32IM-NEXT:    mulhu a3, a0, a2
-; RV32IM-NEXT:    add a1, a3, a1
-; RV32IM-NEXT:    mul a0, a0, a2
-; RV32IM-NEXT:    ret
-  %1 = mul i64 %a, 5
-  ret i64 %1
-}
-
-define i32 @mulhs(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mulhs:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a1
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    srai a3, a2, 31
-; RV32I-NEXT:    call __muldi3
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mulhs:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mulh a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sext i32 %a to i64
-  %2 = sext i32 %b to i64
-  %3 = mul i64 %1, %2
-  %4 = lshr i64 %3, 32
-  %5 = trunc i64 %4 to i32
-  ret i32 %5
-}
-
-define i32 @mulhu(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mulhu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    call __muldi3
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mulhu:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mulhu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = zext i32 %a to i64
-  %2 = zext i32 %b to i64
-  %3 = mul i64 %1, %2
-  %4 = lshr i64 %3, 32
-  %5 = trunc i64 %4 to i32
-  ret i32 %5
-}
diff --git a/test/CodeGen/RISCV/musttail-call.ll b/test/CodeGen/RISCV/musttail-call.ll
deleted file mode 100644
index 551aa7245ce..00000000000
--- a/test/CodeGen/RISCV/musttail-call.ll
+++ /dev/null
@@ -1,20 +0,0 @@
-; Check that we error out if tail is not possible but call is marked as mustail.
-
-; RUN: not llc -mtriple riscv32-unknown-linux-gnu -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv32-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv64-unknown-linux-gnu -o - %s \
-; RUN: 2>&1 | FileCheck %s
-; RUN: not llc -mtriple riscv64-unknown-elf -o - %s \
-; RUN: 2>&1 | FileCheck %s
-
-%struct.A = type { i32 }
-
-declare void @callee_musttail(%struct.A* sret %a)
-define void @caller_musttail(%struct.A* sret %a) {
-; CHECK: LLVM ERROR: failed to perform tail call elimination on a call site marked musttail
-entry:
-  musttail call void @callee_musttail(%struct.A* sret %a)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/option-norelax.ll b/test/CodeGen/RISCV/option-norelax.ll
deleted file mode 100644
index ad2b3249379..00000000000
--- a/test/CodeGen/RISCV/option-norelax.ll
+++ /dev/null
@@ -1,16 +0,0 @@
-; RUN: llc -mtriple=riscv32 -mattr=+relax -filetype=obj < %s \
-; RUN:     | llvm-objdump -d -r - | FileCheck %s
-
-; This test demonstrates that .option norelax has no effect on codegen
-; when emitting an ELF directly.
-
-declare i32 @foo(i32)
-
-define i32 @bar(i32 %a) nounwind {
-; CHECK-LABEL: bar:
-; CHECK: R_RISCV_CALL
-; CHECK: R_RISCV_RELAX
-  tail call void asm sideeffect ".option norelax", ""()
-  %1 = call i32 @foo(i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/option-norvc.ll b/test/CodeGen/RISCV/option-norvc.ll
deleted file mode 100644
index 381fb37735d..00000000000
--- a/test/CodeGen/RISCV/option-norvc.ll
+++ /dev/null
@@ -1,15 +0,0 @@
-; RUN: llc -mtriple=riscv32 -mattr=+c  -filetype=obj < %s\
-; RUN: | llvm-objdump -triple=riscv32 -mattr=+c -d -riscv-no-aliases -\
-; RUN: | FileCheck -check-prefix=CHECK %s
-
-; This test demonstrates that .option norvc has no effect on codegen when
-; emitting an ELF directly.
-
-define i32 @add(i32 %a, i32 %b) nounwind {
-; CHECK-LABEL: add:
-; CHECK:    c.add a0, a1
-; CHECK-NEXT:    c.jr ra
-  tail call void asm sideeffect ".option norvc", ""()
-  %add = add nsw i32 %b, %a
-  ret i32 %add
-}
diff --git a/test/CodeGen/RISCV/option-relax.ll b/test/CodeGen/RISCV/option-relax.ll
deleted file mode 100644
index 26296990561..00000000000
--- a/test/CodeGen/RISCV/option-relax.ll
+++ /dev/null
@@ -1,16 +0,0 @@
-; RUN: llc -mtriple=riscv32 -mattr=-relax -filetype=obj < %s \
-; RUN:     | llvm-objdump -d -r - | FileCheck %s
-
-; This test demonstrates that .option relax has no effect on codegen
-; when emitting an ELF directly.
-
-declare i32 @foo(i32)
-
-define i32 @bar(i32 %a) nounwind {
-; CHECK-LABEL: bar:
-; CHECK: R_RISCV_CALL
-; CHECK-NOT: R_RISCV_RELAX
-  tail call void asm sideeffect ".option relax", ""()
-  %1 = call i32 @foo(i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/option-rvc.ll b/test/CodeGen/RISCV/option-rvc.ll
deleted file mode 100644
index 3c207bd424f..00000000000
--- a/test/CodeGen/RISCV/option-rvc.ll
+++ /dev/null
@@ -1,15 +0,0 @@
-; RUN: llc -mtriple=riscv32 -filetype=obj < %s\
-; RUN: | llvm-objdump -triple=riscv32 -mattr=+c -d -riscv-no-aliases -\
-; RUN: | FileCheck -check-prefix=CHECK %s
-
-; This test demonstrates that .option norvc has no effect on codegen when
-; emitting an ELF directly.
-
-define i32 @add(i32 %a, i32 %b) nounwind {
-; CHECK-LABEL: add:
-; CHECK:    add a0, a1, a0
-; CHECK-NEXT:    jalr zero, ra, 0
-  tail call void asm sideeffect ".option rvc", ""()
-  %add = add nsw i32 %b, %a
-  ret i32 %add
-}
diff --git a/test/CodeGen/RISCV/prefetch.ll b/test/CodeGen/RISCV/prefetch.ll
deleted file mode 100644
index 7891b2e8c74..00000000000
--- a/test/CodeGen/RISCV/prefetch.ll
+++ /dev/null
@@ -1,19 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV64I %s
-
-declare void @llvm.prefetch(i8*, i32, i32, i32)
-
-define void @test_prefetch(i8* %a) nounwind {
-; RV32I-LABEL: test_prefetch:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: test_prefetch:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  call void @llvm.prefetch(i8* %a, i32 0, i32 1, i32 2)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/rem.ll b/test/CodeGen/RISCV/rem.ll
deleted file mode 100644
index f37931f448e..00000000000
--- a/test/CodeGen/RISCV/rem.ll
+++ /dev/null
@@ -1,41 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @urem(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: urem:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __umodsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: urem:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    remu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = urem i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @srem(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srem:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __modsi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: srem:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    rem a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = srem i32 %a, %b
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/remat.ll b/test/CodeGen/RISCV/remat.ll
deleted file mode 100644
index 3b146615bf0..00000000000
--- a/test/CodeGen/RISCV/remat.ll
+++ /dev/null
@@ -1,200 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -O1 -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-@a = common global i32 0, align 4
-@l = common global i32 0, align 4
-@b = common global i32 0, align 4
-@c = common global i32 0, align 4
-@d = common global i32 0, align 4
-@e = common global i32 0, align 4
-@k = common global i32 0, align 4
-@f = common global i32 0, align 4
-@j = common global i32 0, align 4
-@g = common global i32 0, align 4
-@i = common global i32 0, align 4
-@h = common global i32 0, align 4
-
-; This test case benefits from codegen recognising that some values are
-; trivially rematerialisable, meaning they are recreated rather than saved to
-; the stack and restored. It creates high register pressure to force this
-; situation.
-
-define i32 @test() nounwind {
-; RV32I-LABEL: test:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    sw s7, 16(sp)
-; RV32I-NEXT:    sw s8, 12(sp)
-; RV32I-NEXT:    sw s9, 8(sp)
-; RV32I-NEXT:    sw s10, 4(sp)
-; RV32I-NEXT:    sw s11, 0(sp)
-; RV32I-NEXT:    lui s3, %hi(a)
-; RV32I-NEXT:    lw a0, %lo(a)(s3)
-; RV32I-NEXT:    beqz a0, .LBB0_11
-; RV32I-NEXT:  # %bb.1: # %for.body.preheader
-; RV32I-NEXT:    lui s5, %hi(k)
-; RV32I-NEXT:    lui s6, %hi(j)
-; RV32I-NEXT:    lui s7, %hi(i)
-; RV32I-NEXT:    lui s9, %hi(g)
-; RV32I-NEXT:    lui s10, %hi(f)
-; RV32I-NEXT:    lui s1, %hi(e)
-; RV32I-NEXT:    lui s8, %hi(d)
-; RV32I-NEXT:    addi s11, zero, 32
-; RV32I-NEXT:    lui s2, %hi(c)
-; RV32I-NEXT:    lui s4, %hi(b)
-; RV32I-NEXT:  .LBB0_2: # %for.body
-; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
-; RV32I-NEXT:    lui a1, %hi(l)
-; RV32I-NEXT:    lw a1, %lo(l)(a1)
-; RV32I-NEXT:    beqz a1, .LBB0_4
-; RV32I-NEXT:  # %bb.3: # %if.then
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a4, %lo(e)(s1)
-; RV32I-NEXT:    lw a3, %lo(d)(s8)
-; RV32I-NEXT:    lw a2, %lo(c)(s2)
-; RV32I-NEXT:    lw a1, %lo(b)(s4)
-; RV32I-NEXT:    mv a5, s11
-; RV32I-NEXT:    call foo
-; RV32I-NEXT:  .LBB0_4: # %if.end
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a0, %lo(k)(s5)
-; RV32I-NEXT:    beqz a0, .LBB0_6
-; RV32I-NEXT:  # %bb.5: # %if.then3
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a4, %lo(f)(s10)
-; RV32I-NEXT:    lw a3, %lo(e)(s1)
-; RV32I-NEXT:    lw a2, %lo(d)(s8)
-; RV32I-NEXT:    lw a1, %lo(c)(s2)
-; RV32I-NEXT:    lw a0, %lo(b)(s4)
-; RV32I-NEXT:    addi a5, zero, 64
-; RV32I-NEXT:    call foo
-; RV32I-NEXT:  .LBB0_6: # %if.end5
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a0, %lo(j)(s6)
-; RV32I-NEXT:    beqz a0, .LBB0_8
-; RV32I-NEXT:  # %bb.7: # %if.then7
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a4, %lo(g)(s9)
-; RV32I-NEXT:    lw a3, %lo(f)(s10)
-; RV32I-NEXT:    lw a2, %lo(e)(s1)
-; RV32I-NEXT:    lw a1, %lo(d)(s8)
-; RV32I-NEXT:    lw a0, %lo(c)(s2)
-; RV32I-NEXT:    mv a5, s11
-; RV32I-NEXT:    call foo
-; RV32I-NEXT:  .LBB0_8: # %if.end9
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a0, %lo(i)(s7)
-; RV32I-NEXT:    beqz a0, .LBB0_10
-; RV32I-NEXT:  # %bb.9: # %if.then11
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lui a0, %hi(h)
-; RV32I-NEXT:    lw a4, %lo(h)(a0)
-; RV32I-NEXT:    lw a3, %lo(g)(s9)
-; RV32I-NEXT:    lw a2, %lo(f)(s10)
-; RV32I-NEXT:    lw a1, %lo(e)(s1)
-; RV32I-NEXT:    lw a0, %lo(d)(s8)
-; RV32I-NEXT:    mv a5, s11
-; RV32I-NEXT:    call foo
-; RV32I-NEXT:  .LBB0_10: # %for.inc
-; RV32I-NEXT:    # in Loop: Header=BB0_2 Depth=1
-; RV32I-NEXT:    lw a0, %lo(a)(s3)
-; RV32I-NEXT:    addi a0, a0, -1
-; RV32I-NEXT:    sw a0, %lo(a)(s3)
-; RV32I-NEXT:    bnez a0, .LBB0_2
-; RV32I-NEXT:  .LBB0_11: # %for.end
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    lw s11, 0(sp)
-; RV32I-NEXT:    lw s10, 4(sp)
-; RV32I-NEXT:    lw s9, 8(sp)
-; RV32I-NEXT:    lw s8, 12(sp)
-; RV32I-NEXT:    lw s7, 16(sp)
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-entry:
-  %.pr = load i32, i32* @a, align 4
-  %tobool14 = icmp eq i32 %.pr, 0
-  br i1 %tobool14, label %for.end, label %for.body
-
-for.body:                                         ; preds = %entry, %for.inc
-  %0 = phi i32 [ %dec, %for.inc ], [ %.pr, %entry ]
-  %1 = load i32, i32* @l, align 4
-  %tobool1 = icmp eq i32 %1, 0
-  br i1 %tobool1, label %if.end, label %if.then
-
-if.then:                                          ; preds = %for.body
-  %2 = load i32, i32* @b, align 4
-  %3 = load i32, i32* @c, align 4
-  %4 = load i32, i32* @d, align 4
-  %5 = load i32, i32* @e, align 4
-  %call = tail call i32 @foo(i32 %0, i32 %2, i32 %3, i32 %4, i32 %5, i32 32) #3
-  br label %if.end
-
-if.end:                                           ; preds = %for.body, %if.then
-  %6 = load i32, i32* @k, align 4
-  %tobool2 = icmp eq i32 %6, 0
-  br i1 %tobool2, label %if.end5, label %if.then3
-
-if.then3:                                         ; preds = %if.end
-  %7 = load i32, i32* @b, align 4
-  %8 = load i32, i32* @c, align 4
-  %9 = load i32, i32* @d, align 4
-  %10 = load i32, i32* @e, align 4
-  %11 = load i32, i32* @f, align 4
-  %call4 = tail call i32 @foo(i32 %7, i32 %8, i32 %9, i32 %10, i32 %11, i32 64) #3
-  br label %if.end5
-
-if.end5:                                          ; preds = %if.end, %if.then3
-  %12 = load i32, i32* @j, align 4
-  %tobool6 = icmp eq i32 %12, 0
-  br i1 %tobool6, label %if.end9, label %if.then7
-
-if.then7:                                         ; preds = %if.end5
-  %13 = load i32, i32* @c, align 4
-  %14 = load i32, i32* @d, align 4
-  %15 = load i32, i32* @e, align 4
-  %16 = load i32, i32* @f, align 4
-  %17 = load i32, i32* @g, align 4
-  %call8 = tail call i32 @foo(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17, i32 32) #3
-  br label %if.end9
-
-if.end9:                                          ; preds = %if.end5, %if.then7
-  %18 = load i32, i32* @i, align 4
-  %tobool10 = icmp eq i32 %18, 0
-  br i1 %tobool10, label %for.inc, label %if.then11
-
-if.then11:                                        ; preds = %if.end9
-  %19 = load i32, i32* @d, align 4
-  %20 = load i32, i32* @e, align 4
-  %21 = load i32, i32* @f, align 4
-  %22 = load i32, i32* @g, align 4
-  %23 = load i32, i32* @h, align 4
-  %call12 = tail call i32 @foo(i32 %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 32) #3
-  br label %for.inc
-
-for.inc:                                          ; preds = %if.end9, %if.then11
-  %24 = load i32, i32* @a, align 4
-  %dec = add nsw i32 %24, -1
-  store i32 %dec, i32* @a, align 4
-  %tobool = icmp eq i32 %dec, 0
-  br i1 %tobool, label %for.end, label %for.body
-
-for.end:                                          ; preds = %for.inc, %entry
-  ret i32 1
-}
-
-declare i32 @foo(i32, i32, i32, i32, i32, i32)
diff --git a/test/CodeGen/RISCV/rotl-rotr.ll b/test/CodeGen/RISCV/rotl-rotr.ll
deleted file mode 100644
index 49b540eb2b1..00000000000
--- a/test/CodeGen/RISCV/rotl-rotr.ll
+++ /dev/null
@@ -1,38 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; These IR sequences will generate ISD::ROTL and ISD::ROTR nodes, that the
-; RISC-V backend must be able to select
-
-define i32 @rotl(i32 %x, i32 %y) {
-; RV32I-LABEL: rotl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a2, zero, 32
-; RV32I-NEXT:    sub a2, a2, a1
-; RV32I-NEXT:    sll a1, a0, a1
-; RV32I-NEXT:    srl a0, a0, a2
-; RV32I-NEXT:    or a0, a1, a0
-; RV32I-NEXT:    ret
-  %z = sub i32 32, %y
-  %b = shl i32 %x, %y
-  %c = lshr i32 %x, %z
-  %d = or i32 %b, %c
-  ret i32 %d
-}
-
-define i32 @rotr(i32 %x, i32 %y) {
-; RV32I-LABEL: rotr:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a2, zero, 32
-; RV32I-NEXT:    sub a2, a2, a1
-; RV32I-NEXT:    srl a1, a0, a1
-; RV32I-NEXT:    sll a0, a0, a2
-; RV32I-NEXT:    or a0, a1, a0
-; RV32I-NEXT:    ret
-  %z = sub i32 32, %y
-  %b = lshr i32 %x, %y
-  %c = shl i32 %x, %z
-  %d = or i32 %b, %c
-  ret i32 %d
-}
diff --git a/test/CodeGen/RISCV/rv64i-exhaustive-w-insts.ll b/test/CodeGen/RISCV/rv64i-exhaustive-w-insts.ll
deleted file mode 100644
index 52a59c04a32..00000000000
--- a/test/CodeGen/RISCV/rv64i-exhaustive-w-insts.ll
+++ /dev/null
@@ -1,1769 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; The patterns for the 'W' suffixed RV64I instructions have the potential of
-; missing cases. This file checks all the variants of
-; sign-extended/zero-extended/any-extended inputs and outputs.
-
-; The 64-bit add instruction can safely be used when the result is anyext.
-
-define i32 @aext_addw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_addw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_addw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_addw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_addw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_addw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_addw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_addw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_addw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_addw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_addw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-; Always select addw when a signext result is required.
-
-define signext i32 @sext_addw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_addw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_addw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_addw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_addw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_addw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_addw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_addw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_addw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_addw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_addw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-; 64-bit add followed by zero-extension is a safe option when a zeroext result
-; is required.
-
-define zeroext i32 @zext_addw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_addw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_addw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_addw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_addw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_addw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_addw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_addw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_addw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_addw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    add a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-; 64-bit sub is safe for an anyext result.
-
-define i32 @aext_subw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_subw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_subw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_subw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_subw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_subw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_subw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_subw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_subw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_subw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_subw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-; Always select subw for a signext result.
-
-define signext i32 @sext_subw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_subw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_subw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_subw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_subw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_subw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_subw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_subw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_subw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_subw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_subw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    subw a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-; 64-bit sub followed by zero-extension is safe for a zeroext result.
-
-define zeroext i32 @zext_subw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_subw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_subw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_subw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_subw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_subw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_subw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_subw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_subw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_subw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_subw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sub a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-; 64-bit sll is a safe choice for an anyext result.
-
-define i32 @aext_sllw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sllw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sllw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sllw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sllw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sllw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sllw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sllw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sllw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sllw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sllw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: Select sllw for all cases witha signext result.
-
-define signext i32 @sext_sllw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sllw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sllw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sllw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sllw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sllw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sllw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sllw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sllw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sllw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sllw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-; 64-bit sll followed by zero-extension for a zeroext result.
-
-define zeroext i32 @zext_sllw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sllw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sllw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sllw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sllw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sllw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sllw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sllw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sllw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sllw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sllw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: srlw should be selected for 32-bit lshr with variable arguments.
-
-define i32 @aext_srlw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_srlw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_srlw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_srlw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_srlw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_srlw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_srlw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_srlw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_srlw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_srlw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_srlw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_srlw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_srlw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_srlw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_srlw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_srlw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_srlw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_srlw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_srlw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_srlw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_srlw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_srlw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_srlw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_srlw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_srlw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_srlw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_srlw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_srlw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_srlw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srlw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_srlw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-; TODO: sraw should be selected if the first operand is not sign-extended. If the
-; first operand is sign-extended, sra is equivalent for the test cases below.
-
-define i32 @aext_sraw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sraw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sraw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sraw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sraw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sraw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sraw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: aext_sraw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: aext_sraw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @aext_sraw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: aext_sraw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sraw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sraw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sraw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sraw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sraw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sraw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: sext_sraw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: sext_sraw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define signext i32 @sext_sraw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: sext_sraw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_aext_aext(i32 %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sraw_aext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_aext_sext(i32 %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sraw_aext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_aext_zext(i32 %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sraw_aext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_sext_aext(i32 signext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sraw_sext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_sext_sext(i32 signext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sraw_sext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_sext_zext(i32 signext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sraw_sext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_zext_aext(i32 zeroext %a, i32 %b) nounwind {
-; RV64I-LABEL: zext_sraw_zext_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_zext_sext(i32 zeroext %a, i32 signext %b) nounwind {
-; RV64I-LABEL: zext_sraw_zext_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraw_zext_zext(i32 zeroext %a, i32 zeroext %b) nounwind {
-; RV64I-LABEL: zext_sraw_zext_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-; addiw should be selected when there is a signext result.
-
-define i32 @aext_addiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: aext_addiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @aext_addiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: aext_addiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 2
-  ret i32 %1
-}
-
-define i32 @aext_addiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: aext_addiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 3
-  ret i32 %1
-}
-
-define signext i32 @sext_addiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: sext_addiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addiw a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 4
-  ret i32 %1
-}
-
-define signext i32 @sext_addiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: sext_addiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addiw a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 5
-  ret i32 %1
-}
-
-define signext i32 @sext_addiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: sext_addiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addiw a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 6
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: zext_addiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 7
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 7
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: zext_addiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 8
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 8
-  ret i32 %1
-}
-
-define zeroext i32 @zext_addiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: zext_addiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    addi a0, a0, 9
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = add i32 %a, 9
-  ret i32 %1
-}
-
-; slliw should be selected whenever the return is signext.
-
-define i32 @aext_slliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: aext_slliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @aext_slliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: aext_slliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 2
-  ret i32 %1
-}
-
-define i32 @aext_slliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: aext_slliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 3
-  ret i32 %1
-}
-
-define signext i32 @sext_slliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: sext_slliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slliw a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 4
-  ret i32 %1
-}
-
-define signext i32 @sext_slliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: sext_slliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slliw a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 5
-  ret i32 %1
-}
-
-define signext i32 @sext_slliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: sext_slliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slliw a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 6
-  ret i32 %1
-}
-
-; TODO: the constant shifts could be combined.
-
-define zeroext i32 @zext_slliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: zext_slliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 7
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 7
-  ret i32 %1
-}
-
-define zeroext i32 @zext_slliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: zext_slliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 8
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 8
-  ret i32 %1
-}
-
-define zeroext i32 @zext_slliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: zext_slliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 9
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = shl i32 %a, 9
-  ret i32 %1
-}
-
-; srliw should be selected unless the first operand is zeroext, when srli is
-; equivalent.
-
-define i32 @aext_srliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: aext_srliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @aext_srliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: aext_srliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 2
-  ret i32 %1
-}
-
-define i32 @aext_srliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: aext_srliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srli a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 3
-  ret i32 %1
-}
-
-define signext i32 @sext_srliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: sext_srliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 4
-  ret i32 %1
-}
-
-define signext i32 @sext_srliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: sext_srliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 5
-  ret i32 %1
-}
-
-define signext i32 @sext_srliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: sext_srliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srli a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 6
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srliw_aext(i32 %a) nounwind {
-; RV64I-LABEL: zext_srliw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 7
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 7
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srliw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: zext_srliw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srliw a0, a0, 8
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 8
-  ret i32 %1
-}
-
-define zeroext i32 @zext_srliw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: zext_srliw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srli a0, a0, 9
-; RV64I-NEXT:    ret
-  %1 = lshr i32 %a, 9
-  ret i32 %1
-}
-
-; srai is equivalent to sraiw if the first operand is sign-extended.
-
-define i32 @aext_sraiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: aext_sraiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @aext_sraiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: aext_sraiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srai a0, a0, 2
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 2
-  ret i32 %1
-}
-
-define i32 @aext_sraiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: aext_sraiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 3
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 3
-  ret i32 %1
-}
-
-define signext i32 @sext_sraiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: sext_sraiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 4
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 4
-  ret i32 %1
-}
-
-define signext i32 @sext_sraiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: sext_sraiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srai a0, a0, 5
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 5
-  ret i32 %1
-}
-
-define signext i32 @sext_sraiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: sext_sraiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sraiw a0, a0, 6
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 6
-  ret i32 %1
-}
-
-; TODO: sraiw could be selected rather than sext.w and srli. Alternatively,
-; the srli could be merged in to the shifts used for zero-extension.
-
-define zeroext i32 @zext_sraiw_aext(i32 %a) nounwind {
-; RV64I-LABEL: zext_sraiw_aext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    srli a0, a0, 7
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 7
-  ret i32 %1
-}
-
-define zeroext i32 @zext_sraiw_sext(i32 signext %a) nounwind {
-; RV64I-LABEL: zext_sraiw_sext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    srli a0, a0, 8
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 8
-  ret i32 %1
-}
-
-; TODO: sraiw could be selected rather than sext.w and srli. Alternatively,
-; the srli could be merged in to the shifts used for zero-extension.
-
-define zeroext i32 @zext_sraiw_zext(i32 zeroext %a) nounwind {
-; RV64I-LABEL: zext_sraiw_zext:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    srli a0, a0, 9
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = ashr i32 %a, 9
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/rv64i-tricky-shifts.ll b/test/CodeGen/RISCV/rv64i-tricky-shifts.ll
deleted file mode 100644
index 73eeed7553c..00000000000
--- a/test/CodeGen/RISCV/rv64i-tricky-shifts.ll
+++ /dev/null
@@ -1,44 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-; These tests must not compile to sllw/srlw/sraw, as this would be semantically
-; incorrect in the case that %b holds a value between 32 and 63. Selection
-; patterns might make the mistake of assuming that a (sext_inreg foo, i32) can
-; only be produced when sign-extending an i32 type.
-
-define i64 @tricky_shl(i64 %a, i64 %b) {
-; RV64I-LABEL: tricky_shl:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sll a0, a0, a1
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = shl i64 %a, %b
-  %2 = shl i64 %1, 32
-  %3 = ashr i64 %2, 32
-  ret i64 %3
-}
-
-define i64 @tricky_lshr(i64 %a, i64 %b) {
-; RV64I-LABEL: tricky_lshr:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    srl a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = and i64 %a, 4294967295
-  %2 = lshr i64 %1, %b
-  ret i64 %2
-}
-
-define i64 @tricky_ashr(i64 %a, i64 %b) {
-; RV64I-LABEL: tricky_ashr:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    sra a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = shl i64 %a, 32
-  %2 = ashr i64 %1, 32
-  %3 = ashr i64 %2, %b
-  ret i64 %3
-}
diff --git a/test/CodeGen/RISCV/select-cc.ll b/test/CodeGen/RISCV/select-cc.ll
deleted file mode 100644
index 96eb6ff1010..00000000000
--- a/test/CodeGen/RISCV/select-cc.ll
+++ /dev/null
@@ -1,100 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -disable-block-placement -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define i32 @foo(i32 %a, i32 *%b) {
-; RV32I-LABEL: foo:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    beq a0, a2, .LBB0_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_2:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bne a0, a2, .LBB0_4
-; RV32I-NEXT:  # %bb.3:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_4:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bltu a2, a0, .LBB0_6
-; RV32I-NEXT:  # %bb.5:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_6:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bgeu a0, a2, .LBB0_8
-; RV32I-NEXT:  # %bb.7:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_8:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bltu a0, a2, .LBB0_10
-; RV32I-NEXT:  # %bb.9:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_10:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bgeu a2, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.11:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_12:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    blt a2, a0, .LBB0_14
-; RV32I-NEXT:  # %bb.13:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_14:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bge a0, a2, .LBB0_16
-; RV32I-NEXT:  # %bb.15:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_16:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    blt a0, a2, .LBB0_18
-; RV32I-NEXT:  # %bb.17:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_18:
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    bge a1, a0, .LBB0_20
-; RV32I-NEXT:  # %bb.19:
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:  .LBB0_20:
-; RV32I-NEXT:    ret
-  %val1 = load volatile i32, i32* %b
-  %tst1 = icmp eq i32 %a, %val1
-  %val2 = select i1 %tst1, i32 %a, i32 %val1
-
-  %val3 = load volatile i32, i32* %b
-  %tst2 = icmp ne i32 %val2, %val3
-  %val4 = select i1 %tst2, i32 %val2, i32 %val3
-
-  %val5 = load volatile i32, i32* %b
-  %tst3 = icmp ugt i32 %val4, %val5
-  %val6 = select i1 %tst3, i32 %val4, i32 %val5
-
-  %val7 = load volatile i32, i32* %b
-  %tst4 = icmp uge i32 %val6, %val7
-  %val8 = select i1 %tst4, i32 %val6, i32 %val7
-
-  %val9 = load volatile i32, i32* %b
-  %tst5 = icmp ult i32 %val8, %val9
-  %val10 = select i1 %tst5, i32 %val8, i32 %val9
-
-  %val11 = load volatile i32, i32* %b
-  %tst6 = icmp ule i32 %val10, %val11
-  %val12 = select i1 %tst6, i32 %val10, i32 %val11
-
-  %val13 = load volatile i32, i32* %b
-  %tst7 = icmp sgt i32 %val12, %val13
-  %val14 = select i1 %tst7, i32 %val12, i32 %val13
-
-  %val15 = load volatile i32, i32* %b
-  %tst8 = icmp sge i32 %val14, %val15
-  %val16 = select i1 %tst8, i32 %val14, i32 %val15
-
-  %val17 = load volatile i32, i32* %b
-  %tst9 = icmp slt i32 %val16, %val17
-  %val18 = select i1 %tst9, i32 %val16, i32 %val17
-
-  %val19 = load volatile i32, i32* %b
-  %tst10 = icmp sle i32 %val18, %val19
-  %val20 = select i1 %tst10, i32 %val18, i32 %val19
-
-  ret i32 %val20
-}
diff --git a/test/CodeGen/RISCV/sext-zext-trunc.ll b/test/CodeGen/RISCV/sext-zext-trunc.ll
deleted file mode 100644
index 280c68e2ab4..00000000000
--- a/test/CodeGen/RISCV/sext-zext-trunc.ll
+++ /dev/null
@@ -1,438 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV64I
-
-define i8 @sext_i1_to_i8(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i1_to_i8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    neg a0, a0
-; RV64I-NEXT:    ret
-  %1 = sext i1 %a to i8
-  ret i8 %1
-}
-
-define i16 @sext_i1_to_i16(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i1_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    neg a0, a0
-; RV64I-NEXT:    ret
-  %1 = sext i1 %a to i16
-  ret i16 %1
-}
-
-define i32 @sext_i1_to_i32(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i1_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    neg a0, a0
-; RV64I-NEXT:    ret
-  %1 = sext i1 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i1_to_i64(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i1_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    neg a0, a0
-; RV64I-NEXT:    ret
-  %1 = sext i1 %a to i64
-  ret i64 %1
-}
-
-define i16 @sext_i8_to_i16(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i8_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    ret
-  %1 = sext i8 %a to i16
-  ret i16 %1
-}
-
-define i32 @sext_i8_to_i32(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i8_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i8_to_i64(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a0, a1, 24
-; RV32I-NEXT:    srai a1, a1, 31
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i8_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 56
-; RV64I-NEXT:    srai a0, a0, 56
-; RV64I-NEXT:    ret
-  %1 = sext i8 %a to i64
-  ret i64 %1
-}
-
-define i32 @sext_i16_to_i32(i16 %a) {
-; RV32I-LABEL: sext_i16_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 16
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i16_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 48
-; RV64I-NEXT:    ret
-  %1 = sext i16 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i16_to_i64(i16 %a) {
-; RV32I-LABEL: sext_i16_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a0, a1, 16
-; RV32I-NEXT:    srai a1, a1, 31
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i16_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 48
-; RV64I-NEXT:    srai a0, a0, 48
-; RV64I-NEXT:    ret
-  %1 = sext i16 %a to i64
-  ret i64 %1
-}
-
-define i64 @sext_i32_to_i64(i32 %a) {
-; RV32I-LABEL: sext_i32_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: sext_i32_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    sext.w a0, a0
-; RV64I-NEXT:    ret
-  %1 = sext i32 %a to i64
-  ret i64 %1
-}
-
-define i8 @zext_i1_to_i8(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i1_to_i8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = zext i1 %a to i8
-  ret i8 %1
-}
-
-define i16 @zext_i1_to_i16(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i1_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = zext i1 %a to i16
-  ret i16 %1
-}
-
-define i32 @zext_i1_to_i32(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i1_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = zext i1 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i1_to_i64(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i1_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 1
-; RV64I-NEXT:    ret
-  %1 = zext i1 %a to i64
-  ret i64 %1
-}
-
-define i16 @zext_i8_to_i16(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i8_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    ret
-  %1 = zext i8 %a to i16
-  ret i16 %1
-}
-
-define i32 @zext_i8_to_i32(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i8_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i8_to_i64(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i8_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    andi a0, a0, 255
-; RV64I-NEXT:    ret
-  %1 = zext i8 %a to i64
-  ret i64 %1
-}
-
-define i32 @zext_i16_to_i32(i16 %a) {
-; RV32I-LABEL: zext_i16_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i16_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a1, 16
-; RV64I-NEXT:    addiw a1, a1, -1
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = zext i16 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i16_to_i64(i16 %a) {
-; RV32I-LABEL: zext_i16_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i16_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    lui a1, 16
-; RV64I-NEXT:    addiw a1, a1, -1
-; RV64I-NEXT:    and a0, a0, a1
-; RV64I-NEXT:    ret
-  %1 = zext i16 %a to i64
-  ret i64 %1
-}
-
-define i64 @zext_i32_to_i64(i32 %a) {
-; RV32I-LABEL: zext_i32_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: zext_i32_to_i64:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    slli a0, a0, 32
-; RV64I-NEXT:    srli a0, a0, 32
-; RV64I-NEXT:    ret
-  %1 = zext i32 %a to i64
-  ret i64 %1
-}
-
-define i1 @trunc_i8_to_i1(i8 %a) {
-; RV32I-LABEL: trunc_i8_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i8_to_i1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i8 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i16_to_i1(i16 %a) {
-; RV32I-LABEL: trunc_i16_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i16_to_i1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i16 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i32_to_i1(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i32_to_i1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i32 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i64_to_i1(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i64_to_i1:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i64 %a to i1
-  ret i1 %1
-}
-
-define i8 @trunc_i16_to_i8(i16 %a) {
-; RV32I-LABEL: trunc_i16_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i16_to_i8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i16 %a to i8
-  ret i8 %1
-}
-
-define i8 @trunc_i32_to_i8(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i32_to_i8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define i8 @trunc_i64_to_i8(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i64_to_i8:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i64 %a to i8
-  ret i8 %1
-}
-
-define i16 @trunc_i32_to_i16(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i32_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i32 %a to i16
-  ret i16 %1
-}
-
-define i16 @trunc_i64_to_i16(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i64_to_i16:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i64 %a to i16
-  ret i16 %1
-}
-
-define i32 @trunc_i64_to_i32(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-;
-; RV64I-LABEL: trunc_i64_to_i32:
-; RV64I:       # %bb.0:
-; RV64I-NEXT:    ret
-  %1 = trunc i64 %a to i32
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/shift-masked-shamt.ll b/test/CodeGen/RISCV/shift-masked-shamt.ll
deleted file mode 100644
index 5c77aa2d77f..00000000000
--- a/test/CodeGen/RISCV/shift-masked-shamt.ll
+++ /dev/null
@@ -1,70 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; This test checks that unnecessary masking of shift amount operands is
-; eliminated during instruction selection. The test needs to ensure that the
-; masking is not removed if it may affect the shift amount.
-
-define i32 @sll_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sll_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 31
-  %2 = shl i32 %a, %1
-  ret i32 %2
-}
-
-define i32 @sll_non_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sll_non_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a1, a1, 15
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 15
-  %2 = shl i32 %a, %1
-  ret i32 %2
-}
-
-define i32 @srl_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srl_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 4095
-  %2 = lshr i32 %a, %1
-  ret i32 %2
-}
-
-define i32 @srl_non_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srl_non_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a1, a1, 7
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 7
-  %2 = lshr i32 %a, %1
-  ret i32 %2
-}
-
-define i32 @sra_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sra_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 65535
-  %2 = ashr i32 %a, %1
-  ret i32 %2
-}
-
-define i32 @sra_non_redundant_mask(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sra_non_redundant_mask:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a1, a1, 32
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %b, 32
-  %2 = ashr i32 %a, %1
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/shifts.ll b/test/CodeGen/RISCV/shifts.ll
deleted file mode 100644
index 4aa66b0b63c..00000000000
--- a/test/CodeGen/RISCV/shifts.ll
+++ /dev/null
@@ -1,45 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Basic shift support is tested as part of ALU.ll. This file ensures that
-; shifts which may not be supported natively are lowered properly.
-
-define i64 @lshr64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: lshr64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __lshrdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = lshr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @ashr64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: ashr64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __ashrdi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = ashr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @shl64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: shl64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    call __ashldi3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = shl i64 %a, %b
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/tail-calls.ll b/test/CodeGen/RISCV/tail-calls.ll
deleted file mode 100644
index 4d7db01d1fb..00000000000
--- a/test/CodeGen/RISCV/tail-calls.ll
+++ /dev/null
@@ -1,148 +0,0 @@
-; RUN: llc -mtriple riscv32-unknown-linux-gnu -o - %s | FileCheck %s
-; RUN: llc -mtriple riscv32-unknown-elf       -o - %s | FileCheck %s
-
-; Perform tail call optimization for global address.
-declare i32 @callee_tail(i32 %i)
-define i32 @caller_tail(i32 %i) {
-; CHECK-LABEL: caller_tail
-; CHECK: tail callee_tail
-entry:
-  %r = tail call i32 @callee_tail(i32 %i)
-  ret i32 %r
-}
-
-; Perform tail call optimization for external symbol.
-@dest = global [2 x i8] zeroinitializer
-declare void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)
-define void @caller_extern(i8* %src) optsize {
-entry:
-; CHECK: caller_extern
-; CHECK-NOT: call memcpy
-; CHECK: tail memcpy
-  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @dest, i32 0, i32 0), i8* %src, i32 7, i1 false)
-  ret void
-}
-
-; Perform indirect tail call optimization (for function pointer call).
-declare void @callee_indirect1()
-declare void @callee_indirect2()
-define void @caller_indirect_tail(i32 %a) {
-; CHECK-LABEL: caller_indirect_tail
-; CHECK-NOT: call callee_indirect1
-; CHECK-NOT: call callee_indirect2
-; CHECK-NOT: tail callee_indirect1
-; CHECK-NOT: tail callee_indirect2
-
-; CHECK: lui a0, %hi(callee_indirect2)
-; CHECK-NEXT: addi a5, a0, %lo(callee_indirect2)
-; CHECK-NEXT: jr a5
-
-; CHECK: lui a0, %hi(callee_indirect1)
-; CHECK-NEXT: addi a5, a0, %lo(callee_indirect1)
-; CHECK-NEXT: jr a5
-entry:
-  %tobool = icmp eq i32 %a, 0
-  %callee = select i1 %tobool, void ()* @callee_indirect1, void ()* @callee_indirect2
-  tail call void %callee()
-  ret void
-}
-
-; Do not tail call optimize functions with varargs.
-declare i32 @callee_varargs(i32, ...)
-define void @caller_varargs(i32 %a, i32 %b) {
-; CHECK-LABEL: caller_varargs
-; CHECK-NOT: tail callee_varargs
-; CHECK: call callee_varargs
-entry:
-  %call = tail call i32 (i32, ...) @callee_varargs(i32 %a, i32 %b, i32 %b, i32 %a)
-  ret void
-}
-
-; Do not tail call optimize if stack is used to pass parameters.
-declare i32 @callee_args(i32 %a, i32 %b, i32 %c, i32 %dd, i32 %e, i32 %ff, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n)
-define i32 @caller_args(i32 %a, i32 %b, i32 %c, i32 %dd, i32 %e, i32 %ff, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n) {
-; CHECK-LABEL: caller_args
-; CHECK-NOT: tail callee_args
-; CHECK: call callee_args
-entry:
-  %r = tail call i32 @callee_args(i32 %a, i32 %b, i32 %c, i32 %dd, i32 %e, i32 %ff, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n)
-  ret i32 %r
-}
-
-; Do not tail call optimize if parameters need to be passed indirectly.
-declare i32 @callee_indirect_args(fp128 %a)
-define void @caller_indirect_args() {
-; CHECK-LABEL: caller_indirect_args
-; CHECK-NOT: tail callee_indirect_args
-; CHECK: call callee_indirect_args
-entry:
-  %call = tail call i32 @callee_indirect_args(fp128 0xL00000000000000003FFF000000000000)
-  ret void
-}
-
-; Externally-defined functions with weak linkage should not be tail-called.
-; The behaviour of branch instructions in this situation (as used for tail
-; calls) is implementation-defined, so we cannot rely on the linker replacing
-; the tail call with a return.
-declare extern_weak void @callee_weak()
-define void @caller_weak() {
-; CHECK-LABEL: caller_weak
-; CHECK-NOT: tail callee_weak
-; CHECK: call callee_weak
-entry:
-  tail call void @callee_weak()
-  ret void
-}
-
-; Exception-handling functions need a special set of instructions to indicate a
-; return to the hardware. Tail-calling another function would probably break
-; this.
-declare void @callee_irq()
-define void @caller_irq() #0 {
-; CHECK-LABEL: caller_irq
-; CHECK-NOT: tail callee_irq
-; CHECK: call callee_irq
-entry:
-  tail call void @callee_irq()
-  ret void
-}
-attributes #0 = { "interrupt"="machine" }
-
-; Byval parameters hand the function a pointer directly into the stack area
-; we want to reuse during a tail call. Do not tail call optimize functions with
-; byval parameters.
-declare i32 @callee_byval(i32** byval %a)
-define i32 @caller_byval() {
-; CHECK-LABEL: caller_byval
-; CHECK-NOT: tail callee_byval
-; CHECK: call callee_byval
-entry:
-  %a = alloca i32*
-  %r = tail call i32 @callee_byval(i32** byval %a)
-  ret i32 %r
-}
-
-; Do not tail call optimize if callee uses structret semantics.
-%struct.A = type { i32 }
-@a = global %struct.A zeroinitializer
-
-declare void @callee_struct(%struct.A* sret %a)
-define void @caller_nostruct() {
-; CHECK-LABEL: caller_nostruct
-; CHECK-NOT: tail callee_struct
-; CHECK: call callee_struct
-entry:
-  tail call void @callee_struct(%struct.A* sret @a)
-  ret void
-}
-
-; Do not tail call optimize if caller uses structret semantics.
-declare void @callee_nostruct()
-define void @caller_struct(%struct.A* sret %a) {
-; CHECK-LABEL: caller_struct
-; CHECK-NOT: tail callee_nostruct
-; CHECK: call callee_nostruct
-entry:
-  tail call void @callee_nostruct()
-  ret void
-}
diff --git a/test/CodeGen/RISCV/umulo-128-legalisation-lowering.ll b/test/CodeGen/RISCV/umulo-128-legalisation-lowering.ll
deleted file mode 100644
index d00208ef680..00000000000
--- a/test/CodeGen/RISCV/umulo-128-legalisation-lowering.ll
+++ /dev/null
@@ -1,138 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc < %s -mtriple=riscv32 -mattr=+m | FileCheck %s --check-prefixes=RISCV32
-
-define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {
-; RISCV32-LABEL: muloti_test:
-; RISCV32:       # %bb.0: # %start
-; RISCV32-NEXT:    addi sp, sp, -96
-; RISCV32-NEXT:    sw ra, 92(sp)
-; RISCV32-NEXT:    sw s1, 88(sp)
-; RISCV32-NEXT:    sw s2, 84(sp)
-; RISCV32-NEXT:    sw s3, 80(sp)
-; RISCV32-NEXT:    sw s4, 76(sp)
-; RISCV32-NEXT:    sw s5, 72(sp)
-; RISCV32-NEXT:    sw s6, 68(sp)
-; RISCV32-NEXT:    sw s7, 64(sp)
-; RISCV32-NEXT:    sw s8, 60(sp)
-; RISCV32-NEXT:    mv s3, a2
-; RISCV32-NEXT:    mv s1, a1
-; RISCV32-NEXT:    mv s2, a0
-; RISCV32-NEXT:    mv s4, zero
-; RISCV32-NEXT:    sw zero, 20(sp)
-; RISCV32-NEXT:    sw zero, 16(sp)
-; RISCV32-NEXT:    sw zero, 36(sp)
-; RISCV32-NEXT:    sw zero, 32(sp)
-; RISCV32-NEXT:    lw s5, 4(a2)
-; RISCV32-NEXT:    sw s5, 12(sp)
-; RISCV32-NEXT:    lw s7, 0(a2)
-; RISCV32-NEXT:    sw s7, 8(sp)
-; RISCV32-NEXT:    lw s6, 4(a1)
-; RISCV32-NEXT:    sw s6, 28(sp)
-; RISCV32-NEXT:    lw s8, 0(a1)
-; RISCV32-NEXT:    sw s8, 24(sp)
-; RISCV32-NEXT:    addi a0, sp, 40
-; RISCV32-NEXT:    addi a1, sp, 24
-; RISCV32-NEXT:    addi a2, sp, 8
-; RISCV32-NEXT:    call __multi3
-; RISCV32-NEXT:    lw t2, 12(s1)
-; RISCV32-NEXT:    lw a1, 8(s1)
-; RISCV32-NEXT:    mul a0, s5, a1
-; RISCV32-NEXT:    mul a2, t2, s7
-; RISCV32-NEXT:    add a0, a2, a0
-; RISCV32-NEXT:    lw t3, 12(s3)
-; RISCV32-NEXT:    lw a3, 8(s3)
-; RISCV32-NEXT:    mul a2, s6, a3
-; RISCV32-NEXT:    mul a4, t3, s8
-; RISCV32-NEXT:    add a2, a4, a2
-; RISCV32-NEXT:    mul a4, a3, s8
-; RISCV32-NEXT:    mul a5, a1, s7
-; RISCV32-NEXT:    add a4, a5, a4
-; RISCV32-NEXT:    sltu a5, a4, a5
-; RISCV32-NEXT:    mulhu a6, a3, s8
-; RISCV32-NEXT:    add a7, a6, a2
-; RISCV32-NEXT:    mulhu t0, a1, s7
-; RISCV32-NEXT:    add t1, t0, a0
-; RISCV32-NEXT:    add a0, t1, a7
-; RISCV32-NEXT:    add a2, a0, a5
-; RISCV32-NEXT:    lw a0, 52(sp)
-; RISCV32-NEXT:    add a5, a0, a2
-; RISCV32-NEXT:    lw a2, 48(sp)
-; RISCV32-NEXT:    add t4, a2, a4
-; RISCV32-NEXT:    sltu s1, t4, a2
-; RISCV32-NEXT:    add a4, a5, s1
-; RISCV32-NEXT:    beq a4, a0, .LBB0_2
-; RISCV32-NEXT:  # %bb.1: # %start
-; RISCV32-NEXT:    sltu s1, a4, a0
-; RISCV32-NEXT:  .LBB0_2: # %start
-; RISCV32-NEXT:    xor a0, a4, a0
-; RISCV32-NEXT:    xor a2, t4, a2
-; RISCV32-NEXT:    or a0, a2, a0
-; RISCV32-NEXT:    beq a0, s4, .LBB0_4
-; RISCV32-NEXT:  # %bb.3: # %start
-; RISCV32-NEXT:    mv s4, s1
-; RISCV32-NEXT:  .LBB0_4: # %start
-; RISCV32-NEXT:    snez a0, s5
-; RISCV32-NEXT:    snez a2, t2
-; RISCV32-NEXT:    and a0, a2, a0
-; RISCV32-NEXT:    snez a2, s6
-; RISCV32-NEXT:    snez a5, t3
-; RISCV32-NEXT:    and a2, a5, a2
-; RISCV32-NEXT:    mulhu a5, t3, s8
-; RISCV32-NEXT:    snez a5, a5
-; RISCV32-NEXT:    or a2, a2, a5
-; RISCV32-NEXT:    mulhu a5, t2, s7
-; RISCV32-NEXT:    snez a5, a5
-; RISCV32-NEXT:    or a0, a0, a5
-; RISCV32-NEXT:    sltu t0, t1, t0
-; RISCV32-NEXT:    mulhu s1, s5, a1
-; RISCV32-NEXT:    snez s1, s1
-; RISCV32-NEXT:    or a0, a0, s1
-; RISCV32-NEXT:    sltu s1, a7, a6
-; RISCV32-NEXT:    mulhu a5, s6, a3
-; RISCV32-NEXT:    snez a5, a5
-; RISCV32-NEXT:    or a2, a2, a5
-; RISCV32-NEXT:    lw a5, 44(sp)
-; RISCV32-NEXT:    sw a5, 4(s2)
-; RISCV32-NEXT:    lw a5, 40(sp)
-; RISCV32-NEXT:    sw a5, 0(s2)
-; RISCV32-NEXT:    sw t4, 8(s2)
-; RISCV32-NEXT:    sw a4, 12(s2)
-; RISCV32-NEXT:    or a2, a2, s1
-; RISCV32-NEXT:    or a0, a0, t0
-; RISCV32-NEXT:    or a1, a1, t2
-; RISCV32-NEXT:    or a3, a3, t3
-; RISCV32-NEXT:    snez a3, a3
-; RISCV32-NEXT:    snez a1, a1
-; RISCV32-NEXT:    and a1, a1, a3
-; RISCV32-NEXT:    or a0, a1, a0
-; RISCV32-NEXT:    or a0, a0, a2
-; RISCV32-NEXT:    or a0, a0, s4
-; RISCV32-NEXT:    andi a0, a0, 1
-; RISCV32-NEXT:    sb a0, 16(s2)
-; RISCV32-NEXT:    lw s8, 60(sp)
-; RISCV32-NEXT:    lw s7, 64(sp)
-; RISCV32-NEXT:    lw s6, 68(sp)
-; RISCV32-NEXT:    lw s5, 72(sp)
-; RISCV32-NEXT:    lw s4, 76(sp)
-; RISCV32-NEXT:    lw s3, 80(sp)
-; RISCV32-NEXT:    lw s2, 84(sp)
-; RISCV32-NEXT:    lw s1, 88(sp)
-; RISCV32-NEXT:    lw ra, 92(sp)
-; RISCV32-NEXT:    addi sp, sp, 96
-; RISCV32-NEXT:    ret
-start:
-  %0 = tail call { i128, i1 } @llvm.umul.with.overflow.i128(i128 %l, i128 %r) #2
-  %1 = extractvalue { i128, i1 } %0, 0
-  %2 = extractvalue { i128, i1 } %0, 1
-  %3 = zext i1 %2 to i8
-  %4 = insertvalue { i128, i8 } undef, i128 %1, 0
-  %5 = insertvalue { i128, i8 } %4, i8 %3, 1
-  ret { i128, i8 } %5
-}
-
-; Function Attrs: nounwind readnone speculatable
-declare { i128, i1 } @llvm.umul.with.overflow.i128(i128, i128) #1
-
-attributes #0 = { nounwind readnone uwtable }
-attributes #1 = { nounwind readnone speculatable }
-attributes #2 = { nounwind }
diff --git a/test/CodeGen/RISCV/vararg.ll b/test/CodeGen/RISCV/vararg.ll
deleted file mode 100644
index 77f8f300956..00000000000
--- a/test/CodeGen/RISCV/vararg.ll
+++ /dev/null
@@ -1,819 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-declare void @llvm.va_start(i8*)
-declare void @llvm.va_end(i8*)
-
-declare void @notdead(i8*)
-
-; Although frontends are recommended to not generate va_arg due to the lack of
-; support for aggregate types, we test simple cases here to ensure they are
-; lowered correctly
-
-define i32 @va1(i8* %fmt, ...) nounwind {
-; RV32I-FPELIM-LABEL: va1:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 24
-; RV32I-FPELIM-NEXT:    sw a1, 12(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 8
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    sw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %argp.cur = load i8*, i8** %va, align 4
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur, i32 4
-  store i8* %argp.next, i8** %va, align 4
-  %2 = bitcast i8* %argp.cur to i32*
-  %3 = load i32, i32* %2, align 4
-  call void @llvm.va_end(i8* %1)
-  ret i32 %3
-}
-
-define i32 @va1_va_arg(i8* %fmt, ...) nounwind {
-; RV32I-FPELIM-LABEL: va1_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 24
-; RV32I-FPELIM-NEXT:    sw a1, 12(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 8
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    sw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
-
-; Ensure the adjustment when restoring the stack pointer using the frame
-; pointer is correct
-define i32 @va1_va_arg_alloca(i8* %fmt, ...) nounwind {
-; RV32I-FPELIM-LABEL: va1_va_arg_alloca:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    sw s0, 8(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 4(sp)
-; RV32I-FPELIM-NEXT:    addi s0, sp, 16
-; RV32I-FPELIM-NEXT:    mv s1, a1
-; RV32I-FPELIM-NEXT:    sw a7, 28(s0)
-; RV32I-FPELIM-NEXT:    sw a6, 24(s0)
-; RV32I-FPELIM-NEXT:    sw a5, 20(s0)
-; RV32I-FPELIM-NEXT:    sw a4, 16(s0)
-; RV32I-FPELIM-NEXT:    sw a3, 12(s0)
-; RV32I-FPELIM-NEXT:    sw a2, 8(s0)
-; RV32I-FPELIM-NEXT:    addi a0, s0, 8
-; RV32I-FPELIM-NEXT:    sw a0, -16(s0)
-; RV32I-FPELIM-NEXT:    sw a1, 4(s0)
-; RV32I-FPELIM-NEXT:    addi a0, a1, 15
-; RV32I-FPELIM-NEXT:    andi a0, a0, -16
-; RV32I-FPELIM-NEXT:    sub a0, sp, a0
-; RV32I-FPELIM-NEXT:    mv sp, a0
-; RV32I-FPELIM-NEXT:    call notdead
-; RV32I-FPELIM-NEXT:    mv a0, s1
-; RV32I-FPELIM-NEXT:    addi sp, s0, -16
-; RV32I-FPELIM-NEXT:    lw s1, 4(sp)
-; RV32I-FPELIM-NEXT:    lw s0, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_va_arg_alloca:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    mv s1, a1
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, a1, 15
-; RV32I-WITHFP-NEXT:    andi a0, a0, -16
-; RV32I-WITHFP-NEXT:    sub a0, sp, a0
-; RV32I-WITHFP-NEXT:    mv sp, a0
-; RV32I-WITHFP-NEXT:    call notdead
-; RV32I-WITHFP-NEXT:    mv a0, s1
-; RV32I-WITHFP-NEXT:    addi sp, s0, -16
-; RV32I-WITHFP-NEXT:    lw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  %3 = alloca i8, i32 %2
-  call void @notdead(i8* %3)
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
-
-define void @va1_caller() nounwind {
-; Pass a double, as a float would be promoted by a C/C++ frontend
-; RV32I-FPELIM-LABEL: va1_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a3, 261888
-; RV32I-FPELIM-NEXT:    addi a4, zero, 2
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    call va1
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a3, 261888
-; RV32I-WITHFP-NEXT:    addi a4, zero, 2
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    call va1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 (i8*, ...) @va1(i8* undef, double 1.0, i32 2)
-  ret void
-}
-
-; Ensure that 2x xlen size+alignment varargs are accessed via an "aligned"
-; register pair (where the first register is even-numbered).
-
-define double @va2(i8 *%fmt, ...) nounwind {
-; RV32I-FPELIM-LABEL: va2:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 35
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 27
-; RV32I-FPELIM-NEXT:    andi a1, a0, -8
-; RV32I-FPELIM-NEXT:    lw a0, 0(a1)
-; RV32I-FPELIM-NEXT:    ori a1, a1, 4
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 19
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a1, a0, -8
-; RV32I-WITHFP-NEXT:    lw a0, 0(a1)
-; RV32I-WITHFP-NEXT:    ori a1, a1, 4
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = bitcast i8** %va to i32*
-  %argp.cur = load i32, i32* %2, align 4
-  %3 = add i32 %argp.cur, 7
-  %4 = and i32 %3, -8
-  %argp.cur.aligned = inttoptr i32 %3 to i8*
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
-  store i8* %argp.next, i8** %va, align 4
-  %5 = inttoptr i32 %4 to double*
-  %6 = load double, double* %5, align 8
-  call void @llvm.va_end(i8* %1)
-  ret double %6
-}
-
-define double @va2_va_arg(i8 *%fmt, ...) nounwind {
-; RV32I-FPELIM-LABEL: va2_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 27
-; RV32I-FPELIM-NEXT:    andi a0, a0, -8
-; RV32I-FPELIM-NEXT:    ori a1, a0, 4
-; RV32I-FPELIM-NEXT:    sw a1, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a2, a1, 4
-; RV32I-FPELIM-NEXT:    sw a2, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a0, a0, -8
-; RV32I-WITHFP-NEXT:    ori a1, a0, 4
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a2, a1, 4
-; RV32I-WITHFP-NEXT:    sw a2, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, double
-  call void @llvm.va_end(i8* %1)
-  ret double %2
-}
-
-define void @va2_caller() nounwind {
-; RV32I-FPELIM-LABEL: va2_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a3, 261888
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    call va2
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a3, 261888
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    call va2
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
- %1 = call double (i8*, ...) @va2(i8* undef, double 1.000000e+00)
- ret void
-}
-
-; Ensure a named double argument is passed in a1 and a2, while the vararg
-; double is passed in a4 and a5 (rather than a3 and a4)
-
-define double @va3(i32 %a, double %b, ...) nounwind {
-; RV32I-FPELIM-LABEL: va3:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    mv t0, a2
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 27
-; RV32I-FPELIM-NEXT:    sw a1, 0(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 19
-; RV32I-FPELIM-NEXT:    andi a1, a1, -8
-; RV32I-FPELIM-NEXT:    lw a2, 0(a1)
-; RV32I-FPELIM-NEXT:    ori a1, a1, 4
-; RV32I-FPELIM-NEXT:    lw a3, 0(a1)
-; RV32I-FPELIM-NEXT:    mv a1, t0
-; RV32I-FPELIM-NEXT:    call __adddf3
-; RV32I-FPELIM-NEXT:    lw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 24
-; RV32I-WITHFP-NEXT:    mv t0, a2
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    sw a7, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 19
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 11
-; RV32I-WITHFP-NEXT:    andi a1, a1, -8
-; RV32I-WITHFP-NEXT:    lw a2, 0(a1)
-; RV32I-WITHFP-NEXT:    ori a1, a1, 4
-; RV32I-WITHFP-NEXT:    lw a3, 0(a1)
-; RV32I-WITHFP-NEXT:    mv a1, t0
-; RV32I-WITHFP-NEXT:    call __adddf3
-; RV32I-WITHFP-NEXT:    lw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = bitcast i8** %va to i32*
-  %argp.cur = load i32, i32* %2, align 4
-  %3 = add i32 %argp.cur, 7
-  %4 = and i32 %3, -8
-  %argp.cur.aligned = inttoptr i32 %3 to i8*
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
-  store i8* %argp.next, i8** %va, align 4
-  %5 = inttoptr i32 %4 to double*
-  %6 = load double, double* %5, align 8
-  call void @llvm.va_end(i8* %1)
-  %7 = fadd double %b, %6
-  ret double %7
-}
-
-define double @va3_va_arg(i32 %a, double %b, ...) nounwind {
-; RV32I-FPELIM-LABEL: va3_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    mv t0, a2
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 19
-; RV32I-FPELIM-NEXT:    andi a1, a1, -8
-; RV32I-FPELIM-NEXT:    ori a3, a1, 4
-; RV32I-FPELIM-NEXT:    sw a3, 0(sp)
-; RV32I-FPELIM-NEXT:    lw a2, 0(a1)
-; RV32I-FPELIM-NEXT:    addi a1, a3, 4
-; RV32I-FPELIM-NEXT:    sw a1, 0(sp)
-; RV32I-FPELIM-NEXT:    lw a3, 0(a3)
-; RV32I-FPELIM-NEXT:    mv a1, t0
-; RV32I-FPELIM-NEXT:    call __adddf3
-; RV32I-FPELIM-NEXT:    lw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 24
-; RV32I-WITHFP-NEXT:    mv t0, a2
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    sw a7, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 11
-; RV32I-WITHFP-NEXT:    andi a1, a1, -8
-; RV32I-WITHFP-NEXT:    ori a3, a1, 4
-; RV32I-WITHFP-NEXT:    sw a3, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a2, 0(a1)
-; RV32I-WITHFP-NEXT:    addi a1, a3, 4
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a3, 0(a3)
-; RV32I-WITHFP-NEXT:    mv a1, t0
-; RV32I-WITHFP-NEXT:    call __adddf3
-; RV32I-WITHFP-NEXT:    lw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, double
-  call void @llvm.va_end(i8* %1)
-  %3 = fadd double %b, %2
-  ret double %3
-}
-
-define void @va3_caller() nounwind {
-; RV32I-FPELIM-LABEL: va3_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 2
-; RV32I-FPELIM-NEXT:    lui a2, 261888
-; RV32I-FPELIM-NEXT:    lui a5, 262144
-; RV32I-FPELIM-NEXT:    mv a1, zero
-; RV32I-FPELIM-NEXT:    mv a4, zero
-; RV32I-FPELIM-NEXT:    call va3
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 2
-; RV32I-WITHFP-NEXT:    lui a2, 261888
-; RV32I-WITHFP-NEXT:    lui a5, 262144
-; RV32I-WITHFP-NEXT:    mv a1, zero
-; RV32I-WITHFP-NEXT:    mv a4, zero
-; RV32I-WITHFP-NEXT:    call va3
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
- %1 = call double (i32, double, ...) @va3(i32 2, double 1.000000e+00, double 2.000000e+00)
- ret void
-}
-
-declare void @llvm.va_copy(i8*, i8*)
-
-define i32 @va4_va_copy(i32 %argno, ...) nounwind {
-; RV32I-FPELIM-LABEL: va4_va_copy:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    mv s1, a1
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    call notdead
-; RV32I-FPELIM-NEXT:    lw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 3
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a1, a0, 4
-; RV32I-FPELIM-NEXT:    sw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 7
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a2, a0, 4
-; RV32I-FPELIM-NEXT:    sw a2, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a2, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 7
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a3, a0, 4
-; RV32I-FPELIM-NEXT:    sw a3, 4(sp)
-; RV32I-FPELIM-NEXT:    add a1, a1, s1
-; RV32I-FPELIM-NEXT:    add a1, a1, a2
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va4_va_copy:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    mv s1, a1
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    call notdead
-; RV32I-WITHFP-NEXT:    lw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 3
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a1, a0, 4
-; RV32I-WITHFP-NEXT:    sw a1, -16(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 7
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a2, a0, 4
-; RV32I-WITHFP-NEXT:    sw a2, -16(s0)
-; RV32I-WITHFP-NEXT:    lw a2, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 7
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a3, a0, 4
-; RV32I-WITHFP-NEXT:    sw a3, -16(s0)
-; RV32I-WITHFP-NEXT:    add a1, a1, s1
-; RV32I-WITHFP-NEXT:    add a1, a1, a2
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %vargs = alloca i8*, align 4
-  %wargs = alloca i8*, align 4
-  %1 = bitcast i8** %vargs to i8*
-  %2 = bitcast i8** %wargs to i8*
-  call void @llvm.va_start(i8* %1)
-  %3 = va_arg i8** %vargs, i32
-  call void @llvm.va_copy(i8* %2, i8* %1)
-  %4 = load i8*, i8** %wargs, align 4
-  call void @notdead(i8* %4)
-  %5 = va_arg i8** %vargs, i32
-  %6 = va_arg i8** %vargs, i32
-  %7 = va_arg i8** %vargs, i32
-  call void @llvm.va_end(i8* %1)
-  call void @llvm.va_end(i8* %2)
-  %add1 = add i32 %5, %3
-  %add2 = add i32 %add1, %6
-  %add3 = add i32 %add2, %7
-  ret i32 %add3
-}
-
-; Check 2x*xlen values are aligned appropriately when passed on the stack in a vararg call
-
-define i32 @va5_aligned_stack_callee(i32 %a, ...) nounwind {
-; RV32I-FPELIM-LABEL: va5_aligned_stack_callee:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 8(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va5_aligned_stack_callee:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  ret i32 1
-}
-
-define void @va5_aligned_stack_caller() nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-FPELIM-LABEL: va5_aligned_stack_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 17
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 16
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 15
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262236
-; RV32I-FPELIM-NEXT:    addi a0, a0, 655
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 377487
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1475
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 14
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262153
-; RV32I-FPELIM-NEXT:    addi a0, a0, 491
-; RV32I-FPELIM-NEXT:    sw a0, 44(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 545260
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1967
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 964690
-; RV32I-FPELIM-NEXT:    addi a0, a0, -328
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 335544
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1311
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 688509
-; RV32I-FPELIM-NEXT:    addi a6, a0, -2048
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 11
-; RV32I-FPELIM-NEXT:    addi a2, sp, 32
-; RV32I-FPELIM-NEXT:    addi a3, zero, 12
-; RV32I-FPELIM-NEXT:    addi a4, zero, 13
-; RV32I-FPELIM-NEXT:    addi a7, zero, 4
-; RV32I-FPELIM-NEXT:    call va5_aligned_stack_callee
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va5_aligned_stack_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, zero, 17
-; RV32I-WITHFP-NEXT:    sw a0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 16
-; RV32I-WITHFP-NEXT:    sw a0, 20(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 15
-; RV32I-WITHFP-NEXT:    sw a0, 16(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262236
-; RV32I-WITHFP-NEXT:    addi a0, a0, 655
-; RV32I-WITHFP-NEXT:    sw a0, 12(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 377487
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1475
-; RV32I-WITHFP-NEXT:    sw a0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 14
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262153
-; RV32I-WITHFP-NEXT:    addi a0, a0, 491
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 545260
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1967
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 964690
-; RV32I-WITHFP-NEXT:    addi a0, a0, -328
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 335544
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1311
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 688509
-; RV32I-WITHFP-NEXT:    addi a6, a0, -2048
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 11
-; RV32I-WITHFP-NEXT:    addi a2, s0, -32
-; RV32I-WITHFP-NEXT:    addi a3, zero, 12
-; RV32I-WITHFP-NEXT:    addi a4, zero, 13
-; RV32I-WITHFP-NEXT:    addi a7, zero, 4
-; RV32I-WITHFP-NEXT:    call va5_aligned_stack_callee
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 (i32, ...) @va5_aligned_stack_callee(i32 1, i32 11,
-    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13, i64 20000000000,
-    i32 14, double 2.720000e+00, i32 15, [2 x i32] [i32 16, i32 17])
-  ret void
-}
-
-; A function with no fixed arguments is not valid C, but can be
-; specified in LLVM IR. We must ensure the vararg save area is
-; still set up correctly.
-
-define i32 @va6_no_fixed_args(...) nounwind {
-; RV32I-FPELIM-LABEL: va6_no_fixed_args:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a1, sp, 20
-; RV32I-FPELIM-NEXT:    sw a1, 12(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va6_no_fixed_args:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a1, s0, 4
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    sw a0, 0(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/wide-mem.ll b/test/CodeGen/RISCV/wide-mem.ll
deleted file mode 100644
index 02aae215fce..00000000000
--- a/test/CodeGen/RISCV/wide-mem.ll
+++ /dev/null
@@ -1,30 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Check load/store operations on values wider than what is natively supported
-
-define i64 @load_i64(i64 *%a) nounwind {
-; RV32I-LABEL: load_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = load i64, i64* %a
-  ret i64 %1
-}
-
-@val64 = local_unnamed_addr global i64 2863311530, align 8
-
-define i64 @load_i64_global() nounwind {
-; RV32I-LABEL: load_i64_global:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, %hi(val64)
-; RV32I-NEXT:    lw a0, %lo(val64)(a1)
-; RV32I-NEXT:    addi a1, a1, %lo(val64)
-; RV32I-NEXT:    lw a1, 4(a1)
-; RV32I-NEXT:    ret
-  %1 = load i64, i64* @val64
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/zext-with-load-is-free.ll b/test/CodeGen/RISCV/zext-with-load-is-free.ll
deleted file mode 100644
index 9ea4c36a866..00000000000
--- a/test/CodeGen/RISCV/zext-with-load-is-free.ll
+++ /dev/null
@@ -1,76 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; TODO: lbu and lhu should be selected to avoid the unnecessary masking.
-
-@bytes = global [5 x i8] zeroinitializer, align 1
-
-define i32 @test_zext_i8() {
-; RV32I-LABEL: test_zext_i8:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lui a0, %hi(bytes)
-; RV32I-NEXT:    lbu a1, %lo(bytes)(a0)
-; RV32I-NEXT:    addi a2, zero, 136
-; RV32I-NEXT:    bne a1, a2, .LBB0_3
-; RV32I-NEXT:  # %bb.1: # %entry
-; RV32I-NEXT:    addi a0, a0, %lo(bytes)
-; RV32I-NEXT:    lbu a0, 1(a0)
-; RV32I-NEXT:    addi a1, zero, 7
-; RV32I-NEXT:    bne a0, a1, .LBB0_3
-; RV32I-NEXT:  # %bb.2: # %if.end
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_3: # %if.then
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    ret
-entry:
-  %0 = load i8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @bytes, i32 0, i32 0), align 1
-  %cmp = icmp eq i8 %0, -120
-  %1 = load i8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @bytes, i32 0, i32 1), align 1
-  %cmp3 = icmp eq i8 %1, 7
-  %or.cond = and i1 %cmp, %cmp3
-  br i1 %or.cond, label %if.end, label %if.then
-
-if.then:
-  ret i32 1
-
-if.end:
-  ret i32 0
-}
-
-@shorts = global [5 x i16] zeroinitializer, align 2
-
-define i32 @test_zext_i16() {
-; RV32I-LABEL: test_zext_i16:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lui a0, %hi(shorts)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -120
-; RV32I-NEXT:    lhu a2, %lo(shorts)(a0)
-; RV32I-NEXT:    bne a2, a1, .LBB1_3
-; RV32I-NEXT:  # %bb.1: # %entry
-; RV32I-NEXT:    addi a0, a0, %lo(shorts)
-; RV32I-NEXT:    lhu a0, 2(a0)
-; RV32I-NEXT:    addi a1, zero, 7
-; RV32I-NEXT:    bne a0, a1, .LBB1_3
-; RV32I-NEXT:  # %bb.2: # %if.end
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB1_3: # %if.then
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    ret
-entry:
-  %0 = load i16, i16* getelementptr inbounds ([5 x i16], [5 x i16]* @shorts, i32 0, i32 0), align 2
-  %cmp = icmp eq i16 %0, -120
-  %1 = load i16, i16* getelementptr inbounds ([5 x i16], [5 x i16]* @shorts, i32 0, i32 1), align 2
-  %cmp3 = icmp eq i16 %1, 7
-  %or.cond = and i1 %cmp, %cmp3
-  br i1 %or.cond, label %if.end, label %if.then
-
-if.then:
-  ret i32 1
-
-if.end:
-  ret i32 0
-}
diff --git a/test/DebugInfo/RISCV/lit.local.cfg b/test/DebugInfo/RISCV/lit.local.cfg
deleted file mode 100644
index c63820126f8..00000000000
--- a/test/DebugInfo/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
diff --git a/test/DebugInfo/RISCV/relax-debug-line.ll b/test/DebugInfo/RISCV/relax-debug-line.ll
deleted file mode 100644
index 814b253fadf..00000000000
--- a/test/DebugInfo/RISCV/relax-debug-line.ll
+++ /dev/null
@@ -1,75 +0,0 @@
-; RUN: llc -filetype=obj -mtriple=riscv32 -mattr=+relax %s -o - \
-; RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX %s
-;
-; RELAX: .rela.debug_line {
-; RELAX: R_RISCV_ADD16
-; RELAX: R_RISCV_SUB16
-source_filename = "line.c"
-
-; Function Attrs: noinline nounwind optnone
-define i32 @init() !dbg !7 {
-entry:
-  ret i32 0, !dbg !11
-}
-
-; Function Attrs: noinline nounwind optnone
-define i32 @foo(i32 signext %value) !dbg !12 {
-entry:
-  %value.addr = alloca i32, align 4
-  store i32 %value, i32* %value.addr, align 4
-  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !15, metadata !DIExpression()), !dbg !16
-  %0 = load i32, i32* %value.addr, align 4, !dbg !17
-  ret i32 %0, !dbg !18
-}
-
-; Function Attrs: nounwind readnone speculatable
-declare void @llvm.dbg.declare(metadata, metadata, metadata)
-
-; Function Attrs: noinline nounwind optnone
-define i32 @bar() !dbg !19 {
-entry:
-  %result = alloca i32, align 4
-  %v = alloca i32, align 4
-  call void @llvm.dbg.declare(metadata i32* %result, metadata !20, metadata !DIExpression()), !dbg !21
-  call void @llvm.dbg.declare(metadata i32* %v, metadata !22, metadata !DIExpression()), !dbg !23
-  %call = call i32 @init(), !dbg !24
-  store i32 %call, i32* %v, align 4, !dbg !23
-  %0 = load i32, i32* %v, align 4, !dbg !25
-  %call1 = call i32 @foo(i32 signext %0), !dbg !26
-  store i32 %call1, i32* %result, align 4, !dbg !27
-  %1 = load i32, i32* %result, align 4, !dbg !28
-  ret i32 %1, !dbg !29
-}
-
-!llvm.dbg.cu = !{!0}
-!llvm.module.flags = !{!3, !4, !5}
-
-!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
-!1 = !DIFile(filename: "line.c", directory: "./")
-!2 = !{}
-!3 = !{i32 2, !"Dwarf Version", i32 4}
-!4 = !{i32 2, !"Debug Info Version", i32 3}
-!5 = !{i32 1, !"wchar_size", i32 4}
-!7 = distinct !DISubprogram(name: "init", scope: !1, file: !1, line: 1, type: !8, isLocal: false, isDefinition: true, scopeLine: 2, isOptimized: false, unit: !0, retainedNodes: !2)
-!8 = !DISubroutineType(types: !9)
-!9 = !{!10}
-!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
-!11 = !DILocation(line: 3, column: 3, scope: !7)
-!12 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 6, type: !13, isLocal: false, isDefinition: true, scopeLine: 7, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
-!13 = !DISubroutineType(types: !14)
-!14 = !{!10, !10}
-!15 = !DILocalVariable(name: "value", arg: 1, scope: !12, file: !1, line: 6, type: !10)
-!16 = !DILocation(line: 6, column: 13, scope: !12)
-!17 = !DILocation(line: 8, column: 10, scope: !12)
-!18 = !DILocation(line: 8, column: 3, scope: !12)
-!19 = distinct !DISubprogram(name: "bar", scope: !1, file: !1, line: 11, type: !8, isLocal: false, isDefinition: true, scopeLine: 12, isOptimized: false, unit: !0, retainedNodes: !2)
-!20 = !DILocalVariable(name: "result", scope: !19, file: !1, line: 13, type: !10)
-!21 = !DILocation(line: 13, column: 7, scope: !19)
-!22 = !DILocalVariable(name: "v", scope: !19, file: !1, line: 14, type: !10)
-!23 = !DILocation(line: 14, column: 7, scope: !19)
-!24 = !DILocation(line: 14, column: 11, scope: !19)
-!25 = !DILocation(line: 16, column: 16, scope: !19)
-!26 = !DILocation(line: 16, column: 12, scope: !19)
-!27 = !DILocation(line: 16, column: 10, scope: !19)
-!28 = !DILocation(line: 18, column: 10, scope: !19)
-!29 = !DILocation(line: 18, column: 3, scope: !19)
diff --git a/test/MC/Disassembler/RISCV/fuzzer-invalid.txt b/test/MC/Disassembler/RISCV/fuzzer-invalid.txt
deleted file mode 100644
index d90172d3d34..00000000000
--- a/test/MC/Disassembler/RISCV/fuzzer-invalid.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-# RUN: not llvm-mc -disassemble -triple=riscv32 < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -disassemble -triple=riscv64 < %s 2>&1 | FileCheck %s
-#
-# Test generated by a LLVM MC Disassembler Protocol Buffer Fuzzer
-# for the RISC-V assembly language.
-
-[0xf9 0x95 0xab 0x99]
-# CHECK: warning: invalid instruction encoding
diff --git a/test/MC/Disassembler/RISCV/invalid-fp-rounding-mode.txt b/test/MC/Disassembler/RISCV/invalid-fp-rounding-mode.txt
deleted file mode 100644
index f675f532ae5..00000000000
--- a/test/MC/Disassembler/RISCV/invalid-fp-rounding-mode.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -disassemble -triple=riscv32 -mattr=+f,+d < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -disassemble -triple=riscv64 -mattr=+f,+d < %s 2>&1 | FileCheck %s
-#
-# Test generated by a LLVM MC Disassembler Protocol Buffer Fuzzer
-# for the RISC-V assembly language.
-
-# This decodes as fadd.s  ft0, ft0, ft0 with unknown floating point rounding mode
-[0x53 0x50 0x00 0x00]
-# CHECK: warning: invalid instruction encoding
diff --git a/test/MC/Disassembler/RISCV/invalid-instruction.txt b/test/MC/Disassembler/RISCV/invalid-instruction.txt
deleted file mode 100644
index 79e73e243d1..00000000000
--- a/test/MC/Disassembler/RISCV/invalid-instruction.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -disassemble -triple=riscv32 -mattr=+c < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -disassemble -triple=riscv64 -mattr=+c < %s 2>&1 | FileCheck %s
-#
-# Test generated by a LLVM MC Disassembler Protocol Buffer Fuzzer
-# for the RISC-V assembly language.
-
-# This should not decode as c.addi16sp with 0 imm when compression is enabled.
-[0x01 0x61]
-# CHECK: warning: invalid instruction encoding
diff --git a/test/MC/Disassembler/RISCV/lit.local.cfg b/test/MC/Disassembler/RISCV/lit.local.cfg
deleted file mode 100644
index d0b081e3e8b..00000000000
--- a/test/MC/Disassembler/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,3 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
-
diff --git a/test/MC/Disassembler/RISCV/unknown-fence-field.txt b/test/MC/Disassembler/RISCV/unknown-fence-field.txt
deleted file mode 100644
index 5b20994dcb6..00000000000
--- a/test/MC/Disassembler/RISCV/unknown-fence-field.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: llvm-mc -disassemble -triple=riscv32 < %s 2>&1 | FileCheck %s
-# RUN: llvm-mc -disassemble -triple=riscv64 < %s 2>&1 | FileCheck %s
-#
-# Test generated by a LLVM MC Disassembler Protocol Buffer Fuzzer
-# for the RISC-V assembly language.
-
-# This decodes as fence , iorw with invalid fence field as 0.
-[0x0f 0x00 0xf0 0x00]
-# CHECK: fence unknown, iorw
diff --git a/test/MC/RISCV/cnop.s b/test/MC/RISCV/cnop.s
deleted file mode 100644
index 1ac75ec7892..00000000000
--- a/test/MC/RISCV/cnop.s
+++ /dev/null
@@ -1,27 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases  - | FileCheck -check-prefix=CHECK-INST %s
-
-# alpha and main are 8 byte alignment
-# but the alpha function's size is 6
-# So assembler will insert a c.nop to make sure 8 byte alignment.
-
-        .text
-       .p2align        3
-       .type   alpha,@function
-alpha:
-# BB#0:
-       c.addi  sp, -16
-       c.lw    a0, 0(a0)
-       c.lw    a1, 4(a0)
-# CHECK-INST: c.nop
-.Lfunc_end0:
-       .size   alpha, .Lfunc_end0-alpha
-                                        # -- End function
-       .globl  main
-       .p2align        3
-       .type   main,@function
-main:                                   # @main
-# BB#0:
-.Lfunc_end1:
-       .size   main, .Lfunc_end1-main
-                                        # -- End function
diff --git a/test/MC/RISCV/compress-cjal.s b/test/MC/RISCV/compress-cjal.s
deleted file mode 100644
index a77297f6947..00000000000
--- a/test/MC/RISCV/compress-cjal.s
+++ /dev/null
@@ -1,17 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# c.jal is an rv32 only instruction.
-jal ra, 2046
-# CHECK-BYTES: fd 2f
-# CHECK-ALIAS: jal 2046
-# CHECK-INST: c.jal 2046
-# CHECK:  # encoding: [0xfd,0x2f]
diff --git a/test/MC/RISCV/compress-rv32d.s b/test/MC/RISCV/compress-rv32d.s
deleted file mode 100644
index eac0321778e..00000000000
--- a/test/MC/RISCV/compress-rv32d.s
+++ /dev/null
@@ -1,44 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+d -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+d -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+d -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c,+d -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+d -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c,+d -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# RUN: llvm-mc -triple riscv64 -mattr=+c,+d -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c,+d -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c,+d -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c,+d -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c,+d -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c,+d -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# Tests double precision floating point instructions available in rv32 and in rv64.
-
-fld ft0, 64(sp)
-# CHECK-BYTES: 06 20
-# CHECK-ALIAS: fld ft0, 64(sp)
-# CHECK-INST: c.fldsp ft0, 64(sp)
-# CHECK: # encoding:  [0x06,0x20]
-fsd ft0, 64(sp)
-# CHECK-BYTES: 82 a0
-# CHECK-ALIAS: fsd ft0, 64(sp)
-# CHECK-INST: c.fsdsp ft0, 64(sp)
-# CHECK: # encoding:  [0x82,0xa0]
-fld fs0, 248(s0)
-# CHECK-BYTES: 60 3c
-# CHECK-ALIAS: fld fs0, 248(s0)
-# CHECK-INST: c.fld fs0, 248(s0)
-# CHECK: # encoding:  [0x60,0x3c]
-fsd fs0, 248(s0)
-# CHECK-BYTES: 60 bc
-# CHECK-ALIAS: fsd fs0, 248(s0)
-# CHECK-INST: c.fsd fs0, 248(s0)
-# CHECK: # encoding:  [0x60,0xbc]
diff --git a/test/MC/RISCV/compress-rv32f.s b/test/MC/RISCV/compress-rv32f.s
deleted file mode 100644
index 482e528c9ee..00000000000
--- a/test/MC/RISCV/compress-rv32f.s
+++ /dev/null
@@ -1,32 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+f -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+f -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+f -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c,+f -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c,+f -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c,+f -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# Instructions that are 32 bit only.
-flw ft0, 124(sp)
-# CHECK-BYTES: 76 70
-# CHECK-ALIAS: flw     ft0, 124(sp)
-# CHECK-INST: c.flwsp ft0, 124(sp)
-# CHECK:  # encoding: [0x76,0x70]
-fsw ft0, 124(sp)
-# CHECK-BYTES: 82 fe
-# CHECK-ALIAS: fsw ft0, 124(sp)
-# CHECK-INST: c.fswsp ft0, 124(sp)
-# CHECK:  # encoding: [0x82,0xfe]
-flw fs0, 124(s0)
-# CHECK-BYTES: 60 7c
-# CHECK-ALIAS: flw fs0, 124(s0)
-# CHECK-INST: c.flw fs0, 124(s0)
-# CHECK:  # encoding:  [0x60,0x7c]
-fsw fs0, 124(s0)
-# CHECK-BYTES: 60 fc
-# CHECK-ALIAS: fsw fs0, 124(s0)
-# CHECK-INST: c.fsw fs0, 124(s0)
-# CHECK:  # encoding:  [0x60,0xfc]
diff --git a/test/MC/RISCV/compress-rv32i.s b/test/MC/RISCV/compress-rv32i.s
deleted file mode 100644
index 149279c4330..00000000000
--- a/test/MC/RISCV/compress-rv32i.s
+++ /dev/null
@@ -1,219 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# RUN: llvm-mc -triple riscv64 -mattr=+c -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# CHECK-BYTES: 2e 85
-# CHECK-ALIAS: add a0, zero, a1
-# CHECK-INST: c.mv a0, a1
-# CHECK: # encoding:  [0x2e,0x85]
-addi a0, a1, 0
-
-# CHECK-BYTES: e0 1f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: c.addi4spn s0, sp, 1020
-# CHECK: # encoding:  [0xe0,0x1f]
-addi s0, sp, 1020
-
-# CHECK-BYTES: e0 5f
-# CHECK-ALIAS: lw s0, 124(a5)
-# CHECK-INST: c.lw s0, 124(a5)
-# CHECK: # encoding: [0xe0,0x5f]
-lw s0, 124(a5)
-
-# CHECK-BYTES: e0 df
-# CHECK-ALIAS: sw s0, 124(a5)
-# CHECK-INST: c.sw s0, 124(a5)
-# CHECK: # encoding: [0xe0,0xdf]
-sw s0, 124(a5)
-
-# CHECK-BYTES: 01 00
-# CHECK-ALIAS: nop
-# CHECK-INST: c.nop
-# CHECK: # encoding: [0x01,0x00]
-nop
-
-# CHECK-BYTES: 81 10
-# CHECK-ALIAS: addi ra, ra, -32
-# CHECK-INST: c.addi ra, -32
-# CHECK: # encoding:  [0x81,0x10]
-addi ra, ra, -32
-
-# CHECK-BYTES: 85 50
-# CHECK-ALIAS: addi ra, zero, -31
-# CHECK-INST: c.li ra, -31
-# CHECK: # encoding: [0x85,0x50]
-addi ra, zero, -31
-
-# CHECK-BYTES: 39 71
-# CHECK-ALIAS: addi sp, sp, -64
-# CHECK-INST: c.addi16sp sp, -64
-# CHECK:  # encoding: [0x39,0x71]
-addi sp, sp, -64
-
-# CHECK-BYTES: fd 61
-# CHECK-ALIAS: lui gp, 31
-# CHECK-INST: c.lui gp, 31
-# CHECK: # encoding:  [0xfd,0x61]
-lui gp, 31
-
-# CHECK-BYTES: 7d 80
-# CHECK-ALIAS: srli s0, s0, 31
-# CHECK-INST: c.srli s0, 31
-# CHECK: # encoding:  [0x7d,0x80]
-srli s0, s0, 31
-
-# CHECK-BYTES: 7d 84
-# CHECK-ALIAS: srai s0, s0, 31
-# CHECK-INST: c.srai s0, 31
-# CHECK: # encoding: [0x7d,0x84]
-srai s0, s0, 31
-
-# CHECK-BYTES: 7d 88
-# CHECK-ALIAS: andi s0, s0, 31
-# CHECK-INST: c.andi s0, 31
-# CHECK: # encoding: [0x7d,0x88]
-andi s0, s0, 31
-
-# CHECK-BYTES: 1d 8c
-# CHECK-ALIAS: sub s0, s0, a5
-# CHECK-INST: c.sub s0, a5
-# CHECK: # encoding: [0x1d,0x8c]
-sub s0, s0, a5
-
-# CHECK-BYTES: 3d 8c
-# CHECK-ALIAS: xor s0, s0, a5
-# CHECK-INST: c.xor s0, a5
-# CHECK: # encoding: [0x3d,0x8c]
-xor s0, s0, a5
-
-# CHECK-BYTES: 3d 8c
-# CHECK-ALIAS: xor s0, s0, a5
-# CHECK-INST: c.xor s0, a5
-# CHECK: # encoding: [0x3d,0x8c]
-xor s0, a5, s0
-
-# CHECK-BYTES: 5d 8c
-# CHECK-ALIAS: or s0, s0, a5
-# CHECK-INST: c.or s0, a5
-# CHECK: # encoding:  [0x5d,0x8c]
-or s0, s0, a5
-
-# CHECK-BYTES: 45 8c
-# CHECK-ALIAS: or s0, s0, s1
-# CHECK-INST: c.or s0, s1
-# CHECK:  # encoding: [0x45,0x8c]
-or  s0, s1, s0
-
-# CHECK-BYTES: 7d 8c
-# CHECK-ALIAS: and s0, s0, a5
-# CHECK-INST: c.and s0, a5
-# CHECK: # encoding: [0x7d,0x8c]
-and s0, s0, a5
-
-# CHECK-BYTES: 7d 8c
-# CHECK-ALIAS: and s0, s0, a5
-# CHECK-INST: c.and s0, a5
-# CHECK: # encoding: [0x7d,0x8c]
-and s0, a5, s0
-
-# CHECK-BYTES: 01 b0
-# CHECK-ALIAS: j -2048
-# CHECK-INST: c.j -2048
-# CHECK:  # encoding: [0x01,0xb0]
-jal zero, -2048
-
-# CHECK-BYTES: 01 d0
-# CHECK-ALIAS: beqz s0, -256
-# CHECK-INST: c.beqz s0, -256
-# CHECK: # encoding: [0x01,0xd0]
-beq s0, zero, -256
-
-# CHECK-BYTES: 7d ec
-# CHECk-ALIAS: bnez s0, 254
-# CHECK-INST: c.bnez s0, 254
-# CHECK: # encoding: [0x7d,0xec]
-bne s0, zero, 254
-
-# CHECK-BYTES: 7e 04
-# CHECK-ALIAS: slli s0, s0, 31
-# CHECK-INST: c.slli s0, 31
-# CHECK: # encoding:  [0x7e,0x04]
-slli s0, s0, 31
-
-# CHECK-BYTES: fe 50
-# CHECK-ALIAS: lw ra, 252(sp)
-# CHECK-INST: c.lwsp  ra, 252(sp)
-# CHECK: # encoding:  [0xfe,0x50]
-lw ra, 252(sp)
-
-# CHECK-BYTES: 82 80
-# CHECK-ALIAS: ret
-# CHECK-INST: c.jr ra
-# CHECK: # encoding:  [0x82,0x80]
-jalr zero, ra, 0
-
-# CHECK-BYTES: 92 80
-# CHECK-ALIAS: add ra, zero, tp
-# CHECK-INST: c.mv ra, tp
-# CHECK:  # encoding: [0x92,0x80]
-add ra, zero, tp
-
-# CHECK-BYTES: 92 80
-# CHECK-ALIAS: add ra, zero, tp
-# CHECK-INST: c.mv ra, tp
-# CHECK:  # encoding: [0x92,0x80]
-add ra, tp, zero
-
-# CHECK-BYTES: 02 90
-# CHECK-ALIAS: ebreak
-# CHECK-INST: c.ebreak
-# CHECK: # encoding: [0x02,0x90]
-ebreak
-
-# CHECK-BYTES: 02 94
-# CHECK-ALIAS: jalr s0
-# CHECK-INST: c.jalr s0
-# CHECK: # encoding: [0x02,0x94]
-jalr ra, s0, 0
-
-# CHECK-BYTES: 3e 94
-# CHECK-ALIAS: add s0, s0, a5
-# CHECK-INST: c.add s0, a5
-# CHECK: # encoding:  [0x3e,0x94]
-add s0, a5, s0
-
-# CHECK-BYTES: 3e 94
-# CHECK-ALIAS: add s0, s0, a5
-# CHECK-INST: c.add s0, a5
-# CHECK: # encoding:  [0x3e,0x94]
-add s0, s0, a5
-
-# CHECK-BYTES: 82 df
-# CHECK-ALIAS: sw zero, 252(sp)
-# CHECK-INST: c.swsp zero, 252(sp)
-# CHECK: # encoding: [0x82,0xdf]
-sw zero, 252(sp)
-
-# CHECK-BYTES: 00 00
-# CHECK-ALIAS: unimp
-# CHECK-INST: c.unimp
-# CHECK: # encoding: [0x00,0x00]
-unimp
diff --git a/test/MC/RISCV/compress-rv64i.s b/test/MC/RISCV/compress-rv64i.s
deleted file mode 100644
index 7e887ff80d6..00000000000
--- a/test/MC/RISCV/compress-rv64i.s
+++ /dev/null
@@ -1,60 +0,0 @@
-# RUN: llvm-mc -triple riscv64 -mattr=+c -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -mattr=+c -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# Tests compressed instructions available in rv64 and not in rv32.
-
-# CHECK-BYTES: e0 7f
-# CHECK-ALIAS: ld s0, 248(a5)
-# CHECK-INST: c.ld s0, 248(a5)
-# CHECK: # encoding: [0xe0,0x7f]
-ld s0, 248(a5)
-
-# CHECK-BYTES: a0 e3
-# CHECK-ALIAS: sd s0, 64(a5)
-# CHECK-INST: c.sd s0, 64(a5)
-# CHECK: # encoding: [0xa0,0xe3]
-sd s0, 64(a5)
-
-# CHECK-BYTES: 7d 22
-# CHEACK-ALIAS: addiw tp, tp, 31
-# CHECK-INST: c.addiw  tp, 31
-# CHECK: # encoding: [0x7d,0x22]
-addiw tp, tp, 31
-
-# CHECK-BYTES: 1d 9c
-# CHEACK-ALIAS: subw s0, s0, a5
-# CHECK-INST: c.subw s0, a5
-# CHECK: # encoding:  [0x1d,0x9c]
-subw s0, s0, a5
-
-# CHECK-BYTES: 3d 9c
-# CHECK-ALIAS: addw s0, s0, a5
-# CHECK-INST: c.addw s0, a5
-# CHECK: # encoding: [0x3d,0x9c]
-addw s0, s0, a5
-
-# CHECK-BYTES: 3d 9c
-# CHECK-ALIAS: addw s0, s0, a5
-# CHECK-INST: c.addw s0, a5
-# CHECK: # encoding: [0x3d,0x9c]
-addw s0, a5, s0
-
-# CHECK-BYTES: ee 70
-# CHECK-ALIAS: ld ra, 248(sp)
-# CHECK-INST: c.ldsp ra, 248(sp)
-# CHECK: # encoding:  [0xee,0x70]
-ld ra, 248(sp)
-
-# CHECK-BYTES: a2 e0
-# CHECK-ALIAS: sd s0, 64(sp)
-# CHECK-INST: c.sdsp s0, 64(sp)
-# CHECK: # encoding: [0xa2,0xe0]
-sd s0, 64(sp)
diff --git a/test/MC/RISCV/compressed-relocations.s b/test/MC/RISCV/compressed-relocations.s
deleted file mode 100644
index 31c398ef84e..00000000000
--- a/test/MC/RISCV/compressed-relocations.s
+++ /dev/null
@@ -1,22 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c -riscv-no-aliases < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=INSTR -check-prefix=FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c,+relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-
-# Check prefixes:
-# RELOC - Check the relocation in the object.
-# FIXUP - Check the fixup on the instruction.
-# INSTR - Check the instruction is handled properly by the ASMPrinter
-c.jal foo
-# A compressed jump (c.j) to an unresolved symbol will be relaxed to a (jal).
-# RELOC: R_RISCV_JAL
-# INSTR: c.jal foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_rvc_jump
-
-c.bnez a0, foo
-# A compressed branch (c.bnez) to an unresolved symbol will be relaxed to a (bnez).
-# RELOC: R_RISCV_BRANCH
-# INSTR: c.bnez a0, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_rvc_branch
diff --git a/test/MC/RISCV/csr-aliases.s b/test/MC/RISCV/csr-aliases.s
deleted file mode 100644
index 473ce71ccce..00000000000
--- a/test/MC/RISCV/csr-aliases.s
+++ /dev/null
@@ -1,117 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-
-
-# CHECK-INST: csrrs t0, fcsr, zero
-# CHECK-ALIAS: frcsr t0
-# CHECK-EXT-F:  frcsr t0
-# CHECK-EXT-F-OFF: csrr t0, 3
-csrrs t0, 3, zero
-
-# CHECK-INST: csrrw t1, fcsr, t2
-# CHECK-ALIAS: fscsr t1, t2
-# CHECK-EXT-F-ON: fscsr t1, t2
-# CHECK-EXT-F-OFF: csrrw t1, 3, t2
-csrrw t1, 3, t2
-
-# CHECK-INST: csrrw zero, fcsr, t2
-# CHECK-ALIAS: fscsr t2
-# CHECK-EXT-F-ON: fscsr t2
-# CHECK-EXT-F-OFF: csrw 3, t2
-csrrw zero, 3, t2
-
-# CHECK-INST: csrrw zero, fcsr, t2
-# CHECK-ALIAS: fscsr t2
-# CHECK-EXT-F-ON: fscsr t2
-# CHECK-EXT-F-OFF: csrw 3, t2
-csrrw zero, 3, t2
-
-# CHECK-INST: csrrw t0, frm, zero
-# CHECK-ALIAS: fsrm  t0, zero
-# CHECK-EXT-F-ON: fsrm t0, zero
-# CHECK-EXT-F-OFF: csrrw t0, 2, zero
-csrrw t0, 2, zero
-
-# CHECK-INST: csrrw t0, frm, t1
-# CHECK-ALIAS: fsrm t0, t1
-# CHECK-EXT-F-ON: fsrm t0, t1
-# CHECK-EXT-F-OFF: csrrw t0, 2, t1
-csrrw t0, 2, t1
-
-# CHECK-INST: csrrwi t0, frm, 31
-# CHECK-ALIAS: fsrmi t0, 31
-# CHECK-EXT-F-ON: fsrmi t0, 31
-# CHECK-EXT-F-OFF: csrrwi t0, 2, 31
-csrrwi t0, 2, 31
-
-# CHECK-INST: csrrwi zero, frm, 31
-# CHECK-ALIAS: fsrmi 31
-# CHECK-EXT-F-ON: fsrmi 31
-# CHECK-EXT-F-OFF:  csrwi 2, 31
-csrrwi zero, 2, 31
-
-# CHECK-INST: csrrs t0, fflags, zero
-# CHECK-ALIAS: frflags t0
-# CHECK-EXT-F-ON: frflags t0
-# CHECK-EXT-F-OFF: csrr t0, 1
-csrrs t0, 1, zero
-
-# CHECK-INST: csrrw t0, fflags, t2
-# CHECK-ALIAS: fsflags t0, t2
-# CHECK-EXT-F-ON: fsflags t0, t2
-# CHECK-EXT-F-OFF: csrrw t0, 1, t2
-csrrw t0, 1, t2
-
-# CHECK-INST: csrrw zero, fflags, t2
-# CHECK-ALIAS: fsflags t2
-# CHECK-EXT-F-ON: fsflags t2
-# CHECK-EXT-F-OFF: csrw 1, t2
-csrrw zero, 1, t2
-
-# CHECK-INST: csrrwi t0, fflags, 31
-# CHECK-ALIAS: fsflagsi t0, 31
-# CHECK-EXT-F: fsflagsi t0, 31
-# CHECK-EXT-F-OFF: csrrwi t0, 1, 31
-csrrwi t0, 1, 31
-
-# CHECK-INST: csrrwi zero, fflags, 31
-# CHECK-ALIAS: fsflagsi 31
-# CHECK-EXT-F: fsflagsi 31
-# CHECK-EXT-F-OFF: csrwi 1, 31
-csrrwi zero, 1, 31
-
diff --git a/test/MC/RISCV/data-directives-invalid.s b/test/MC/RISCV/data-directives-invalid.s
deleted file mode 100644
index 6618cd17fa2..00000000000
--- a/test/MC/RISCV/data-directives-invalid.s
+++ /dev/null
@@ -1,23 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 | FileCheck %s
-
-# CHECK: [[@LINE+1]]:7: error: out of range literal value in '.byte' directive
-.byte 0xffa
-# CHECK: [[@LINE+1]]:7: error: out of range literal value in '.half' directive
-.half 0xffffa
-# CHECK: [[@LINE+1]]:8: error: out of range literal value in '.short' directive
-.short 0xffffa
-# CHECK: [[@LINE+1]]:8: error: out of range literal value in '.hword' directive
-.hword 0xffffa
-# CHECK: [[@LINE+1]]:8: error: out of range literal value in '.2byte' directive
-.2byte 0xffffa
-# CHECK: [[@LINE+1]]:7: error: out of range literal value in '.word' directive
-.word 0xffffffffa
-# CHECK: [[@LINE+1]]:7: error: out of range literal value in '.long' directive
-.long 0xffffffffa
-# CHECK: [[@LINE+1]]:8: error: out of range literal value in '.4byte' directive
-.4byte 0xffffffffa
-# CHECK: [[@LINE+1]]:8: error: literal value out of range for directive in '.dword' directive
-.dword 0xffffffffffffffffa
-# CHECK: [[@LINE+1]]:8: error: literal value out of range for directive in '.8byte' directive
-.8byte 0xffffffffffffffffa
diff --git a/test/MC/RISCV/data-directives-valid.s b/test/MC/RISCV/data-directives-valid.s
deleted file mode 100644
index ece7f096f16..00000000000
--- a/test/MC/RISCV/data-directives-valid.s
+++ /dev/null
@@ -1,32 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -s - | FileCheck %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -s - | FileCheck %s
-
-# Check that data directives supported by gas are also supported by LLVM MC.
-# As there was some confusion about whether .half/.word/.dword imply
-# alignment (see <https://github.com/riscv/riscv-asm-manual/issues/12>), we
-# are sure to check this.
-
-.data
-
-# CHECK: Contents of section .data:
-# CHECK-NEXT: 0000 deadbeef badcaf11 22334455 66778800
-.byte 0xde
-.half 0xbead
-.word 0xafdcbaef
-.dword 0x8877665544332211
-.byte 0
-
-# CHECK-NEXT: 0010 deadbeef badcaf11 22334455 66778800
-.byte 0xde
-.2byte 0xbead
-.4byte 0xafdcbaef
-.8byte 0x8877665544332211
-.byte 0
-
-# CHECK-NEXT: 0020 deadbeef badcaf11 22
-.byte 0xde
-.short 0xbead
-.long 0xafdcbaef
-.hword 0x2211
diff --git a/test/MC/RISCV/elf-flags.s b/test/MC/RISCV/elf-flags.s
deleted file mode 100644
index 1d183aab339..00000000000
--- a/test/MC/RISCV/elf-flags.s
+++ /dev/null
@@ -1,13 +0,0 @@
-# RUN: llvm-mc -triple=riscv32 -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVI %s
-# RUN: llvm-mc -triple=riscv64 -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVI %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+c -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVIC %s
-# RUN: llvm-mc -triple=riscv64 -mattr=+c -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVIC %s
-
-# CHECK-RVI:       Flags [ (0x0)
-# CHECK-RVI-NEXT:  ]
-
-# CHECK-RVIC:       Flags [ (0x1)
-# CHECK-RVIC-NEXT:    EF_RISCV_RVC (0x1)
-# CHECK-RVIC-NEXT:  ]
-
-nop
diff --git a/test/MC/RISCV/elf-header.s b/test/MC/RISCV/elf-header.s
deleted file mode 100644
index 29a7036f2fc..00000000000
--- a/test/MC/RISCV/elf-header.s
+++ /dev/null
@@ -1,42 +0,0 @@
-# RUN: llvm-mc %s -filetype=obj -triple=riscv32 | llvm-readobj -h \
-# RUN:     | FileCheck -check-prefix=RV32 %s
-# RUN: llvm-mc %s -filetype=obj -triple=riscv64 | llvm-readobj -h \
-# RUN:     | FileCheck -check-prefix=RV64 %s
-
-# RV32: Format: ELF32-riscv
-# RV32: Arch: riscv32
-# RV32: AddressSize: 32bit
-# RV32: ElfHeader {
-# RV32:   Ident {
-# RV32:     Magic: (7F 45 4C 46)
-# RV32:     Class: 32-bit (0x1)
-# RV32:     DataEncoding: LittleEndian (0x1)
-# RV32:     FileVersion: 1
-# RV32:     OS/ABI: SystemV (0x0)
-# RV32:     ABIVersion: 0
-# RV32:   }
-# RV32:   Type: Relocatable (0x1)
-# RV32:   Machine: EM_RISCV (0xF3)
-# RV32:   Version: 1
-# RV32:   Flags [ (0x0)
-# RV32:   ]
-# RV32: }
-
-# RV64: Format: ELF64-riscv
-# RV64: Arch: riscv64
-# RV64: AddressSize: 64bit
-# RV64: ElfHeader {
-# RV64:   Ident {
-# RV64:     Magic: (7F 45 4C 46)
-# RV64:     Class: 64-bit (0x2)
-# RV64:     DataEncoding: LittleEndian (0x1)
-# RV64:     FileVersion: 1
-# RV64:     OS/ABI: SystemV (0x0)
-# RV64:     ABIVersion: 0
-# RV64:   }
-# RV64:   Type: Relocatable (0x1)
-# RV64:   Machine: EM_RISCV (0xF3)
-# RV64:   Version: 1
-# RV64:   Flags [ (0x0)
-# RV64:   ]
-# RV64: }
diff --git a/test/MC/RISCV/fixups-compressed.s b/test/MC/RISCV/fixups-compressed.s
deleted file mode 100644
index 7ae6274bf27..00000000000
--- a/test/MC/RISCV/fixups-compressed.s
+++ /dev/null
@@ -1,25 +0,0 @@
-# RUN: llvm-mc %s -triple riscv32 -mattr=+c -show-encoding \
-# RUN:     | FileCheck -check-prefix=CHECK-FIXUP %s
-# RUN: llvm-mc -triple riscv32 -filetype=obj -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - | FileCheck -check-prefix=CHECK-INSTR %s
-# RUN: llvm-mc -filetype=obj -mattr=+c -triple=riscv32 %s \
-# RUN:     | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-.LBB0_2:
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_jump
-# CHECK-INSTR: c.j     0
-c.j     .LBB0_2
-# CHECK:   fixup A - offset: 0, value: func1, kind: fixup_riscv_rvc_jump
-# CHECK-INSTR: c.jal   6
-c.jal   func1
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_branch
-# CHECK-INSTR: c.beqz  a3, -4
-c.beqz  a3, .LBB0_2
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_branch
-# CHECK-INSTR: c.bnez  a5, -6
-c.bnez  a5, .LBB0_2
-
-func1:
-  nop
-
-# CHECK-REL-NOT: R_RISCV
diff --git a/test/MC/RISCV/fixups-diagnostics.s b/test/MC/RISCV/fixups-diagnostics.s
deleted file mode 100644
index d346605221c..00000000000
--- a/test/MC/RISCV/fixups-diagnostics.s
+++ /dev/null
@@ -1,18 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -filetype obj < %s -o /dev/null 2>&1 | FileCheck %s
-
-  jal a0, far_distant # CHECK: :[[@LINE]]:3: error: fixup value out of range
-  jal a0, unaligned # CHECK: :[[@LINE]]:3: error: fixup value must be 2-byte aligned
-
-  beq a0, a1, distant # CHECK: :[[@LINE]]:3: error: fixup value out of range
-  blt t0, t1, unaligned # CHECK: :[[@LINE]]:3: error: fixup value must be 2-byte aligned
-
-  .byte 0
-unaligned:
-  .byte 0
-  .byte 0
-  .byte 0
-
-  .space 1<<12
-distant:
-  .space 1<<20
-far_distant:
diff --git a/test/MC/RISCV/fixups-expr.s b/test/MC/RISCV/fixups-expr.s
deleted file mode 100644
index 303b25c4832..00000000000
--- a/test/MC/RISCV/fixups-expr.s
+++ /dev/null
@@ -1,47 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+relax %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=-relax %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX %s
-
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+relax %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=-relax %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX %s
-
-# Check that subtraction expressions are emitted as two relocations
-# only when relaxation is enabled
-
-.globl G1
-.globl G2
-.L1:
-G1:
-addi a0, a0, 0
-.L2:
-G2:
-
-.data
-.dword .L2-.L1
-.dword G2-G1
-.word .L2-.L1
-.word G2-G1
-.half .L2-.L1
-.half G2-G1
-.byte .L2-.L1
-.byte G2-G1
-# RELAX: 0x0 R_RISCV_ADD64 .L2 0x0
-# RELAX: 0x0 R_RISCV_SUB64 .L1 0x0
-# RELAX: 0x8 R_RISCV_ADD64 G2 0x0
-# RELAX: 0x8 R_RISCV_SUB64 G1 0x0
-# RELAX: 0x10 R_RISCV_ADD32 .L2 0x0
-# RELAX: 0x10 R_RISCV_SUB32 .L1 0x0
-# RELAX: 0x14 R_RISCV_ADD32 G2 0x0
-# RELAX: 0x14 R_RISCV_SUB32 G1 0x0
-# RELAX: 0x18 R_RISCV_ADD16 .L2 0x0
-# RELAX: 0x18 R_RISCV_SUB16 .L1 0x0
-# RELAX: 0x1A R_RISCV_ADD16 G2 0x0
-# RELAX: 0x1A R_RISCV_SUB16 G1 0x0
-# RELAX: 0x1C R_RISCV_ADD8 .L2 0x0
-# RELAX: 0x1C R_RISCV_SUB8 .L1 0x0
-# RELAX: 0x1D R_RISCV_ADD8 G2 0x0
-# RELAX: 0x1D R_RISCV_SUB8 G1 0x0
-# NORELAX-NOT: R_RISCV
diff --git a/test/MC/RISCV/fixups.s b/test/MC/RISCV/fixups.s
deleted file mode 100644
index f0377debabb..00000000000
--- a/test/MC/RISCV/fixups.s
+++ /dev/null
@@ -1,83 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -riscv-no-aliases < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=CHECK-FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INSTR %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:     | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-# Checks that fixups that can be resolved within the same object file are
-# applied correctly
-
-.LBB0:
-lui t1, %hi(val)
-# CHECK-FIXUP: fixup A - offset: 0, value: %hi(val), kind: fixup_riscv_hi20
-# CHECK-INSTR: lui t1, 74565
-
-lw a0, %lo(val)(t1)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_i
-# CHECK-INSTR: lw a0, 1656(t1)
-addi a1, t1, %lo(val)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_i
-# CHECK-INSTR: addi a1, t1, 1656
-sw a0, %lo(val)(t1)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_s
-# CHECK-INSTR: sw a0, 1656(t1)
-
-1:
-auipc t1, %pcrel_hi(.LBB0)
-# CHECK-FIXUP: fixup A - offset: 0, value: %pcrel_hi(.LBB0), kind: fixup_riscv_pcrel_hi20
-# CHECK-INSTR: auipc t1, 0
-addi t1, t1, %pcrel_lo(1b)
-# CHECK-FIXUP: fixup A - offset: 0, value: %pcrel_lo(.Ltmp0), kind: fixup_riscv_pcrel_lo12_i
-# CHECK-INSTR: addi t1, t1, -16
-sw t1, %pcrel_lo(1b)(t1)
-# CHECK-FIXUP: fixup A - offset: 0, value: %pcrel_lo(.Ltmp0), kind: fixup_riscv_pcrel_lo12_s
-# CHECK-INSTR: sw t1, -16(t1)
-
-jal zero, .LBB0
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB0, kind: fixup_riscv_jal
-# CHECK-INSTR: jal zero, -28
-jal zero, .LBB2
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB2, kind: fixup_riscv_jal
-# CHECK-INSTR: jal zero, 330996
-beq a0, a1, .LBB0
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB0, kind: fixup_riscv_branch
-# CHECK-INSTR: beq a0, a1, -36
-blt a0, a1, .LBB1
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB1, kind: fixup_riscv_branch
-# CHECK-INSTR: blt a0, a1, 1108
-
-.fill 1104
-
-.LBB1:
-
-.fill 329876
-addi zero, zero, 0
-.LBB2:
-
-.set val, 0x12345678
-
-# CHECK-REL-NOT: R_RISCV
-
-# Testing the function call offset could resovled by assembler
-# when the function and the callsite within the same compile unit
-# and the linker relaxation is disabled.
-func:
-.fill 100
-call func
-# CHECK-FIXUP: fixup A - offset: 0, value: func, kind: fixup_riscv_call
-# CHECK-INSTR: auipc   ra, 0
-# CHECK-INSTR: jalr    ra, ra, -100
-
-.fill 10000
-call func
-# CHECK-FIXUP: fixup A - offset: 0, value: func, kind: fixup_riscv_call
-# CHECK-INSTR: auipc   ra, 1048574
-# CHECK-INSTR: jalr    ra, ra, -1916
-
-.fill 20888
-call func
-# CHECK-FIXUP: fixup A - offset: 0, value: func, kind: fixup_riscv_call
-# CHECK-INSTR: auipc   ra, 1048568
-# CHECK-INSTR: jalr    ra, ra, 1764
diff --git a/test/MC/RISCV/function-call-invalid.s b/test/MC/RISCV/function-call-invalid.s
deleted file mode 100644
index 14532495e3f..00000000000
--- a/test/MC/RISCV/function-call-invalid.s
+++ /dev/null
@@ -1,11 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-
-call 1234 # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %pcrel_hi(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %pcrel_lo(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %pcrel_hi(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %pcrel_lo(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %hi(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %lo(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %hi(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-call %lo(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
diff --git a/test/MC/RISCV/function-call.s b/test/MC/RISCV/function-call.s
deleted file mode 100644
index 44f64f5a70b..00000000000
--- a/test/MC/RISCV/function-call.s
+++ /dev/null
@@ -1,45 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-# RUN: llvm-mc -triple riscv32 < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=FIXUP %s
-
-.long foo
-
-call foo
-# RELOC: R_RISCV_CALL foo 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_call
-call bar
-# RELOC: R_RISCV_CALL bar 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: bar, kind: fixup_riscv_call
-
-# Ensure that calls to functions whose names coincide with register names work.
-
-call zero
-# RELOC: R_RISCV_CALL zero 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: zero, kind: fixup_riscv_call
-
-call f1
-# RELOC: R_RISCV_CALL f1 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: f1, kind: fixup_riscv_call
-
-call ra
-# RELOC: R_RISCV_CALL ra 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: ra, kind: fixup_riscv_call
-
-call mstatus
-# RELOC: R_RISCV_CALL mstatus 0x0
-# INSTR: auipc ra, 0
-# INSTR: jalr  ra
-# FIXUP: fixup A - offset: 0, value: mstatus, kind: fixup_riscv_call
diff --git a/test/MC/RISCV/hilo-constaddr-expr.s b/test/MC/RISCV/hilo-constaddr-expr.s
deleted file mode 100644
index 48893757f8b..00000000000
--- a/test/MC/RISCV/hilo-constaddr-expr.s
+++ /dev/null
@@ -1,31 +0,0 @@
-# RUN: not llvm-mc -filetype=obj -triple=riscv32 -mattr=+relax %s 2>&1 \
-# RUN:     | FileCheck %s -check-prefix=CHECK-RELAX
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=-relax %s 2>&1 \
-# RUN:     | llvm-objdump -d - | FileCheck %s -check-prefix=CHECK-INSTR
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=-relax %s 2>&1 \
-# RUN:     | llvm-objdump -r - | FileCheck %s -check-prefix=CHECK-REL
-
-# Check the assembler rejects hi and lo expressions with constant expressions
-# involving labels when diff expressions are emitted as relocation pairs.
-# Test case derived from test/MC/Mips/hilo-addressing.s
-
-tmp1:
-  # Emit zeros so that difference between tmp1 and tmp3 is 0x30124 bytes.
-  .fill 0x30124-8
-tmp2:
-# CHECK-RELAX: :[[@LINE+1]]:{{[0-9]+}}: error: expected relocatable expression
-  lui t0, %hi(tmp3-tmp1)
-# CHECK-RELAX: :[[@LINE+1]]:{{[0-9]+}}: error: expected relocatable expression
-  lw ra, %lo(tmp3-tmp1)(t0)
-# CHECK-INSTR: lui t0, 48
-# CHECK-INSTR: lw ra, 292(t0)
-
-tmp3:
-# CHECK-RELAX: :[[@LINE+1]]:{{[0-9]+}}: error: expected relocatable expression
-  lui t1, %hi(tmp2-tmp3)
-# CHECK-RELAX: :[[@LINE+1]]:{{[0-9]+}}: error: expected relocatable expression
-  lw sp, %lo(tmp2-tmp3)(t1)
-# CHECK-INSTR: lui t1, 0
-# CHECK-INSTR: lw sp, -8(t1)
-
-# CHECK-REL-NOT: R_RISCV
\ No newline at end of file
diff --git a/test/MC/RISCV/hilo-constaddr.s b/test/MC/RISCV/hilo-constaddr.s
deleted file mode 100644
index 9676d85bd9c..00000000000
--- a/test/MC/RISCV/hilo-constaddr.s
+++ /dev/null
@@ -1,17 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:  | llvm-objdump -d - | FileCheck %s -check-prefix=CHECK-INSTR
-
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:  | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-# Check the assembler can handle hi and lo expressions with a constant
-# address. Test case derived from test/MC/Mips/hilo-addressing.s
-
-# Check that 1 is added to the high 20 bits if bit 11 of the low part is 1.
-.equ addr, 0xdeadbeef
-  lui t0, %hi(addr)
-  lw ra, %lo(addr)(t0)
-# CHECK-INSTR: lui t0, 912092
-# CHECK-INSTR: lw ra, -273(t0)
-
-# CHECK-REL-NOT: R_RISCV
diff --git a/test/MC/RISCV/linker-relaxation.s b/test/MC/RISCV/linker-relaxation.s
deleted file mode 100644
index 0184d174e90..00000000000
--- a/test/MC/RISCV/linker-relaxation.s
+++ /dev/null
@@ -1,26 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX-RELOC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=-relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX-RELOC %s
-# RUN: llvm-mc -triple riscv32 -mattr=+relax < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=RELAX-FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX-RELOC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=-relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=NORELAX-RELOC %s
-# RUN: llvm-mc -triple riscv64 -mattr=+relax < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=RELAX-FIXUP %s
-
-.long foo
-
-.L1:
-call foo
-# NORELAX-RELOC: R_RISCV_CALL foo 0x0
-# NORELAX-RELOC-NOT: R_RISCV_RELAX
-# RELAX-RELOC: R_RISCV_CALL foo 0x0
-# RELAX-RELOC: R_RISCV_RELAX foo 0x0
-# RELAX-FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_call
-# RELAX-FIXUP: fixup B - offset: 0, value: foo, kind: fixup_riscv_relax
-beq s1, s1, .L1
-# RELAX-RELOC: R_RISCV_BRANCH .L1 0x0
-# RELAX-FIXUP: fixup A - offset: 0, value: .L1, kind: fixup_riscv_branch
diff --git a/test/MC/RISCV/lit.local.cfg b/test/MC/RISCV/lit.local.cfg
deleted file mode 100644
index d0b081e3e8b..00000000000
--- a/test/MC/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,3 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
-
diff --git a/test/MC/RISCV/lla-invalid.s b/test/MC/RISCV/lla-invalid.s
deleted file mode 100644
index bd99bfd83ca..00000000000
--- a/test/MC/RISCV/lla-invalid.s
+++ /dev/null
@@ -1,6 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -triple=riscv64 < %s 2>&1 | FileCheck %s
-
-# Non bare symbols must be rejected
-lla a2, %lo(a_symbol) # CHECK: :[[@LINE]]:9: error: operand must be a bare symbol name
-lla a2, %hi(a_symbol) # CHECK: :[[@LINE]]:9: error: operand must be a bare symbol name
diff --git a/test/MC/RISCV/machine-csr-names-invalid.s b/test/MC/RISCV/machine-csr-names-invalid.s
deleted file mode 100644
index 4fc97303028..00000000000
--- a/test/MC/RISCV/machine-csr-names-invalid.s
+++ /dev/null
@@ -1,40 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 \
-# RUN:  | FileCheck -check-prefixes=CHECK-NEED-RV32 %s
-
-# These machine mode CSR register names are RV32 only.
-
-csrrs t1, pmpcfg1, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, pmpcfg3, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-
-csrrs t1, mcycleh, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, minstreth, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-
-csrrs t1, mhpmcounter3h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter4h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter5h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter6h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter7h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter8h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter9h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter10h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter11h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter12h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter13h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter14h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter15h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter16h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter17h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter18h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter19h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter20h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter21h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter22h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter23h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter24h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter25h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter26h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter27h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter28h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter29h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter30h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, mhpmcounter31h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
diff --git a/test/MC/RISCV/machine-csr-names.s b/test/MC/RISCV/machine-csr-names.s
deleted file mode 100644
index 3932ebce483..00000000000
--- a/test/MC/RISCV/machine-csr-names.s
+++ /dev/null
@@ -1,1229 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-#
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-##################################
-# Machine Information Registers
-##################################
-
-# mvendorid
-# name
-# CHECK-INST: csrrs t1, mvendorid, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0xf1]
-# CHECK-INST-ALIAS: csrr t1, mvendorid
-# uimm12
-# CHECK-INST: csrrs t2, mvendorid, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0xf1]
-# CHECK-INST-ALIAS: csrr t2, mvendorid
-# name
-csrrs t1, mvendorid, zero
-# uimm12
-csrrs t2, 0xF11, zero
-
-# marchid
-# name
-# CHECK-INST: csrrs t1, marchid, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0xf1]
-# CHECK-INST-ALIAS: csrr t1, marchid
-# uimm12
-# CHECK-INST: csrrs t2, marchid, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0xf1]
-# CHECK-INST-ALIAS: csrr t2, marchid
-# name
-csrrs t1, marchid, zero
-# uimm12
-csrrs t2, 0xF12, zero
-
-# mimpid
-# name
-# CHECK-INST: csrrs t1, mimpid, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0xf1]
-# CHECK-INST-ALIAS: csrr t1, mimpid
-# uimm12
-# CHECK-INST: csrrs t2, mimpid, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0xf1]
-# CHECK-INST-ALIAS: csrr t2, mimpid
-csrrs t1, mimpid, zero
-# uimm12
-csrrs t2, 0xF13, zero
-
-# mhartid
-# name
-# CHECK-INST: csrrs t1, mhartid, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x40,0xf1]
-# CHECK-INST-ALIAS: csrr t1, mhartid
-# uimm12
-# CHECK-INST: csrrs t2, mhartid, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x40,0xf1]
-# CHECK-INST-ALIAS: csrr t2, mhartid
-# name
-csrrs t1, mhartid, zero
-# uimm12
-csrrs t2, 0xF14, zero
-
-##################################
-# Machine Trap Setup
-##################################
-
-# mstatus
-# name
-# CHECK-INST: csrrs t1, mstatus, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x30]
-# CHECK-INST-ALIAS: csrr t1, mstatus
-# uimm12
-# CHECK-INST: csrrs t2, mstatus, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x30]
-# CHECK-INST-ALIAS: csrr t2, mstatus
-# name
-csrrs t1, mstatus, zero
-# uimm12
-csrrs t2, 0x300, zero
-
-# misa
-# name
-# CHECK-INST: csrrs t1, misa, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x30]
-# CHECK-INST-ALIAS: csrr t1, misa
-# uimm12
-# CHECK-INST: csrrs t2, misa, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x30]
-# CHECK-INST-ALIAS: csrr t2, misa
-# name
-csrrs t1, misa, zero
-# uimm12
-csrrs t2, 0x301, zero
-
-# medeleg
-# name
-# CHECK-INST: csrrs t1, medeleg, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x30]
-# CHECK-INST-ALIAS: csrr t1, medeleg
-# uimm12
-# CHECK-INST: csrrs t2, medeleg, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x30]
-# CHECK-INST-ALIAS: csrr t2, medeleg
-# name
-csrrs t1, medeleg, zero
-# uimm12
-csrrs t2, 0x302, zero
-# aliases
-
-# mideleg
-# name
-# CHECK-INST: csrrs t1, mideleg, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x30]
-# CHECK-INST-ALIAS: csrr t1, mideleg
-# uimm12
-# CHECK-INST: csrrs t2, mideleg, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x30]
-# CHECK-INST-ALIAS: csrr t2, mideleg
-# aliases
-# name
-csrrs t1, mideleg, zero
-# uimm12
-csrrs t2, 0x303, zero
-
-# mie
-# name
-# CHECK-INST: csrrs t1, mie, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x40,0x30]
-# CHECK-INST-ALIAS: csrr t1, mie
-# uimm12
-# CHECK-INST: csrrs t2, mie, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x30]
-# CHECK-INST-ALIAS: csrr t2, mie
-# name
-csrrs t1, mie, zero
-# uimm12
-csrrs t2, 0x304, zero
-
-# mtvec
-# name
-# CHECK-INST: csrrs t1, mtvec, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x50,0x30]
-# CHECK-INST-ALIAS: csrr t1, mtvec
-# uimm12
-# CHECK-INST: csrrs t2, mtvec, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x50,0x30]
-# CHECK-INST-ALIAS: csrr t2, mtvec
-# name
-csrrs t1, mtvec, zero
-# uimm12
-csrrs t2, 0x305, zero
-
-# mcounteren
-# name
-# CHECK-INST: csrrs t1, mcounteren, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x60,0x30]
-# CHECK-INST-ALIAS: csrr t1, mcounteren
-# uimm12
-# CHECK-INST: csrrs t2, mcounteren, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x60,0x30]
-# CHECK-INST-ALIAS: csrr t2, mcounteren
-# name
-csrrs t1, mcounteren, zero
-# uimm12
-csrrs t2, 0x306, zero
-
-# mscratch
-# name
-# CHECK-INST: csrrs t1, mscratch, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x34]
-# CHECK-INST-ALIAS: csrr t1, mscratch
-# uimm12
-# CHECK-INST: csrrs t2, mscratch, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x34]
-# CHECK-INST-ALIAS: csrr t2, mscratch
-# name
-csrrs t1, mscratch, zero
-# uimm12
-csrrs t2, 0x340, zero
-
-# mepc
-# name
-# CHECK-INST: csrrs t1, mepc, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x34]
-# CHECK-INST-ALIAS: csrr t1, mepc
-# uimm12
-# CHECK-INST: csrrs t2, mepc, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x34]
-# CHECK-INST-ALIAS: csrr t2, mepc
-# name
-csrrs t1, mepc, zero
-# uimm12
-csrrs t2, 0x341, zero
-
-# mcause
-# name
-# CHECK-INST: csrrs t1, mcause, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x34]
-# CHECK-INST-ALIAS: csrr t1, mcause
-# uimm12
-# CHECK-INST: csrrs t2, mcause, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x34]
-# CHECK-INST-ALIAS: csrr t2, mcause
-# name
-csrrs t1, mcause, zero
-# uimm12
-csrrs t2, 0x342, zero
-
-# mtval
-# name
-# CHECK-INST: csrrs t1, mtval, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x34]
-# CHECK-INST-ALIAS: csrr t1, mtval
-# uimm12
-# CHECK-INST: csrrs t2, mtval, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x34]
-# CHECK-INST-ALIAS: csrr t2, mtval
-# name
-csrrs t1, mtval, zero
-# uimm12
-csrrs t2, 0x343, zero
-
-# mip
-# name
-# CHECK-INST: csrrs t1, mip, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x40,0x34]
-# CHECK-INST-ALIAS: csrr t1, mip
-# uimm12
-# CHECK-INST: csrrs t2, mip, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x34]
-# CHECK-INST-ALIAS: csrr t2, mip
-# name
-csrrs t1, mip, zero
-# uimm12
-csrrs t2, 0x344, zero
-
-######################################
-# Machine Protection and Translation
-######################################
-# Tests for pmpcfg1, pmpcfg2 in rv32-machine-csr-names.s
-
-# pmpcfg0
-# name
-# CHECK-INST: csrrs t1, pmpcfg0, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x3a]
-# CHECK-INST-ALIAS: csrr t1, pmpcfg0
-# uimm12
-# CHECK-INST: csrrs t2, pmpcfg0, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x3a]
-# CHECK-INST-ALIAS: csrr t2, pmpcfg0
-# name
-csrrs t1, pmpcfg0, zero
-# uimm12
-csrrs t2, 0x3A0, zero
-
-# pmpcfg2
-# name
-# CHECK-INST: csrrs t1, pmpcfg2, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x3a]
-# CHECK-INST-ALIAS: csrr t1, pmpcfg2
-# uimm12
-# CHECK-INST: csrrs t2, pmpcfg2, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x3a]
-# CHECK-INST-ALIAS: csrr t2, pmpcfg2
-# name
-csrrs t1, pmpcfg2, zero
-# uimm12
-csrrs t2, 0x3A2, zero
-
-
-######################################
-# Machine Counter and Timers
-######################################
-# mcycle
-# name
-# CHECK-INST: csrrs t1, mcycle, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mcycle
-# uimm12
-# CHECK-INST: csrrs t2, mcycle, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mcycle
-csrrs t1, mcycle, zero
-# uimm12
-csrrs t2, 0xB00, zero
-
-# minstret
-# name
-# CHECK-INST: csrrs t1, minstret, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0xb0]
-# CHECK-INST-ALIAS: csrr t1, minstret
-# uimm12
-# CHECK-INST: csrrs t2, minstret, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0xb0]
-# CHECK-INST-ALIAS: csrr t2, minstret
-# name
-csrrs t1, minstret, zero
-# uimm12
-csrrs t2, 0xB02, zero
-
-
-######################################################
-# Debug and Trace Registers (shared with Debug Mode)
-######################################################
-# tselect
-# name
-# CHECK-INST: csrrs t1, tselect, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x7a]
-# CHECK-INST-ALIAS: csrr t1, tselect
-# uimm12
-# CHECK-INST: csrrs t2, tselect, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x7a]
-# CHECK-INST-ALIAS: csrr t2, tselect
-# name
-csrrs t1, tselect, zero
-# uimm12
-csrrs t2, 0x7A0, zero
-
-# tdata1
-# name
-# CHECK-INST: csrrs t1, tdata1, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x7a]
-# CHECK-INST-ALIAS: csrr t1, tdata1
-# uimm12
-# CHECK-INST: csrrs t2, tdata1, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x7a]
-# CHECK-INST-ALIAS: csrr t2, tdata1
-# name
-csrrs t1, tdata1, zero
-# uimm12
-csrrs t2, 0x7A1, zero
-
-# tdata2
-# name
-# CHECK-INST: csrrs t1, tdata2, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x7a]
-# CHECK-INST-ALIAS: csrr t1, tdata2
-# uimm12
-# CHECK-INST: csrrs t2, tdata2, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x7a]
-# CHECK-INST-ALIAS: csrr t2, tdata2
-csrrs t1, tdata2, zero
-# uimm12
-csrrs t2, 0x7A2, zero
-
-#tdata3
-# name
-# CHECK-INST: csrrs t1, tdata3, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x7a]
-# CHECK-INST-ALIAS: csrr t1, tdata3
-# uimm12
-# CHECK-INST: csrrs t2, tdata3, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x7a]
-# CHECK-INST-ALIAS: csrr t2, tdata3
-# name
-csrrs t1, tdata3, zero
-# uimm12
-csrrs t2, 0x7A3, zero
-
-#######################
-# Debug Mode Registers
-########################
-# dcsr
-# name
-# CHECK-INST: csrrs t1, dcsr, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x7b]
-# CHECK-INST-ALIAS: csrr t1, dcsr
-# uimm12
-# CHECK-INST: csrrs t2, dcsr, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x7b]
-# CHECK-INST-ALIAS: csrr t2, dcsr
-# name
-csrrs t1, dcsr, zero
-# uimm12
-csrrs t2, 0x7B0, zero
-
-# dpc
-# name
-# CHECK-INST: csrrs t1, dpc, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x7b]
-# CHECK-INST-ALIAS: csrr t1, dpc
-# uimm12
-# CHECK-INST: csrrs t2, dpc, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x7b]
-# CHECK-INST-ALIAS: csrr t2, dpc
-# name
-csrrs t1, dpc, zero
-# uimm12
-csrrs t2, 0x7B1, zero
-
-# dscratch
-# name
-# CHECK-INST: csrrs t1, dscratch, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x7b]
-# CHECK-INST-ALIAS: csrr t1, dscratch
-# uimm12
-# CHECK-INST: csrrs t2, dscratch, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x7b]
-# CHECK-INST-ALIAS: csrr t2, dscratch
-# name
-csrrs t1, dscratch, zero
-# uimm12
-csrrs t2, 0x7B2, zero
-
-# mhpmcounter3
-# name
-# CHECK-INST: csrrs t1, mhpmcounter3, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter3
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter3, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter3
-# name
-csrrs t1, mhpmcounter3, zero
-# uimm12
-csrrs t2, 0xB03, zero
-
-# mhpmcounter4
-# name
-# CHECK-INST: csrrs t1, mhpmcounter4, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter4
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter4, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter4
-# name
-csrrs t1, mhpmcounter4, zero
-# uimm12
-csrrs t2, 0xB04, zero
-
-# mhpmcounter5
-# name
-# CHECK-INST: csrrs t1, mhpmcounter5, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter5
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter5, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter5
-# name
-csrrs t1, mhpmcounter5, zero
-# uimm12
-csrrs t2, 0xB05, zero
-
-# mhpmcounter6
-# name
-# CHECK-INST: csrrs t1, mhpmcounter6, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter6
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter6, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter6
-# name
-csrrs t1, mhpmcounter6, zero
-# uimm12
-csrrs t2, 0xB06, zero
-
-# mhpmcounter7
-# name
-# CHECK-INST: csrrs t1, mhpmcounter7, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter7
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter7, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter7
-# name
-csrrs t1, mhpmcounter7, zero
-# uimm12
-csrrs t2, 0xB07, zero
-
-# mhpmcounter8
-# name
-# CHECK-INST: csrrs t1, mhpmcounter8, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter8
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter8, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter8
-# name
-csrrs t1, mhpmcounter8, zero
-# uimm12
-csrrs t2, 0xB08, zero
-
-# mhpmcounter9
-# name
-# CHECK-INST: csrrs t1, mhpmcounter9, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter9
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter9, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter9
-# name
-csrrs t1, mhpmcounter9, zero
-# uimm12
-csrrs t2, 0xB09, zero
-
-# mhpmcounter10
-# name
-# CHECK-INST: csrrs t1, mhpmcounter10, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter10
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter10, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter10
-# name
-csrrs t1, mhpmcounter10, zero
-# uimm12
-csrrs t2, 0xB0A, zero
-
-# mhpmcounter11
-# name
-# CHECK-INST: csrrs t1, mhpmcounter11, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter11
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter11, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter11
-# name
-csrrs t1, mhpmcounter11, zero
-# uimm12
-csrrs t2, 0xB0B, zero
-
-# mhpmcounter12
-# name
-# CHECK-INST: csrrs t1, mhpmcounter12, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter12
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter12, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter12
-# name
-csrrs t1, mhpmcounter12, zero
-# uimm12
-csrrs t2, 0xB0C, zero
-
-# mhpmcounter13
-# name
-# CHECK-INST: csrrs t1, mhpmcounter13, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter13
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter13, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter13
-# name
-csrrs t1, mhpmcounter13, zero
-# uimm12
-csrrs t2, 0xB0D, zero
-
-# mhpmcounter14
-# name
-# CHECK-INST: csrrs t1, mhpmcounter14, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter14
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter14, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter14
-# name
-csrrs t1, mhpmcounter14, zero
-# uimm12
-csrrs t2, 0xB0E, zero
-
-# mhpmcounter15
-# name
-# CHECK-INST: csrrs t1, mhpmcounter15, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xb0]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter15
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter15, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb0]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter15
-# name
-csrrs t1, mhpmcounter15, zero
-# uimm12
-csrrs t2, 0xB0F, zero
-
-# mhpmcounter16
-# name
-# CHECK-INST: csrrs t1, mhpmcounter16, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter16
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter16, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter16
-# name
-csrrs t1, mhpmcounter16, zero
-# uimm12
-csrrs t2, 0xB10, zero
-
-# mhpmcounter17
-# name
-# CHECK-INST: csrrs t1, mhpmcounter17, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter17
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter17, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter17
-# name
-csrrs t1, mhpmcounter17, zero
-# uimm12
-csrrs t2, 0xB11, zero
-
-# mhpmcounter18
-# name
-# CHECK-INST: csrrs t1, mhpmcounter18, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter18
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter18, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter18
-# name
-csrrs t1, mhpmcounter18, zero
-# uimm12
-csrrs t2, 0xB12, zero
-
-# mhpmcounter19
-# name
-# CHECK-INST: csrrs t1, mhpmcounter19, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter19
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter19, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter19
-# name
-csrrs t1, mhpmcounter19, zero
-# uimm12
-csrrs t2, 0xB13, zero
-
-# mhpmcounter20
-# name
-# CHECK-INST: csrrs t1, mhpmcounter20, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter20
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter20, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter20
-# name
-csrrs t1, mhpmcounter20, zero
-# uimm12
-csrrs t2, 0xB14, zero
-
-# mhpmcounter21
-# name
-# CHECK-INST: csrrs t1, mhpmcounter21, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter21
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter21, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter21
-# name
-csrrs t1, mhpmcounter21, zero
-# uimm12
-csrrs t2, 0xB15, zero
-
-# mhpmcounter22
-# name
-# CHECK-INST: csrrs t1, mhpmcounter22, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter22
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter22, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter22
-# name
-csrrs t1, mhpmcounter22, zero
-# uimm12
-csrrs t2, 0xB16, zero
-
-# mhpmcounter23
-# name
-# CHECK-INST: csrrs t1, mhpmcounter23, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter23
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter23, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter23
-# name
-csrrs t1, mhpmcounter23, zero
-# uimm12
-csrrs t2, 0xB17, zero
-
-# mhpmcounter24
-# name
-# CHECK-INST: csrrs t1, mhpmcounter24, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter24
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter24, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter24
-# name
-csrrs t1, mhpmcounter24, zero
-# uimm12
-csrrs t2, 0xB18, zero
-
-# mhpmcounter25
-# name
-# CHECK-INST: csrrs t1, mhpmcounter25, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter25
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter25, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter25
-# name
-csrrs t1, mhpmcounter25, zero
-# uimm12
-csrrs t2, 0xB19, zero
-
-# mhpmcounter26
-# name
-# CHECK-INST: csrrs t1, mhpmcounter26, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter26
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter26, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter26
-# name
-csrrs t1, mhpmcounter26, zero
-# uimm12
-csrrs t2, 0xB1A, zero
-
-# mhpmcounter27
-# name
-# CHECK-INST: csrrs t1, mhpmcounter27, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter27
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter27, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter27
-# name
-csrrs t1, mhpmcounter27, zero
-# uimm12
-csrrs t2, 0xB1B, zero
-
-# mhpmcounter28
-# name
-# CHECK-INST: csrrs t1, mhpmcounter28, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter28
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter28, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter28
-# name
-csrrs t1, mhpmcounter28, zero
-# uimm12
-csrrs t2, 0xB1C, zero
-
-# mhpmcounter29
-# name
-# CHECK-INST: csrrs t1, mhpmcounter29, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter29
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter29, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter29
-# name
-csrrs t1, mhpmcounter29, zero
-# uimm12
-csrrs t2, 0xB1D, zero
-
-# mhpmcounter30
-# name
-# CHECK-INST: csrrs t1, mhpmcounter30, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter30
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter30, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter30
-# name
-csrrs t1, mhpmcounter30, zero
-# uimm12
-csrrs t2, 0xB1E, zero
-
-# mhpmcounter31
-# name
-# CHECK-INST: csrrs t1, mhpmcounter31, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xb1]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter31
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter31, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb1]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter31
-# name
-csrrs t1, mhpmcounter31, zero
-# uimm12
-csrrs t2, 0xB1F, zero
-
-
-######################################
-# Machine Counter Setup
-######################################
-# mhpmevent3
-# name
-# CHECK-INST: csrrs t1, mhpmevent3, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent3
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent3, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent3
-# name
-csrrs t1, mhpmevent3, zero
-# uimm12
-csrrs t2, 0x323, zero
-
-# mhpmevent4
-# name
-# CHECK-INST: csrrs t1, mhpmevent4, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent4
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent4, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent4
-# name
-csrrs t1, mhpmevent4, zero
-# uimm12
-csrrs t2, 0x324, zero
-
-# mhpmevent5
-# name
-# CHECK-INST: csrrs t1, mhpmevent5, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent5
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent5, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent5
-# name
-csrrs t1, mhpmevent5, zero
-# uimm12
-csrrs t2, 0x325, zero
-
-# mhpmevent6
-# name
-# CHECK-INST: csrrs t1, mhpmevent6, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent6
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent6, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent6
-# name
-csrrs t1, mhpmevent6, zero
-# uimm12
-csrrs t2, 0x326, zero
-
-# mhpmevent7
-# name
-# CHECK-INST: csrrs t1, mhpmevent7, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent7
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent7, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent7
-# name
-csrrs t1, mhpmevent7, zero
-# uimm12
-csrrs t2, 0x327, zero
-
-# mhpmevent8
-# name
-# CHECK-INST: csrrs t1, mhpmevent8, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent8
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent8, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent8
-# name
-csrrs t1, mhpmevent8, zero
-# uimm12
-csrrs t2, 0x328, zero
-
-# mhpmevent9
-# name
-# CHECK-INST: csrrs t1, mhpmevent9, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent9
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent9, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent9
-# name
-csrrs t1, mhpmevent9, zero
-# uimm12
-csrrs t2, 0x329, zero
-
-# mhpmevent10
-# name
-# CHECK-INST: csrrs t1, mhpmevent10, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent10
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent10, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent10
-# name
-csrrs t1, mhpmevent10, zero
-# uimm12
-csrrs t2, 0x32A, zero
-
-# mhpmevent11
-# name
-# CHECK-INST: csrrs t1, mhpmevent11, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent11
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent11, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent11
-# name
-csrrs t1, mhpmevent11, zero
-# uimm12
-csrrs t2, 0x32B, zero
-
-# mhpmevent12
-# name
-# CHECK-INST: csrrs t1, mhpmevent12, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent12
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent12, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent12
-# name
-csrrs t1, mhpmevent12, zero
-# uimm12
-csrrs t2, 0x32C, zero
-
-# mhpmevent13
-# name
-# CHECK-INST: csrrs t1, mhpmevent13, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent13
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent13, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent13
-# name
-csrrs t1, mhpmevent13, zero
-# uimm12
-csrrs t2, 0x32D, zero
-
-# mhpmevent14
-# name
-# CHECK-INST: csrrs t1, mhpmevent14, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent14
-# uimm12
-
-# CHECK-INST: csrrs t2, mhpmevent14, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent14
-# name
-csrrs t1, mhpmevent14, zero
-# uimm12
-csrrs t2, 0x32E, zero
-
-# mhpmevent15
-# name
-# CHECK-INST: csrrs t1, mhpmevent15, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0x32]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent15
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent15, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0x32]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent15
-# name
-csrrs t1, mhpmevent15, zero
-# uimm12
-csrrs t2, 0x32F, zero
-
-# mhpmevent16
-# name
-# CHECK-INST: csrrs t1, mhpmevent16, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent16
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent16, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent16
-# name
-csrrs t1, mhpmevent16, zero
-# uimm12
-csrrs t2, 0x330, zero
-
-# mhpmevent17
-# name
-# CHECK-INST: csrrs t1, mhpmevent17, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent17
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent17, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent17
-# name
-csrrs t1, mhpmevent17, zero
-# uimm12
-csrrs t2, 0x331, zero
-
-# mhpmevent18
-# name
-# CHECK-INST: csrrs t1, mhpmevent18, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent18
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent18, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent18
-# name
-csrrs t1, mhpmevent18, zero
-# uimm12
-csrrs t2, 0x332, zero
-
-# mhpmevent19
-# name
-# CHECK-INST: csrrs t1, mhpmevent19, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent19
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent19, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent19
-# name
-csrrs t1, mhpmevent19, zero
-# uimm12
-csrrs t2, 0x333, zero
-
-# mhpmevent20
-# name
-# CHECK-INST: csrrs t1, mhpmevent20, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent20
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent20, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent20
-# name
-csrrs t1, mhpmevent20, zero
-# uimm12
-csrrs t2, 0x334, zero
-
-# mhpmevent21
-# name
-# CHECK-INST: csrrs t1, mhpmevent21, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent21
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent21, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent21
-# name
-csrrs t1, mhpmevent21, zero
-# uimm12
-csrrs t2, 0x335, zero
-
-# mhpmevent22
-# name
-# CHECK-INST: csrrs t1, mhpmevent22, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent22
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent22, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent22
-# name
-csrrs t1, mhpmevent22, zero
-# uimm12
-csrrs t2, 0x336, zero
-
-# mhpmevent23
-# name
-# CHECK-INST: csrrs t1, mhpmevent23, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent23
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent23, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent23
-# name
-csrrs t1, mhpmevent23, zero
-# uimm12
-csrrs t2, 0x337, zero
-
-# mhpmevent24
-# name
-# CHECK-INST: csrrs t1, mhpmevent24, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent24
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent24, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent24
-# name
-csrrs t1, mhpmevent24, zero
-# uimm12
-csrrs t2, 0x338, zero
-
-# mhpmevent25
-# name
-# CHECK-INST: csrrs t1, mhpmevent25, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent25
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent25, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent25
-# name
-csrrs t1, mhpmevent25, zero
-# uimm12
-csrrs t2, 0x339, zero
-
-# mhpmevent26
-# name
-# CHECK-INST: csrrs t1, mhpmevent26, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent26
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent26, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent26
-# name
-csrrs t1, mhpmevent26, zero
-# uimm12
-csrrs t2, 0x33A, zero
-
-# mhpmevent27
-# name
-# CHECK-INST: csrrs t1, mhpmevent27, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent27
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent27, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent27
-# name
-csrrs t1, mhpmevent27, zero
-# uimm12
-csrrs t2, 0x33B, zero
-
-# mhpmevent28
-# name
-# CHECK-INST: csrrs t1, mhpmevent28, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent28
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent28, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent28
-# name
-csrrs t1, mhpmevent28, zero
-# uimm12
-csrrs t2, 0x33C, zero
-
-# mhpmevent29
-# name
-# CHECK-INST: csrrs t1, mhpmevent29, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent29
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent29, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent29
-# name
-csrrs t1, mhpmevent29, zero
-# uimm12
-csrrs t2, 0x33D, zero
-
-# mhpmevent30
-# name
-# CHECK-INST: csrrs t1, mhpmevent30, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent30
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent30, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent30
-# name
-csrrs t1, mhpmevent30, zero
-# uimm12
-csrrs t2, 0x33E, zero
-
-# mhpmevent31
-# name
-# CHECK-INST: csrrs t1, mhpmevent31, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0x33]
-# CHECK-INST-ALIAS: csrr t1, mhpmevent31
-# uimm12
-# CHECK-INST: csrrs t2, mhpmevent31, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0x33]
-# CHECK-INST-ALIAS: csrr t2, mhpmevent31
-# name
-csrrs t1, mhpmevent31, zero
-# uimm12
-csrrs t2, 0x33F, zero
diff --git a/test/MC/RISCV/option-invalid.s b/test/MC/RISCV/option-invalid.s
deleted file mode 100644
index 8333f1c1997..00000000000
--- a/test/MC/RISCV/option-invalid.s
+++ /dev/null
@@ -1,26 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 \
-# RUN: | FileCheck -check-prefixes=CHECK %s
-
-# CHECK: error: unexpected token, expected identifier
-.option
-
-# CHECK: error: unexpected token, expected identifier
-.option 123
-
-# CHECK: error: unexpected token, expected identifier
-.option "str"
-
-# CHECK: error: unexpected token, expected end of statement
-.option rvc foo
-
-# CHECK: warning: unknown option, expected 'push', 'pop', 'rvc', 'norvc', 'relax' or 'norelax'
-.option bar
-
-# CHECK: error: .option pop with no .option push
-.option pop
-
-# CHECK: error: unexpected token, expected end of statement
-.option push 123
-
-# CHECK: error: unexpected token, expected end of statement
-.option pop 123
diff --git a/test/MC/RISCV/option-pushpop.s b/test/MC/RISCV/option-pushpop.s
deleted file mode 100644
index 9e3ae4156a4..00000000000
--- a/test/MC/RISCV/option-pushpop.s
+++ /dev/null
@@ -1,74 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=-relax -riscv-no-aliases < %s \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=CHECK-RELOC %s
-# RUN: llvm-mc -triple riscv32 -filetype=obj < %s \
-# RUN:     | llvm-objdump  -triple riscv32 -mattr=+c -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-
-# RUN: llvm-mc -triple riscv64 -mattr=-relax -riscv-no-aliases < %s \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=CHECK-RELOC %s
-# RUN: llvm-mc -triple riscv64 -filetype=obj < %s \
-# RUN:     | llvm-objdump  -triple riscv64 -mattr=+c -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-
-# Test the operation of the push and pop assembler directives when
-# using .option relax and .option rvc. Checks that using .option pop
-# correctly restores all target features to their state at the point
-# where .option pop was last used.
-
-# CHECK-INST: call foo
-# CHECK-RELOC: R_RISCV_CALL foo 0x0
-# CHECK-RELOC-NOT: R_RISCV_RELAX foo 0x0
-call foo
-
-# CHECK-INST: addi s0, sp, 1020
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-addi s0, sp, 1020
-
-.option push    # Push relax=false, rvc=false
-# CHECK-INST: .option push
-
-.option relax
-# CHECK-INST: .option relax
-# CHECK-INST: call bar
-# CHECK-RELOC-NEXT: R_RISCV_CALL bar 0x0
-# CHECK-RELOC-NEXT: R_RISCV_RELAX bar 0x0
-call bar
-
-.option push    # Push relax=true, rvc=false
-# CHECK-INST: .option push
-
-.option rvc
-# CHECK-INST: .option rvc
-# CHECK-INST: c.addi4spn s0, sp, 1020
-# CHECK-BYTES: e0 1f
-# CHECK-ALIAS: addi s0, sp, 1020
-addi s0, sp, 1020
-
-.option pop     # Pop relax=true, rvc=false
-# CHECK-INST: .option pop
-# CHECK-INST: addi s0, sp, 1020
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-addi s0, sp, 1020
-
-# CHECK-INST: call bar
-# CHECK-RELOC-NEXT: R_RISCV_CALL bar 0x0
-# CHECK-RELOC-NEXT: R_RISCV_RELAX bar 0x0
-call bar
-
-.option pop     # Pop relax=false, rvc=false
-# CHECK-INST: .option pop
-# CHECK-INST: call baz
-# CHECK-RELOC: R_RISCV_CALL baz 0x0
-# CHECK-RELOC-NOT: R_RISCV_RELAX baz 0x0
-call baz
-
-# CHECK-INST: addi s0, sp, 1020
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-addi s0, sp, 1020
diff --git a/test/MC/RISCV/option-relax.s b/test/MC/RISCV/option-relax.s
deleted file mode 100644
index 82ec24b710c..00000000000
--- a/test/MC/RISCV/option-relax.s
+++ /dev/null
@@ -1,66 +0,0 @@
-# RUN: llvm-mc -triple riscv32 < %s \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=CHECK-RELOC %s
-
-# RUN: llvm-mc -triple riscv64 < %s \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=CHECK-RELOC %s
-
-# Check .option relax causes R_RISCV_RELAX to be emitted, and .option
-# norelax suppresses it. Also check that if .option relax was enabled
-# at any point and an instruction may have been relaxed, diff & branch
-# relocations are emitted to ensure correct codegen. See
-# linker-relaxation.s and fixups-expr.s for behaviour of the relax
-# attribute.
-
-.L1:
-.option norelax
-# CHECK-INST: .option norelax
-
-# CHECK-INST: call foo
-# CHECK-RELOC: R_RISCV_CALL foo 0x0
-# CHECK-RELOC-NOT: R_RISCV_RELAX foo 0x0
-call foo
-
-# CHECK-RELOC-NEXT: R_RISCV_ADD64
-# CHECK-RELOC-NEXT: R_RISCV_SUB64
-.dword .L2-.L1
-# CHECK-RELOC-NEXT: R_RISCV_JAL
-jal zero, .L1
-# CHECK-RELOC-NEXT: R_RISCV_BRANCH
-beq s1, s1, .L1
-
-.L2:
-.option relax
-# CHECK-INST: .option relax
-
-# CHECK-INST: call bar
-# CHECK-RELOC-NEXT: R_RISCV_CALL bar 0x0
-# CHECK-RELOC-NEXT: R_RISCV_RELAX bar 0x0
-call bar
-
-# CHECK-RELOC-NEXT: R_RISCV_ADD64
-# CHECK-RELOC-NEXT: R_RISCV_SUB64
-.dword .L2-.L1
-# CHECK-RELOC-NEXT: R_RISCV_JAL
-jal zero, .L1
-# CHECK-RELOC-NEXT: R_RISCV_BRANCH
-beq s1, s1, .L1
-
-.option norelax
-# CHECK-INST: .option norelax
-
-# CHECK-INST: call baz
-# CHECK-RELOC-NEXT: R_RISCV_CALL baz 0x0
-# CHECK-RELOC-NOT: R_RISCV_RELAX baz 0x0
-call baz
-
-# CHECK-RELOC-NEXT: R_RISCV_ADD64
-# CHECK-RELOC-NEXT: R_RISCV_SUB64
-.dword .L2-.L1
-# CHECK-RELOC-NEXT: R_RISCV_JAL
-jal zero, .L1
-# CHECK-RELOC-NEXT: R_RISCV_BRANCH
-beq s1, s1, .L1
diff --git a/test/MC/RISCV/option-rvc.s b/test/MC/RISCV/option-rvc.s
deleted file mode 100644
index 129eae5bf79..00000000000
--- a/test/MC/RISCV/option-rvc.s
+++ /dev/null
@@ -1,90 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple riscv32 -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv32 -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv32 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# RUN: llvm-mc -triple riscv64 -show-encoding < %s \
-# RUN: | FileCheck -check-prefixes=CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -show-encoding \
-# RUN: -riscv-no-aliases <%s | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc -triple riscv64 -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-ALIAS %s
-# RUN: llvm-mc -triple riscv64 -filetype=obj < %s \
-# RUN: | llvm-objdump  -triple riscv64 -mattr=+c -d -riscv-no-aliases - \
-# RUN: | FileCheck -check-prefixes=CHECK-BYTES,CHECK-INST %s
-
-# CHECK-BYTES: 13 85 05 00
-# CHECK-ALIAS: mv a0, a1
-# CHECK-INST: addi a0, a1, 0
-# CHECK: # encoding:  [0x13,0x85,0x05,0x00]
-addi a0, a1, 0
-
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: addi s0, sp, 1020
-# CHECK: # encoding:  [0x13,0x04,0xc1,0x3f]
-addi s0, sp, 1020
-
-
-# CHECK: .option rvc
-.option rvc
-# CHECK-BYTES: 2e 85
-# CHECK-ALIAS: add a0, zero, a1
-# CHECK-INST: c.mv a0, a1
-# CHECK: # encoding:  [0x2e,0x85]
-addi a0, a1, 0
-
-# CHECK-BYTES: e0 1f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: c.addi4spn s0, sp, 1020
-# CHECK: # encoding:  [0xe0,0x1f]
-addi s0, sp, 1020
-
-# CHECK: .option norvc
-.option norvc
-# CHECK-BYTES: 13 85 05 00
-# CHECK-ALIAS: mv a0, a1
-# CHECK-INST: addi a0, a1, 0
-# CHECK: # encoding:  [0x13,0x85,0x05,0x00]
-addi a0, a1, 0
-
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: addi s0, sp, 1020
-# CHECK: # encoding:  [0x13,0x04,0xc1,0x3f]
-addi s0, sp, 1020
-
-# CHECK: .option rvc
-.option rvc
-# CHECK-BYTES: 2e 85
-# CHECK-ALIAS: add a0, zero, a1
-# CHECK-INST: c.mv a0, a1
-# CHECK: # encoding:  [0x2e,0x85]
-addi a0, a1, 0
-
-# CHECK-BYTES: e0 1f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: c.addi4spn s0, sp, 1020
-# CHECK: # encoding:  [0xe0,0x1f]
-addi s0, sp, 1020
-
-# CHECK: .option norvc
-.option norvc
-# CHECK-BYTES: 13 85 05 00
-# CHECK-ALIAS: mv a0, a1
-# CHECK-INST: addi a0, a1, 0
-# CHECK: # encoding:  [0x13,0x85,0x05,0x00]
-addi a0, a1, 0
-
-# CHECK-BYTES: 13 04 c1 3f
-# CHECK-ALIAS: addi s0, sp, 1020
-# CHECK-INST: addi s0, sp, 1020
-# CHECK: # encoding:  [0x13,0x04,0xc1,0x3f]
-addi s0, sp, 1020
diff --git a/test/MC/RISCV/pcrel-lo12-invalid.s b/test/MC/RISCV/pcrel-lo12-invalid.s
deleted file mode 100644
index 7cf2494ad8e..00000000000
--- a/test/MC/RISCV/pcrel-lo12-invalid.s
+++ /dev/null
@@ -1,5 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=-relax -filetype obj < %s -o /dev/null 2>&1 | FileCheck %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+relax -filetype obj < %s -o /dev/null 2>&1 | FileCheck %s
-
-1:
-  addi a0, a0, %pcrel_lo(1b) # CHECK: :[[@LINE]]:3: error: could not find corresponding %pcrel_hi
diff --git a/test/MC/RISCV/priv-invalid.s b/test/MC/RISCV/priv-invalid.s
deleted file mode 100644
index 8f421e471f9..00000000000
--- a/test/MC/RISCV/priv-invalid.s
+++ /dev/null
@@ -1,7 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-
-mret 0x10 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-
-sfence.vma zero, a1, a2 # CHECK: :[[@LINE]]:22: error: invalid operand for instruction
-
-sfence.vma a0, 0x10 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
diff --git a/test/MC/RISCV/priv-valid.s b/test/MC/RISCV/priv-valid.s
deleted file mode 100644
index 88d35f2f9ff..00000000000
--- a/test/MC/RISCV/priv-valid.s
+++ /dev/null
@@ -1,34 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: uret
-# CHECK: encoding: [0x73,0x00,0x20,0x00]
-uret
-
-# CHECK-INST: sret
-# CHECK: encoding: [0x73,0x00,0x20,0x10]
-sret
-
-# CHECK-INST: mret
-# CHECK: encoding: [0x73,0x00,0x20,0x30]
-mret
-
-# CHECK-INST: wfi
-# CHECK: encoding: [0x73,0x00,0x50,0x10]
-wfi
-
-# CHECK-INST: sfence.vma zero, zero
-# CHECK: encoding: [0x73,0x00,0x00,0x12]
-sfence.vma zero, zero
-
-# CHECK-INST: sfence.vma a0, a1
-# CHECK: encoding: [0x73,0x00,0xb5,0x12]
-sfence.vma a0, a1
diff --git a/test/MC/RISCV/relocations.s b/test/MC/RISCV/relocations.s
deleted file mode 100644
index a879c9a54ad..00000000000
--- a/test/MC/RISCV/relocations.s
+++ /dev/null
@@ -1,76 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -riscv-no-aliases < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=INSTR -check-prefix=FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-
-# Check prefixes:
-# RELOC - Check the relocation in the object.
-# FIXUP - Check the fixup on the instruction.
-# INSTR - Check the instruction is handled properly by the ASMPrinter
-
-.long foo
-# RELOC: R_RISCV_32 foo
-
-.quad foo
-# RELOC: R_RISCV_64 foo
-
-lui t1, %hi(foo)
-# RELOC: R_RISCV_HI20 foo 0x0
-# INSTR: lui t1, %hi(foo)
-# FIXUP: fixup A - offset: 0, value: %hi(foo), kind: fixup_riscv_hi20
-
-lui t1, %hi(foo+4)
-# RELOC: R_RISCV_HI20 foo 0x4
-# INSTR: lui t1, %hi(foo+4)
-# FIXUP: fixup A - offset: 0, value: %hi(foo+4), kind: fixup_riscv_hi20
-
-addi t1, t1, %lo(foo)
-# RELOC: R_RISCV_LO12_I foo 0x0
-# INSTR: addi t1, t1, %lo(foo)
-# FIXUP: fixup A - offset: 0, value: %lo(foo), kind: fixup_riscv_lo12_i
-
-addi t1, t1, %lo(foo+4)
-# RELOC: R_RISCV_LO12_I foo 0x4
-# INSTR: addi t1, t1, %lo(foo+4)
-# FIXUP: fixup A - offset: 0, value: %lo(foo+4), kind: fixup_riscv_lo12_i
-
-sb t1, %lo(foo)(a2)
-# RELOC: R_RISCV_LO12_S foo 0x0
-# INSTR: sb t1, %lo(foo)(a2)
-# FIXUP: fixup A - offset: 0, value: %lo(foo), kind: fixup_riscv_lo12_s
-
-sb t1, %lo(foo+4)(a2)
-# RELOC: R_RISCV_LO12_S foo 0x4
-# INSTR: sb t1, %lo(foo+4)(a2)
-# FIXUP: fixup A - offset: 0, value: %lo(foo+4), kind: fixup_riscv_lo12_s
-
-.L0:
-auipc t1, %pcrel_hi(foo)
-# RELOC: R_RISCV_PCREL_HI20 foo 0x0
-# INSTR: auipc t1, %pcrel_hi(foo)
-# FIXUP: fixup A - offset: 0, value: %pcrel_hi(foo), kind: fixup_riscv_pcrel_hi20
-
-auipc t1, %pcrel_hi(foo+4)
-# RELOC: R_RISCV_PCREL_HI20 foo 0x4
-# INSTR: auipc t1, %pcrel_hi(foo+4)
-# FIXUP: fixup A - offset: 0, value: %pcrel_hi(foo+4), kind: fixup_riscv_pcrel_hi20
-
-addi t1, t1, %pcrel_lo(.L0)
-# RELOC: R_RISCV_PCREL_LO12_I .L0 0x0
-# INSTR: addi t1, t1, %pcrel_lo(.L0)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(.L0), kind: fixup_riscv_pcrel_lo12_i
-
-sb t1, %pcrel_lo(.L0)(a2)
-# RELOC: R_RISCV_PCREL_LO12_S .L0 0x0
-# INSTR: sb t1, %pcrel_lo(.L0)(a2)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(.L0), kind: fixup_riscv_pcrel_lo12_s
-
-jal zero, foo
-# RELOC: R_RISCV_JAL
-# INSTR: jal zero, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_jal
-
-bgeu a0, a1, foo
-# RELOC: R_RISCV_BRANCH
-# INSTR: bgeu a0, a1, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_branch
diff --git a/test/MC/RISCV/rv32-machine-csr-names.s b/test/MC/RISCV/rv32-machine-csr-names.s
deleted file mode 100644
index 0f43088ab63..00000000000
--- a/test/MC/RISCV/rv32-machine-csr-names.s
+++ /dev/null
@@ -1,474 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-######################################
-# Machine Protection and Translation
-######################################
-
-# pmpcfg1
-# name
-# CHECK-INST: csrrs t1, pmpcfg1, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x3a]
-# CHECK-INST-ALIAS: csrr t1, pmpcfg1
-# uimm12
-# CHECK-INST: csrrs t2, pmpcfg1, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x3a]
-# CHECK-INST-ALIAS: csrr t2, pmpcfg1
-# name
-csrrs t1, pmpcfg1, zero
-# uimm12
-csrrs t2, 0x3A1, zero
-
-# pmpcfg3
-# name
-# CHECK-INST: csrrs t1, pmpcfg3, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x3a]
-# CHECK-INST-ALIAS: csrr t1, pmpcfg3
-# uimm12
-# CHECK-INST: csrrs t2, pmpcfg3, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x3a]
-# CHECK-INST-ALIAS: csrr t2, pmpcfg3
-# name
-csrrs t1, pmpcfg3, zero
-# uimm12
-csrrs t2, 0x3A3, zero
-
-######################################
-# Machine Counter and Timers
-######################################
-# mcycleh
-# name
-# CHECK-INST: csrrs t1, mcycleh, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mcycleh
-# uimm12
-# CHECK-INST: csrrs t2, mcycleh, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mcycleh
-csrrs t1, mcycleh, zero
-# uimm12
-csrrs t2, 0xB80, zero
-
-# minstreth
-# name
-# CHECK-INST: csrrs t1, minstreth, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0xb8]
-# CHECK-INST-ALIAS: csrr t1, minstreth
-# uimm12
-# CHECK-INST: csrrs t2, minstreth, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0xb8]
-# CHECK-INST-ALIAS: csrr t2, minstreth
-# name
-csrrs t1, minstreth, zero
-# uimm12
-csrrs t2, 0xB82, zero
-
-# mhpmcounter3h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter3h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter3h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter3h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter3h
-# name
-csrrs t1, mhpmcounter3h, zero
-# uimm12
-csrrs t2, 0xB83, zero
-
-# mhpmcounter4h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter4h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter4h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter4h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter4h
-# name
-csrrs t1, mhpmcounter4h, zero
-# uimm12
-csrrs t2, 0xB84, zero
-
-# mhpmcounter5h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter5h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter5h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter5h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter5h
-# name
-csrrs t1, mhpmcounter5h, zero
-# uimm12
-csrrs t2, 0xB85, zero
-
-# mhpmcounter6h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter6h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter6h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter6h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter6h
-# name
-csrrs t1, mhpmcounter6h, zero
-# uimm12
-csrrs t2, 0xB86, zero
-
-# mhpmcounter7h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter7h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter7h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter7h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter7h
-# name
-csrrs t1, mhpmcounter7h, zero
-# uimm12
-csrrs t2, 0xB87, zero
-
-# mhpmcounter8h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter8h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter8h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter8h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter8h
-# name
-csrrs t1, mhpmcounter8h, zero
-# uimm12
-csrrs t2, 0xB88, zero
-
-# mhpmcounter9h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter9h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter9h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter9h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter9h
-# name
-csrrs t1, mhpmcounter9h, zero
-# uimm12
-csrrs t2, 0xB89, zero
-
-# mhpmcounter10h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter10h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter10h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter10h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter10h
-# name
-csrrs t1, mhpmcounter10h, zero
-# uimm12
-csrrs t2, 0xB8A, zero
-
-# mhpmcounter11h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter11h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter11h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter11h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter11h
-# name
-csrrs t1, mhpmcounter11h, zero
-# uimm12
-csrrs t2, 0xB8B, zero
-
-# mhpmcounter12h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter12h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter12h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter12h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter12h
-# name
-csrrs t1, mhpmcounter12h, zero
-# uimm12
-csrrs t2, 0xB8C, zero
-
-# mhpmcounter13h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter13h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter13h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter13h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter13h
-# name
-csrrs t1, mhpmcounter13h, zero
-# uimm12
-csrrs t2, 0xB8D, zero
-
-# mhpmcounter14h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter14h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter14h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter14h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter14h
-# name
-csrrs t1, mhpmcounter14h, zero
-# uimm12
-csrrs t2, 0xB8E, zero
-
-# mhpmcounter15h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter15h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xb8]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter15h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter15h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter15h
-# name
-csrrs t1, mhpmcounter15h, zero
-# uimm12
-csrrs t2, 0xB8F, zero
-
-# mhpmcounter16h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter16h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter16h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter16h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter16h
-# name
-csrrs t1, mhpmcounter16h, zero
-# uimm12
-csrrs t2, 0xB90, zero
-
-# mhpmcounter17h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter17h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter17h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter17h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter17h
-# name
-csrrs t1, mhpmcounter17h, zero
-# uimm12
-csrrs t2, 0xB91, zero
-
-# mhpmcounter18h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter18h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter18h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter18h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter18h
-# name
-csrrs t1, mhpmcounter18h, zero
-# uimm12
-csrrs t2, 0xB92, zero
-
-# mhpmcounter19h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter19h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter19h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter19h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter19h
-# name
-csrrs t1, mhpmcounter19h, zero
-# uimm12
-csrrs t2, 0xB93, zero
-
-# mhpmcounter20h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter20h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter20h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter20h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter20h
-# name
-csrrs t1, mhpmcounter20h, zero
-# uimm12
-csrrs t2, 0xB94, zero
-
-# mhpmcounter21h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter21h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter21h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter21h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter21h
-# name
-csrrs t1, mhpmcounter21h, zero
-# uimm12
-csrrs t2, 0xB95, zero
-
-# mhpmcounter22h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter22h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter22h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter22h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter22h
-# name
-csrrs t1, mhpmcounter22h, zero
-# uimm12
-csrrs t2, 0xB96, zero
-
-# mhpmcounter23h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter23h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter23h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter23h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter23h
-# name
-csrrs t1, mhpmcounter23h, zero
-# uimm12
-csrrs t2, 0xB97, zero
-
-# mhpmcounter24h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter24h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter24h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter24h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter24h
-# name
-csrrs t1, mhpmcounter24h, zero
-# uimm12
-csrrs t2, 0xB98, zero
-
-# mhpmcounter25h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter25h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter25h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter25h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter25h
-# name
-csrrs t1, mhpmcounter25h, zero
-# uimm12
-csrrs t2, 0xB99, zero
-
-# mhpmcounter26h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter26h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter26h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter26h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter26h
-# name
-csrrs t1, mhpmcounter26h, zero
-# uimm12
-csrrs t2, 0xB9A, zero
-
-# mhpmcounter27h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter27h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter27h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter27h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter27h
-# name
-csrrs t1, mhpmcounter27h, zero
-# uimm12
-csrrs t2, 0xB9B, zero
-
-# mhpmcounter28h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter28h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter28h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter28h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter28h
-# name
-csrrs t1, mhpmcounter28h, zero
-# uimm12
-csrrs t2, 0xB9C, zero
-
-# mhpmcounter29h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter29h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter29h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter29h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter29h
-# name
-csrrs t1, mhpmcounter29h, zero
-# uimm12
-csrrs t2, 0xB9D, zero
-
-# mhpmcounter30h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter30h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter30h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter30h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter30h
-# name
-csrrs t1, mhpmcounter30h, zero
-# uimm12
-csrrs t2, 0xB9E, zero
-
-# mhpmcounter31h
-# name
-# CHECK-INST: csrrs t1, mhpmcounter31h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xb9]
-# CHECK-INST-ALIAS: csrr t1, mhpmcounter31h
-# uimm12
-# CHECK-INST: csrrs t2, mhpmcounter31h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, mhpmcounter31h
-# name
-csrrs t1, mhpmcounter31h, zero
-# uimm12
-csrrs t2, 0xB9F, zero
-
diff --git a/test/MC/RISCV/rv32-relaxation.s b/test/MC/RISCV/rv32-relaxation.s
deleted file mode 100644
index 09a833a790f..00000000000
--- a/test/MC/RISCV/rv32-relaxation.s
+++ /dev/null
@@ -1,127 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - | FileCheck -check-prefix=INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c,+relax < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - | FileCheck -check-prefix=RELAX-INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c,+relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX-RELOC %s
-
-FAR_JUMP_NEGATIVE:
-  c.nop
-.space 2000
-
-FAR_BRANCH_NEGATIVE:
-  c.nop
-.space 256
-
-NEAR_NEGATIVE:
-  c.nop
-
-start:
-  c.bnez a0, NEAR
-#INSTR: c.bnez a0, 72
-#RELAX-INSTR: c.bnez a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.bnez a0, NEAR_NEGATIVE
-#INSTR: c.bnez a0, -4
-#RELAX-INSTR: c.bnez a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.bnez a0, FAR_BRANCH
-#INSTR-NEXT: bne a0, zero, 326
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: bne a0, zero, -268
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_JUMP
-#INSTR-NEXT: bne a0, zero, 2320
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: bne a0, zero, -2278
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-
-  c.beqz a0, NEAR
-#INSTR-NEXT: c.beqz a0, 52
-#RELAX-INSTR-NEXT: c.beqz a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.beqz a0, NEAR_NEGATIVE
-#INSTR-NEXT: c.beqz a0, -24
-#RELAX-INSTR-NEXT: c.beqz a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.beqz a0, FAR_BRANCH
-#INSTR-NEXT: beq a0, zero, 306
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: beq a0, zero, -288
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_JUMP
-#INSTR-NEXT: beq a0, zero, 2300
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: beq a0, zero, -2298
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-
-  c.j NEAR
-#INSTR-NEXT: c.j 32
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j NEAR_NEGATIVE
-#INSTR-NEXT: c.j -44
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_BRANCH
-#INSTR-NEXT: c.j 286
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.j -306
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_JUMP
-#INSTR-NEXT: jal zero, 2284
-#RELAX-INSTR-NEXT: jal zero, 0
-#RELAX-RELOC: R_RISCV_JAL
-  c.j FAR_JUMP_NEGATIVE
-#INSTR-NEXT: jal zero, -2314
-#RELAX-INSTR-NEXT: jal zero, 0
-#RELAX-RELOC: R_RISCV_JAL
-
-  c.jal NEAR
-#INSTR: c.jal 16
-#RELAX-INSTR: c.jal 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.jal NEAR_NEGATIVE
-#INSTR: c.jal -60
-#RELAX-INSTR: c.jal 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.jal FAR_BRANCH
-#INSTR-NEXT: c.jal 270
-#RELAX-INSTR-NEXT: c.jal 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.jal FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.jal -322
-#RELAX-INSTR-NEXT: c.jal 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.jal FAR_JUMP
-#INSTR-NEXT: jal ra, 2268
-#RELAX-INSTR-NEXT: jal ra, 0
-#RELAX-RELOC: R_RISCV_JAL
-  c.jal FAR_JUMP_NEGATIVE
-#INSTR-NEXT: jal ra, -2330
-#RELAX-INSTR-NEXT: jal ra, 0
-#RELAX-RELOC: R_RISCV_JAL
-
-NEAR:
-  c.nop
-.space 256
-FAR_BRANCH:
-  c.nop
-.space 2000
-FAR_JUMP:
-  c.nop
diff --git a/test/MC/RISCV/rv32-user-csr-names.s b/test/MC/RISCV/rv32-user-csr-names.s
deleted file mode 100644
index acd66467bfe..00000000000
--- a/test/MC/RISCV/rv32-user-csr-names.s
+++ /dev/null
@@ -1,457 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-##################################
-# User Counter and Timers
-##################################
-
-# cycleh
-# name
-# CHECK-INST: csrrs t1, cycleh, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xc8]
-# CHECK-INST-ALIAS: rdcycleh t1
-# uimm12
-# CHECK-INST: csrrs t2, cycleh, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc8]
-# CHECK-INST-ALIAS: rdcycleh t2
-# name
-csrrs t1, cycleh, zero
-# uimm12
-csrrs t2, 0xC80, zero
-
-# timeh
-# name
-# CHECK-INST: csrrs t1, timeh, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xc8]
-# CHECK-INST-ALIAS: rdtimeh t1
-# uimm12
-# CHECK-INST: csrrs t2, timeh, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc8]
-# CHECK-INST-ALIAS: rdtimeh t2
-# name
-csrrs t1, timeh, zero
-# uimm12
-csrrs t2, 0xC81, zero
-
-# instreth
-# name
-# CHECK-INST: csrrs t1, instreth, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xc8]
-# CHECK-INST-ALIAS: rdinstreth t1
-# uimm12
-# CHECK-INST: csrrs t2, instreth, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc8]
-# CHECK-INST-ALIAS: rdinstreth t2
-# name
-csrrs t1, instreth, zero
-# uimm12
-csrrs t2, 0xC82, zero
-
-# hpmcounter3h
-# name
-# CHECK-INST: csrrs t1, hpmcounter3h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter3h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter3h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter3h
-# name
-csrrs t1, hpmcounter3h, zero
-# uimm12
-csrrs t2, 0xC83, zero
-
-# hpmcounter4h
-# name
-# CHECK-INST: csrrs t1, hpmcounter4h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter4h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter4h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter4h
-# name
-csrrs t1, hpmcounter4h, zero
-# uimm12
-csrrs t2, 0xC84, zero
-
-# hpmcounter5h
-# name
-# CHECK-INST: csrrs t1, hpmcounter5h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter5h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter5h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter5h
-# name
-csrrs t1, hpmcounter5h, zero
-# uimm12
-csrrs t2, 0xC85, zero
-
-# hpmcounter6h
-# name
-# CHECK-INST: csrrs t1, hpmcounter6h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter6h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter6h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter6h
-# name
-csrrs t1, hpmcounter6h, zero
-# uimm12
-csrrs t2, 0xC86, zero
-
-# hpmcounter7h
-# name
-# CHECK-INST: csrrs t1, hpmcounter7h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter7h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter7h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter7h
-# name
-csrrs t1, hpmcounter7h, zero
-# uimm12
-csrrs t2, 0xC87, zero
-
-# hpmcounter8h
-# name
-# CHECK-INST: csrrs t1, hpmcounter8h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter8h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter8h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter8h
-# name
-csrrs t1, hpmcounter8h, zero
-# uimm12
-csrrs t2, 0xC88, zero
-
-# hpmcounter9h
-# name
-# CHECK-INST: csrrs t1, hpmcounter9h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter9h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter9h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter9h
-# name
-csrrs t1, hpmcounter9h, zero
-# uimm12
-csrrs t2, 0xC89, zero
-
-# hpmcounter10h
-# name
-# CHECK-INST: csrrs t1, hpmcounter10h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter10h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter10h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter10h
-# name
-csrrs t1, hpmcounter10h, zero
-# uimm12
-csrrs t2, 0xC8A, zero
-
-# hpmcounter11h
-# name
-# CHECK-INST: csrrs t1, hpmcounter11h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter11h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter11h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter11h
-# name
-csrrs t1, hpmcounter11h, zero
-# uimm12
-csrrs t2, 0xC8B, zero
-
-# hpmcounter12h
-# name
-# CHECK-INST: csrrs t1, hpmcounter12h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter12h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter12h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter12h
-# name
-csrrs t1, hpmcounter12h, zero
-# uimm12
-csrrs t2, 0xC8C, zero
-
-# hpmcounter13h
-# name
-# CHECK-INST: csrrs t1, hpmcounter13h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter13h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter13h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter13h
-# name
-csrrs t1, hpmcounter13h, zero
-# uimm12
-csrrs t2, 0xC8D, zero
-
-# hpmcounter14h
-# name
-# CHECK-INST: csrrs t1, hpmcounter14h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter14h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter14h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter14h
-# name
-csrrs t1, hpmcounter14h, zero
-# uimm12
-csrrs t2, 0xC8E, zero
-
-# hpmcounter15h
-# name
-# CHECK-INST: csrrs t1, hpmcounter15h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xc8]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter15h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter15h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter15h
-# name
-csrrs t1, hpmcounter15h, zero
-# uimm12
-csrrs t2, 0xC8F, zero
-
-# hpmcounter16h
-# name
-# CHECK-INST: csrrs t1, hpmcounter16h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter16h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter16h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter16h
-# name
-csrrs t1, hpmcounter16h, zero
-# uimm12
-csrrs t2, 0xC90, zero
-
-# hpmcounter17h
-# name
-# CHECK-INST: csrrs t1, hpmcounter17h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter17h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter17h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter17h
-# name
-csrrs t1, hpmcounter17h, zero
-# uimm12
-csrrs t2, 0xC91, zero
-
-# hpmcounter18h
-# name
-# CHECK-INST: csrrs t1, hpmcounter18h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter18h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter18h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter18h
-# name
-csrrs t1, hpmcounter18h, zero
-# uimm12
-csrrs t2, 0xC92, zero
-
-# hpmcounter19h
-# name
-# CHECK-INST: csrrs t1, hpmcounter19h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter19h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter19h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter19h
-# name
-csrrs t1, hpmcounter19h, zero
-# uimm12
-csrrs t2, 0xC93, zero
-
-# hpmcounter20h
-# name
-# CHECK-INST: csrrs t1, hpmcounter20h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter20h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter20h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter20h
-# name
-csrrs t1, hpmcounter20h, zero
-# uimm12
-csrrs t2, 0xC94, zero
-
-# hpmcounter21h
-# name
-# CHECK-INST: csrrs t1, hpmcounter21h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter21h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter21h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter21h
-# name
-csrrs t1, hpmcounter21h, zero
-# uimm12
-csrrs t2, 0xC95, zero
-
-# hpmcounter22h
-# name
-# CHECK-INST: csrrs t1, hpmcounter22h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter22h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter22h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter22h
-# name
-csrrs t1, hpmcounter22h, zero
-# uimm12
-csrrs t2, 0xC96, zero
-
-# hpmcounter23h
-# name
-# CHECK-INST: csrrs t1, hpmcounter23h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter23h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter23h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter23h
-# name
-csrrs t1, hpmcounter23h, zero
-# uimm12
-csrrs t2, 0xC97, zero
-
-# hpmcounter24h
-# name
-# CHECK-INST: csrrs t1, hpmcounter24h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter24h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter24h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter24h
-# name
-csrrs t1, hpmcounter24h, zero
-# uimm12
-csrrs t2, 0xC98, zero
-
-# hpmcounter25h
-# name
-# CHECK-INST: csrrs t1, hpmcounter25h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter25h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter25h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter25h
-# name
-csrrs t1, hpmcounter25h, zero
-# uimm12
-csrrs t2, 0xC99, zero
-
-# hpmcounter26h
-# name
-# CHECK-INST: csrrs t1, hpmcounter26h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter26h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter26h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter26h
-# name
-csrrs t1, hpmcounter26h, zero
-# uimm12
-csrrs t2, 0xC9A, zero
-
-# hpmcounter27h
-# name
-# CHECK-INST: csrrs t1, hpmcounter27h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter27h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter27h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter27h
-# name
-csrrs t1, hpmcounter27h, zero
-# uimm12
-csrrs t2, 0xC9B, zero
-
-# hpmcounter28h
-# name
-# CHECK-INST: csrrs t1, hpmcounter28h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter28h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter28h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter28h
-# name
-csrrs t1, hpmcounter28h, zero
-# uimm12
-csrrs t2, 0xC9C, zero
-
-# hpmcounter29h
-# name
-# CHECK-INST: csrrs t1, hpmcounter29h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter29h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter29h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter29h
-# name
-csrrs t1, hpmcounter29h, zero
-# uimm12
-csrrs t2, 0xC9D, zero
-
-# hpmcounter30h
-# name
-# CHECK-INST: csrrs t1, hpmcounter30h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter30h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter30h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter30h
-# name
-csrrs t1, hpmcounter30h, zero
-# uimm12
-csrrs t2, 0xC9E, zero
-
-# hpmcounter31h
-# name
-# CHECK-INST: csrrs t1, hpmcounter31h, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xc9]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter31h
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter31h, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter31h
-# name
-csrrs t1, hpmcounter31h, zero
-# uimm12
-csrrs t2, 0xC9F, zero
diff --git a/test/MC/RISCV/rv32a-invalid.s b/test/MC/RISCV/rv32a-invalid.s
deleted file mode 100644
index 8ee21bc501b..00000000000
--- a/test/MC/RISCV/rv32a-invalid.s
+++ /dev/null
@@ -1,17 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+a < %s 2>&1 | FileCheck %s
-
-# Final operand must have parentheses
-amoswap.w a1, a2, a3 # CHECK: :[[@LINE]]:19: error: invalid operand for instruction
-amomin.w a1, a2, 1 # CHECK: :[[@LINE]]:18: error: invalid operand for instruction
-lr.w a4, a5 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Only .aq, .rl, and .aqrl suffixes are valid
-amoxor.w.rlqa a2, a3, (a4) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.w.aq.rl a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.w. a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# lr only takes two operands
-lr.w s0, (s1), s2 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
-
-# Note: errors for use of RV64A instructions for RV32 are checked in
-# rv64a-valid.s
diff --git a/test/MC/RISCV/rv32a-valid.s b/test/MC/RISCV/rv32a-valid.s
deleted file mode 100644
index 9b1b9f92c4c..00000000000
--- a/test/MC/RISCV/rv32a-valid.s
+++ /dev/null
@@ -1,148 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: lr.w t0, (t1)
-# CHECK-ASM: encoding: [0xaf,0x22,0x03,0x10]
-lr.w t0, (t1)
-# CHECK-ASM-AND-OBJ: lr.w.aq t1, (t2)
-# CHECK-ASM: encoding: [0x2f,0xa3,0x03,0x14]
-lr.w.aq t1, (t2)
-# CHECK-ASM-AND-OBJ: lr.w.rl t2, (t3)
-# CHECK-ASM: encoding: [0xaf,0x23,0x0e,0x12]
-lr.w.rl t2, (t3)
-# CHECK-ASM-AND-OBJ: lr.w.aqrl t3, (t4)
-# CHECK-ASM: encoding: [0x2f,0xae,0x0e,0x16]
-lr.w.aqrl t3, (t4)
-
-# CHECK-ASM-AND-OBJ: sc.w t6, t5, (t4)
-# CHECK-ASM: encoding: [0xaf,0xaf,0xee,0x19]
-sc.w t6, t5, (t4)
-# CHECK-ASM-AND-OBJ: sc.w.aq t5, t4, (t3)
-# CHECK-ASM: encoding: [0x2f,0x2f,0xde,0x1d]
-sc.w.aq t5, t4, (t3)
-# CHECK-ASM-AND-OBJ: sc.w.rl t4, t3, (t2)
-# CHECK-ASM: encoding: [0xaf,0xae,0xc3,0x1b]
-sc.w.rl t4, t3, (t2)
-# CHECK-ASM-AND-OBJ: sc.w.aqrl t3, t2, (t1)
-# CHECK-ASM: encoding: [0x2f,0x2e,0x73,0x1e]
-sc.w.aqrl t3, t2, (t1)
-
-# CHECK-ASM-AND-OBJ: amoswap.w a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x27,0x14,0x08]
-amoswap.w a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.w a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xa5,0xc6,0x00]
-amoadd.w a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.w a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x26,0xd7,0x20]
-amoxor.w a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.w a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xa6,0xe7,0x60]
-amoand.w a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.w a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x27,0xf8,0x40]
-amoor.w a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.w a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xa7,0x08,0x81]
-amomin.w a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.w s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xab,0x6a,0xa1]
-amomax.w s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.w s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x2b,0x5a,0xc1]
-amominu.w s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.w s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xaa,0x49,0xe1]
-amomaxu.w s5, s4, (s3)
-
-# CHECK-ASM-AND-OBJ: amoswap.w.aq a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x27,0x14,0x0c]
-amoswap.w.aq a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.w.aq a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xa5,0xc6,0x04]
-amoadd.w.aq a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.w.aq a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x26,0xd7,0x24]
-amoxor.w.aq a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.w.aq a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xa6,0xe7,0x64]
-amoand.w.aq a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.w.aq a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x27,0xf8,0x44]
-amoor.w.aq a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.w.aq a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xa7,0x08,0x85]
-amomin.w.aq a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.w.aq s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xab,0x6a,0xa5]
-amomax.w.aq s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.w.aq s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x2b,0x5a,0xc5]
-amominu.w.aq s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.w.aq s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xaa,0x49,0xe5]
-amomaxu.w.aq s5, s4, (s3)
-
-# CHECK-ASM-AND-OBJ: amoswap.w.rl a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x27,0x14,0x0a]
-amoswap.w.rl a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.w.rl a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xa5,0xc6,0x02]
-amoadd.w.rl a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.w.rl a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x26,0xd7,0x22]
-amoxor.w.rl a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.w.rl a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xa6,0xe7,0x62]
-amoand.w.rl a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.w.rl a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x27,0xf8,0x42]
-amoor.w.rl a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.w.rl a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xa7,0x08,0x83]
-amomin.w.rl a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.w.rl s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xab,0x6a,0xa3]
-amomax.w.rl s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.w.rl s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x2b,0x5a,0xc3]
-amominu.w.rl s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.w.rl s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xaa,0x49,0xe3]
-amomaxu.w.rl s5, s4, (s3)
-
-# CHECK-ASM-AND-OBJ: amoswap.w.aqrl a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x27,0x14,0x0e]
-amoswap.w.aqrl a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.w.aqrl a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xa5,0xc6,0x06]
-amoadd.w.aqrl a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.w.aqrl a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x26,0xd7,0x26]
-amoxor.w.aqrl a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.w.aqrl a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xa6,0xe7,0x66]
-amoand.w.aqrl a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.w.aqrl a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x27,0xf8,0x46]
-amoor.w.aqrl a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.w.aqrl a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xa7,0x08,0x87]
-amomin.w.aqrl a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.w.aqrl s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xab,0x6a,0xa7]
-amomax.w.aqrl s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.w.aqrl s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x2b,0x5a,0xc7]
-amominu.w.aqrl s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.w.aqrl s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xaa,0x49,0xe7]
-amomaxu.w.aqrl s5, s4, (s3)
diff --git a/test/MC/RISCV/rv32c-aliases-valid.s b/test/MC/RISCV/rv32c-aliases-valid.s
deleted file mode 100644
index f9c07e23a84..00000000000
--- a/test/MC/RISCV/rv32c-aliases-valid.s
+++ /dev/null
@@ -1,65 +0,0 @@
-# RUN: llvm-mc -triple=riscv32 -mattr=+c -riscv-no-aliases < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-
-# The following check prefixes are used in this test:
-# CHECK-INST.....Match the canonical instr (tests alias to instr. mapping)
-# CHECK-EXPAND...Match canonical instr. unconditionally (tests alias expansion)
-
-# CHECK-EXPAND: c.li a0, 0
-li x10, 0
-# CHECK-EXPAND: c.li a0, 1
-li x10, 1
-# CHECK-EXPAND: c.li a0, -1
-li x10, -1
-# CHECK-EXPAND: addi a0, zero, 2047
-li x10, 2047
-# CHECK-EXPAND: addi a0, zero, -2047
-li x10, -2047
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: addi a1, a1, -2048
-li x11, 2048
-# CHECK-EXPAND: addi a1, zero, -2048
-li x11, -2048
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: addi a1, a1, -2047
-li x11, 2049
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: addi a1, a1, 2047
-li x11, -2049
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: c.addi a1, -1
-li x11, 4095
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: c.addi a1, 1
-li x11, -4095
-# CHECK-EXPAND: c.lui a2, 1
-li x12, 4096
-# CHECK-EXPAND: lui a2, 1048575
-li x12, -4096
-# CHECK-EXPAND: c.lui a2, 1
-# CHECK-EXPAND: c.addi a2, 1
-li x12, 4097
-# CHECK-EXPAND: lui a2, 1048575
-# CHECK-EXPAND: c.addi a2, -1
-li x12, -4097
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: c.addi a2, -1
-li x12, 2147483647
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: c.addi a2, 1
-li x12, -2147483647
-# CHECK-EXPAND: lui a2, 524288
-li x12, -2147483648
-# CHECK-EXPAND: lui a2, 524288
-li x12, -0x80000000
-
-# CHECK-EXPAND: lui a2, 524288
-li x12, 0x80000000
-# CHECK-EXPAND: c.li a2, -1
-li x12, 0xFFFFFFFF
-
-# CHECK-EXPAND: c.mv sp, sp
-addi x2, x2, 0
diff --git a/test/MC/RISCV/rv32c-fuzzed-invalid.s b/test/MC/RISCV/rv32c-fuzzed-invalid.s
deleted file mode 100644
index 0fa3b8137a1..00000000000
--- a/test/MC/RISCV/rv32c-fuzzed-invalid.s
+++ /dev/null
@@ -1,17 +0,0 @@
-# REQUIRES: asserts
-# RUN: not llvm-mc -triple riscv32 -mattr=+c,+f,+d < %s 2>&1 | FileCheck %s
-#
-# Fuzzed test cases produced by a LLVM MC Assembler
-# Protocol Buffer Fuzzer for the RISC-V assembly language.
-#
-
-c.addi x13,f30,0    # CHECK: error: immediate must be non-zero in the range [-32, 31]
-c.swsp x0,(f14)     # CHECK: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-c.lui x4,x0         # CHECK: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.li x6,x6,x0,x0    # CHECK: error: immediate must be an integer in the range [-32, 31]
-c.addi16sp 2,(x0)   # CHECK: error: invalid operand for instruction
-c.fsdsp f9,x0,0     # CHECK: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-c.flw f15,x14,x0    # CHECK: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-c.fld f8,f30,x17    # CHECK: error: immediate must be a multiple of 8 bytes in the range [0, 248]
-c.addi4spn x8,x2,x8 # CHECK: error: immediate must be a multiple of 4 bytes in the range [4, 1020]
-
diff --git a/test/MC/RISCV/rv32c-invalid.s b/test/MC/RISCV/rv32c-invalid.s
deleted file mode 100644
index 9981f67b5e1..00000000000
--- a/test/MC/RISCV/rv32c-invalid.s
+++ /dev/null
@@ -1,92 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c < %s 2>&1 | FileCheck %s
-
-## GPRC
-.LBB:
-c.lw  ra, 4(sp) # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.sw  sp, 4(sp) # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.beqz  t0, .LBB # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.bnez  s8, .LBB # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.addi4spn  s4, sp, 12 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-c.srli  s7, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.srai  t0, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.andi  t1, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.and  t1, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-c.or   a0, s8 # CHECK: :[[@LINE]]:12: error: invalid operand for instruction
-c.xor  t2, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-c.sub  a0, s8 # CHECK: :[[@LINE]]:12: error: invalid operand for instruction
-
-## GPRNoX0
-c.lwsp  x0, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.lwsp  zero, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.jr  x0 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.jalr  zero # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.addi  x0, x0, 1 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.li  zero, 2 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.slli  zero, zero, 4 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.mv  zero, s0 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.mv  ra, x0 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-c.add  ra, ra, x0 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
-c.add  zero, zero, sp # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## GPRNoX0X2
-c.lui x0, 4 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.lui x2, 4 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-
-## SP
-c.addi4spn  a0, a0, 12 # CHECK: :[[@LINE]]:17: error: invalid operand for instruction
-c.addi16sp  t0, 16 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-
-# Out of range immediates
-
-## uimmlog2xlennonzero
-c.slli t0, 64 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-c.srli a0, 32 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-c.srai a0, 0  # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-
-## simm6
-c.li t0, 128 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-32, 31]
-c.li t0, foo # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-32, 31]
-c.li t0, %lo(foo) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-32, 31]
-c.li t0, %hi(foo) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-32, 31]
-c.andi a0, -33 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [-32, 31]
-c.andi a0, foo # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [-32, 31]
-c.andi a0, %lo(foo) # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [-32, 31]
-c.andi a0, %hi(foo) # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [-32, 31]
-
-## simm6nonzero
-c.addi t0, 0 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, -33 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, 32 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, foo # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, %lo(foo) # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, %hi(foo) # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-
-## c_lui_imm
-c.lui t0, 0 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 32 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 0xffffdf # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 0x1000000 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-
-## uimm8_lsb00
-c.lwsp  ra, 256(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-c.swsp  ra, -4(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-## uimm7_lsb00
-c.lw  s0, -4(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-c.sw  s0, 128(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-
-## simm9_lsb0
-c.bnez  s1, -258 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-256, 254]
-c.beqz  a0, 256 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-256, 254]
-
-## simm12_lsb0
-c.j 2048 # CHECK: :[[@LINE]]:5: error: immediate must be a multiple of 2 bytes in the range [-2048, 2046]
-c.jal -2050 # CHECK: :[[@LINE]]:7: error: immediate must be a multiple of 2 bytes in the range [-2048, 2046]
-
-## uimm10_lsb00nonzero
-c.addi4spn  a0, sp, 0 # CHECK: :[[@LINE]]:21: error: immediate must be a multiple of 4 bytes in the range [4, 1020]
-c.addi4spn  a0, sp, 1024 # CHECK: :[[@LINE]]:21: error: immediate must be a multiple of 4 bytes in the range [4, 1020]
-
-## simm10_lsb0000nonzero
-c.addi16sp  sp, -528 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
-c.addi16sp  sp, 512 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
-c.addi16sp  sp, 0 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
diff --git a/test/MC/RISCV/rv32c-only-valid.s b/test/MC/RISCV/rv32c-only-valid.s
deleted file mode 100644
index b2fc4152594..00000000000
--- a/test/MC/RISCV/rv32c-only-valid.s
+++ /dev/null
@@ -1,19 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -mattr=+c -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv64 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# FIXME: error message for c.jal with rv64c is misleading
-
-# CHECK-ASM-AND-OBJ: c.jal 2046
-# CHECK-ASM: encoding: [0xfd,0x2f]
-# CHECK-NO-EXT: error: instruction use requires an option to be enabled
-c.jal 2046
diff --git a/test/MC/RISCV/rv32c-valid.s b/test/MC/RISCV/rv32c-valid.s
deleted file mode 100644
index b72e4922a57..00000000000
--- a/test/MC/RISCV/rv32c-valid.s
+++ /dev/null
@@ -1,108 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -mattr=+c -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+c -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -mattr=+c -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# TODO: more exhaustive testing of immediate encoding.
-
-# CHECK-ASM-AND-OBJ: c.lwsp ra, 0(sp)
-# CHECK-ASM: encoding: [0x82,0x40]
-c.lwsp ra, 0(sp)
-# CHECK-ASM-AND-OBJ: c.swsp ra, 252(sp)
-# CHECK-ASM: encoding: [0x86,0xdf]
-c.swsp ra, 252(sp)
-# CHECK-ASM-AND-OBJ: c.lw a2, 0(a0)
-# CHECK-ASM: encoding: [0x10,0x41]
-c.lw a2, 0(a0)
-# CHECK-ASM-AND-OBJ: c.sw a5, 124(a3)
-# CHECK-ASM: encoding: [0xfc,0xde]
-c.sw a5, 124(a3)
-
-# CHECK-ASM-AND-OBJ: c.j -2048
-# CHECK-ASM: encoding: [0x01,0xb0]
-c.j -2048
-# CHECK-ASM-AND-OBJ: c.jr a7
-# CHECK-ASM: encoding: [0x82,0x88]
-c.jr a7
-# CHECK-ASM-AND-OBJ: c.jalr a1
-# CHECK-ASM: encoding: [0x82,0x95]
-c.jalr a1
-# CHECK-ASM-AND-OBJ: c.beqz a3, -256
-# CHECK-ASM: encoding: [0x81,0xd2]
-c.beqz a3, -256
-# CHECK-ASM-AND-OBJ: c.bnez a5, 254
-# CHECK-ASM: encoding: [0xfd,0xef]
-c.bnez a5,  254
-
-# CHECK-ASM-AND-OBJ: c.li a7, 31
-# CHECK-ASM: encoding: [0xfd,0x48]
-c.li a7, 31
-# CHECK-ASM-AND-OBJ: c.addi a3, -32
-# CHECK-ASM: encoding: [0x81,0x16]
-c.addi a3, -32
-# CHECK-ASM-AND-OBJ: c.addi16sp sp, -512
-# CHECK-ASM: encoding: [0x01,0x71]
-c.addi16sp sp, -512
-# CHECK-ASM-AND-OBJ: c.addi16sp sp, 496
-# CHECK-ASM: encoding: [0x7d,0x61]
-c.addi16sp sp, 496
-# CHECK-ASM-AND-OBJ: c.addi4spn a3, sp, 1020
-# CHECK-ASM: encoding: [0xf4,0x1f]
-c.addi4spn a3, sp, 1020
-# CHECK-ASM-AND-OBJ: c.addi4spn a3, sp, 4
-# CHECK-ASM: encoding: [0x54,0x00]
-c.addi4spn a3, sp, 4
-# CHECK-ASM-AND-OBJ: c.slli a1, 1
-# CHECK-ASM: encoding: [0x86,0x05]
-c.slli a1, 1
-# CHECK-ASM-AND-OBJ: c.srli a3, 31
-# CHECK-ASM: encoding: [0xfd,0x82]
-c.srli a3, 31
-# CHECK-ASM-AND-OBJ: c.srai a4, 2
-# CHECK-ASM: encoding: [0x09,0x87]
-c.srai a4, 2
-# CHECK-ASM-AND-OBJ: c.andi a5, 15
-# CHECK-ASM: encoding: [0xbd,0x8b]
-c.andi a5, 15
-# CHECK-ASM-AND-OBJ: c.mv a7, s0
-# CHECK-ASM: encoding: [0xa2,0x88]
-c.mv a7, s0
-# CHECK-ASM-AND-OBJ: c.and a1, a2
-# CHECK-ASM: encoding: [0xf1,0x8d]
-c.and a1, a2
-# CHECK-ASM-AND-OBJ: c.or a2, a3
-# CHECK-ASM: encoding: [0x55,0x8e]
-c.or a2, a3
-# CHECK-ASM-AND-OBJ: c.xor a3, a4
-# CHECK-ASM: encoding: [0xb9,0x8e]
-c.xor a3, a4
-# CHECK-ASM-AND-OBJ: c.sub a4, a5
-# CHECK-ASM: encoding: [0x1d,0x8f]
-c.sub a4, a5
-# CHECK-ASM-AND-OBJ: c.nop
-# CHECK-ASM: encoding: [0x01,0x00]
-c.nop
-# CHECK-ASM-AND-OBJ: c.ebreak
-# CHECK-ASM: encoding: [0x02,0x90]
-c.ebreak
-# CHECK-ASM-AND-OBJ: c.lui s0, 1
-# CHECK-ASM: encoding: [0x05,0x64]
-c.lui s0, 1
-# CHECK-ASM-AND-OBJ: c.lui s0, 31
-# CHECK-ASM: encoding: [0x7d,0x64]
-c.lui s0, 31
-# CHECK-ASM-AND-OBJ: c.lui s0, 1048544
-# CHECK-ASM: encoding: [0x01,0x74]
-c.lui s0, 0xfffe0
-# CHECK-ASM-AND-OBJ: c.lui s0, 1048575
-# CHECK-ASM: encoding: [0x7d,0x74]
-c.lui s0, 0xfffff
-# CHECK-ASM-AND-OBJ: c.unimp
-# CHECK-ASM: encoding: [0x00,0x00]
-c.unimp
diff --git a/test/MC/RISCV/rv32d-invalid.s b/test/MC/RISCV/rv32d-invalid.s
deleted file mode 100644
index d6f5e722f82..00000000000
--- a/test/MC/RISCV/rv32d-invalid.s
+++ /dev/null
@@ -1,21 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+d < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## simm12
-fld ft1, -2049(a0) # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-fsd ft2, 2048(a1) # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Memory operand not formatted correctly
-fld ft1, a0, -200 # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-fsd ft2, a1, 100 # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Invalid register names
-fld ft15, 100(a0) # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-fld ft1, 100(a10) # CHECK: :[[@LINE]]:14: error: expected register
-fsgnjn.d fa100, fa2, fa3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Integer registers where FP regs are expected
-fadd.d a2, a1, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.wu.d ft2, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv32d-valid.s b/test/MC/RISCV/rv32d-valid.s
deleted file mode 100644
index 551a51500dd..00000000000
--- a/test/MC/RISCV/rv32d-valid.s
+++ /dev/null
@@ -1,161 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# Support for the 'D' extension implies support for 'F'
-# CHECK-ASM-AND-OBJ: fadd.s fs10, fs11, ft8
-# CHECK-ASM: encoding: [0x53,0xfd,0xcd,0x01]
-fadd.s f26, f27, f28
-
-# CHECK-ASM-AND-OBJ: fld ft0, 12(a0)
-# CHECK-ASM: encoding: [0x07,0x30,0xc5,0x00]
-fld f0, 12(a0)
-# CHECK-ASM-AND-OBJ: fld ft1, 4(ra)
-# CHECK-ASM: encoding: [0x87,0xb0,0x40,0x00]
-fld f1, +4(ra)
-# CHECK-ASM-AND-OBJ: fld ft2, -2048(a3)
-# CHECK-ASM: encoding: [0x07,0xb1,0x06,0x80]
-fld f2, -2048(x13)
-# CHECK-ASM-AND-OBJ: fld ft3, -2048(s1)
-# CHECK-ASM: encoding: [0x87,0xb1,0x04,0x80]
-fld f3, %lo(2048)(s1)
-# CHECK-ASM-AND-OBJ: fld ft4, 2047(s2)
-# CHECK-ASM: encoding: [0x07,0x32,0xf9,0x7f]
-fld f4, 2047(s2)
-# CHECK-ASM-AND-OBJ: fld ft5, 0(s3)
-# CHECK-ASM: encoding: [0x87,0xb2,0x09,0x00]
-fld f5, 0(s3)
-
-# CHECK-ASM-AND-OBJ: fsd ft6, 2047(s4)
-# CHECK-ASM: encoding: [0xa7,0x3f,0x6a,0x7e]
-fsd f6, 2047(s4)
-# CHECK-ASM-AND-OBJ: fsd ft7, -2048(s5)
-# CHECK-ASM: encoding: [0x27,0xb0,0x7a,0x80]
-fsd f7, -2048(s5)
-# CHECK-ASM-AND-OBJ: fsd fs0, -2048(s6)
-# CHECK-ASM: encoding: [0x27,0x30,0x8b,0x80]
-fsd f8, %lo(2048)(s6)
-# CHECK-ASM-AND-OBJ: fsd fs1, 999(s7)
-# CHECK-ASM: encoding: [0xa7,0xb3,0x9b,0x3e]
-fsd f9, 999(s7)
-
-# CHECK-ASM-AND-OBJ: fmadd.d fa0, fa1, fa2, fa3, dyn
-# CHECK-ASM: encoding: [0x43,0xf5,0xc5,0x6a]
-fmadd.d f10, f11, f12, f13, dyn
-# CHECK-ASM-AND-OBJ: fmsub.d fa4, fa5, fa6, fa7, dyn
-# CHECK-ASM: encoding: [0x47,0xf7,0x07,0x8b]
-fmsub.d f14, f15, f16, f17, dyn
-# CHECK-ASM-AND-OBJ: fnmsub.d fs2, fs3, fs4, fs5, dyn
-# CHECK-ASM: encoding: [0x4b,0xf9,0x49,0xab]
-fnmsub.d f18, f19, f20, f21, dyn
-# CHECK-ASM-AND-OBJ: fnmadd.d fs6, fs7, fs8, fs9, dyn
-# CHECK-ASM: encoding: [0x4f,0xfb,0x8b,0xcb]
-fnmadd.d f22, f23, f24, f25, dyn
-
-# CHECK-ASM-AND-OBJ: fadd.d fs10, fs11, ft8, dyn
-# CHECK-ASM: encoding: [0x53,0xfd,0xcd,0x03]
-fadd.d f26, f27, f28, dyn
-# CHECK-ASM-AND-OBJ: fsub.d ft9, ft10, ft11, dyn
-# CHECK-ASM: encoding: [0xd3,0x7e,0xff,0x0b]
-fsub.d f29, f30, f31, dyn
-# CHECK-ASM-AND-OBJ: fmul.d ft0, ft1, ft2, dyn
-# CHECK-ASM: encoding: [0x53,0xf0,0x20,0x12]
-fmul.d ft0, ft1, ft2, dyn
-# CHECK-ASM-AND-OBJ: fdiv.d ft3, ft4, ft5, dyn
-# CHECK-ASM: encoding: [0xd3,0x71,0x52,0x1a]
-fdiv.d ft3, ft4, ft5, dyn
-# CHECK-ASM-AND-OBJ: fsqrt.d ft6, ft7, dyn
-# CHECK-ASM: encoding: [0x53,0xf3,0x03,0x5a]
-fsqrt.d ft6, ft7, dyn
-# CHECK-ASM-AND-OBJ: fsgnj.d fs1, fa0, fa1
-# CHECK-ASM: encoding: [0xd3,0x04,0xb5,0x22]
-fsgnj.d fs1, fa0, fa1
-# CHECK-ASM-AND-OBJ: fsgnjn.d fa1, fa3, fa4
-# CHECK-ASM: encoding: [0xd3,0x95,0xe6,0x22]
-fsgnjn.d fa1, fa3, fa4
-# CHECK-ASM-AND-OBJ: fsgnjx.d fa3, fa2, fa1
-# CHECK-ASM: encoding: [0xd3,0x26,0xb6,0x22]
-fsgnjx.d fa3, fa2, fa1
-# CHECK-ASM-AND-OBJ: fmin.d fa5, fa6, fa7
-# CHECK-ASM: encoding: [0xd3,0x07,0x18,0x2b]
-fmin.d fa5, fa6, fa7
-# CHECK-ASM-AND-OBJ: fmax.d fs2, fs3, fs4
-# CHECK-ASM: encoding: [0x53,0x99,0x49,0x2b]
-fmax.d fs2, fs3, fs4
-
-# CHECK-ASM-AND-OBJ: fcvt.s.d fs5, fs6, dyn
-# CHECK-ASM: encoding: [0xd3,0x7a,0x1b,0x40]
-fcvt.s.d fs5, fs6, dyn
-# CHECK-ASM-AND-OBJ: fcvt.d.s fs7, fs8
-# CHECK-ASM: encoding: [0xd3,0x0b,0x0c,0x42]
-fcvt.d.s fs7, fs8
-# CHECK-ASM-AND-OBJ: feq.d a1, fs8, fs9
-# CHECK-ASM: encoding: [0xd3,0x25,0x9c,0xa3]
-feq.d a1, fs8, fs9
-# CHECK-ASM-AND-OBJ: flt.d a2, fs10, fs11
-# CHECK-ASM: encoding: [0x53,0x16,0xbd,0xa3]
-flt.d a2, fs10, fs11
-# CHECK-ASM-AND-OBJ: fle.d a3, ft8, ft9
-# CHECK-ASM: encoding: [0xd3,0x06,0xde,0xa3]
-fle.d a3, ft8, ft9
-# CHECK-ASM-AND-OBJ: fclass.d a3, ft10
-# CHECK-ASM: encoding: [0xd3,0x16,0x0f,0xe2]
-fclass.d a3, ft10
-
-# CHECK-ASM-AND-OBJ: fcvt.w.d a4, ft11, dyn
-# CHECK-ASM: encoding: [0x53,0xf7,0x0f,0xc2]
-fcvt.w.d a4, ft11, dyn
-# CHECK-ASM-AND-OBJ: fcvt.d.w ft0, a5
-# CHECK-ASM: encoding: [0x53,0x80,0x07,0xd2]
-fcvt.d.w ft0, a5
-# CHECK-ASM-AND-OBJ: fcvt.d.wu ft1, a6
-# CHECK-ASM: encoding: [0xd3,0x00,0x18,0xd2]
-fcvt.d.wu ft1, a6
-
-# Rounding modes
-
-# CHECK-ASM-AND-OBJ: fmadd.d fa0, fa1, fa2, fa3, rne
-# CHECK-ASM: encoding: [0x43,0x85,0xc5,0x6a]
-fmadd.d f10, f11, f12, f13, rne
-# CHECK-ASM-AND-OBJ: fmsub.d fa4, fa5, fa6, fa7, rtz
-# CHECK-ASM: encoding: [0x47,0x97,0x07,0x8b]
-fmsub.d f14, f15, f16, f17, rtz
-# CHECK-ASM-AND-OBJ: fnmsub.d fs2, fs3, fs4, fs5, rdn
-# CHECK-ASM: encoding: [0x4b,0xa9,0x49,0xab]
-fnmsub.d f18, f19, f20, f21, rdn
-# CHECK-ASM-AND-OBJ: fnmadd.d fs6, fs7, fs8, fs9, rup
-# CHECK-ASM: encoding: [0x4f,0xbb,0x8b,0xcb]
-fnmadd.d f22, f23, f24, f25, rup
-
-# CHECK-ASM-AND-OBJ: fadd.d fs10, fs11, ft8, rmm
-# CHECK-ASM: encoding: [0x53,0xcd,0xcd,0x03]
-fadd.d f26, f27, f28, rmm
-# CHECK-ASM-AND-OBJ: fsub.d ft9, ft10, ft11
-# CHECK-ASM: encoding: [0xd3,0x7e,0xff,0x0b]
-fsub.d f29, f30, f31, dyn
-# CHECK-ASM-AND-OBJ: fmul.d ft0, ft1, ft2, rne
-# CHECK-ASM: encoding: [0x53,0x80,0x20,0x12]
-fmul.d ft0, ft1, ft2, rne
-# CHECK-ASM-AND-OBJ: fdiv.d ft3, ft4, ft5, rtz
-# CHECK-ASM: encoding: [0xd3,0x11,0x52,0x1a]
-fdiv.d ft3, ft4, ft5, rtz
-
-# CHECK-ASM-AND-OBJ: fsqrt.d ft6, ft7, rdn
-# CHECK-ASM: encoding: [0x53,0xa3,0x03,0x5a]
-fsqrt.d ft6, ft7, rdn
-# CHECK-ASM-AND-OBJ: fcvt.s.d fs5, fs6, rup
-# CHECK-ASM: encoding: [0xd3,0x3a,0x1b,0x40]
-fcvt.s.d fs5, fs6, rup
-# CHECK-ASM-AND-OBJ: fcvt.w.d a4, ft11, rmm
-# CHECK-ASM: encoding: [0x53,0xc7,0x0f,0xc2]
-fcvt.w.d a4, ft11, rmm
-# CHECK-ASM-AND-OBJ: fcvt.wu.d a5, ft10, dyn
-# CHECK-ASM: encoding: [0xd3,0x77,0x1f,0xc2]
-fcvt.wu.d a5, ft10, dyn
diff --git a/test/MC/RISCV/rv32dc-invalid.s b/test/MC/RISCV/rv32dc-invalid.s
deleted file mode 100644
index 70fb504b1bb..00000000000
--- a/test/MC/RISCV/rv32dc-invalid.s
+++ /dev/null
@@ -1,12 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c,+d < %s 2>&1 | FileCheck %s
-
-## FPRC
-c.fld  ft3, 8(a5) # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## uimm9_lsb000
-c.fldsp  fs1, 512(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-c.fsdsp  fs2, -8(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-
-## uimm8_lsb000
-c.fld  fs0, -8(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 248]
-c.fsd  fs1, 256(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 248]
diff --git a/test/MC/RISCV/rv32dc-valid.s b/test/MC/RISCV/rv32dc-valid.s
deleted file mode 100644
index 1a9ea317a35..00000000000
--- a/test/MC/RISCV/rv32dc-valid.s
+++ /dev/null
@@ -1,29 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c,+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c,+d < %s \
-# RUN:     | llvm-objdump -mattr=+c,+d -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv32 -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# CHECK-ASM-AND-OBJ: c.fldsp  fs0, 504(sp)
-# CHECK-ASM: encoding: [0x7e,0x34]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fldsp  fs0, 504(sp)
-# CHECK-ASM-AND-OBJ: c.fsdsp  fa7, 504(sp)
-# CHECK-ASM: encoding: [0xc6,0xbf]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsdsp  fa7, 504(sp)
-
-# CHECK-ASM-AND-OBJ: c.fld  fa3, 248(a5)
-# CHECK-ASM: encoding: [0xf4,0x3f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fld  fa3, 248(a5)
-# CHECK-ASM-AND-OBJ: c.fsd  fa2, 248(a1)
-# CHECK-ASM: encoding: [0xf0,0xbd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsd  fa2, 248(a1)
diff --git a/test/MC/RISCV/rv32f-invalid.s b/test/MC/RISCV/rv32f-invalid.s
deleted file mode 100644
index 5b49244416b..00000000000
--- a/test/MC/RISCV/rv32f-invalid.s
+++ /dev/null
@@ -1,34 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+f < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## simm12
-flw ft1, -2049(a0) # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-fsw ft2, 2048(a1) # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Memory operand not formatted correctly
-flw ft1, a0, -200 # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-fsw ft2, a1, 100 # CHECK: :[[@LINE]]:10: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Invalid register names
-flw ft15, 100(a0) # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-flw ft1, 100(a10) # CHECK: :[[@LINE]]:14: error: expected register
-fsgnjn.s fa100, fa2, fa3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Integer registers where FP regs are expected
-fmv.x.w fs7, a2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fmv.w.x a8, ft2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# Rounding mode when a register is expected
-fmadd.s f10, f11, f12, ree # CHECK: :[[@LINE]]:24: error: invalid operand for instruction
-
-# Invalid rounding modes
-fmadd.s f10, f11, f12, f13, ree # CHECK: :[[@LINE]]:29: error: operand must be a valid floating point rounding mode mnemonic
-fmsub.s f14, f15, f16, f17, 0 # CHECK: :[[@LINE]]:29: error: operand must be a valid floating point rounding mode mnemonic
-fnmsub.s f18, f19, f20, f21, 0b111 # CHECK: :[[@LINE]]:30: error: operand must be a valid floating point rounding mode mnemonic
-
-# Using 'D' instructions for an 'F'-only target
-fadd.d ft0, ft1, ft2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Using RV64F instructions for RV32 is tested in rv64f-valid.s
diff --git a/test/MC/RISCV/rv32f-valid.s b/test/MC/RISCV/rv32f-valid.s
deleted file mode 100644
index 9cf9164f0ab..00000000000
--- a/test/MC/RISCV/rv32f-valid.s
+++ /dev/null
@@ -1,166 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: flw ft0, 12(a0)
-# CHECK-ASM: encoding: [0x07,0x20,0xc5,0x00]
-flw f0, 12(a0)
-# CHECK-ASM-AND-OBJ: flw ft1, 4(ra)
-# CHECK-ASM: encoding: [0x87,0xa0,0x40,0x00]
-flw f1, +4(ra)
-# CHECK-ASM-AND-OBJ: flw ft2, -2048(a3)
-# CHECK-ASM: encoding: [0x07,0xa1,0x06,0x80]
-flw f2, -2048(x13)
-# CHECK-ASM-AND-OBJ: flw ft3, -2048(s1)
-# CHECK-ASM: encoding: [0x87,0xa1,0x04,0x80]
-flw f3, %lo(2048)(s1)
-# CHECK-ASM-AND-OBJ: flw ft4, 2047(s2)
-# CHECK-ASM: encoding: [0x07,0x22,0xf9,0x7f]
-flw f4, 2047(s2)
-# CHECK-ASM-AND-OBJ: flw ft5, 0(s3)
-# CHECK-ASM: encoding: [0x87,0xa2,0x09,0x00]
-flw f5, 0(s3)
-
-# CHECK-ASM-AND-OBJ: fsw ft6, 2047(s4)
-# CHECK-ASM: encoding: [0xa7,0x2f,0x6a,0x7e]
-fsw f6, 2047(s4)
-# CHECK-ASM-AND-OBJ: fsw ft7, -2048(s5)
-# CHECK-ASM: encoding: [0x27,0xa0,0x7a,0x80]
-fsw f7, -2048(s5)
-# CHECK-ASM-AND-OBJ: fsw fs0, -2048(s6)
-# CHECK-ASM: encoding: [0x27,0x20,0x8b,0x80]
-fsw f8, %lo(2048)(s6)
-# CHECK-ASM-AND-OBJ: fsw fs1, 999(s7)
-# CHECK-ASM: encoding: [0xa7,0xa3,0x9b,0x3e]
-fsw f9, 999(s7)
-
-# CHECK-ASM-AND-OBJ: fmadd.s fa0, fa1, fa2, fa3, dyn
-# CHECK-ASM: encoding: [0x43,0xf5,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, dyn
-# CHECK-ASM-AND-OBJ: fmsub.s fa4, fa5, fa6, fa7, dyn
-# CHECK-ASM: encoding: [0x47,0xf7,0x07,0x89]
-fmsub.s f14, f15, f16, f17, dyn
-# CHECK-ASM-AND-OBJ: fnmsub.s fs2, fs3, fs4, fs5, dyn
-# CHECK-ASM: encoding: [0x4b,0xf9,0x49,0xa9]
-fnmsub.s f18, f19, f20, f21, dyn
-# CHECK-ASM-AND-OBJ: fnmadd.s fs6, fs7, fs8, fs9, dyn
-# CHECK-ASM: encoding: [0x4f,0xfb,0x8b,0xc9]
-fnmadd.s f22, f23, f24, f25, dyn
-
-# CHECK-ASM-AND-OBJ: fadd.s fs10, fs11, ft8, dyn
-# CHECK-ASM: encoding: [0x53,0xfd,0xcd,0x01]
-fadd.s f26, f27, f28, dyn
-# CHECK-ASM-AND-OBJ: fsub.s ft9, ft10, ft11, dyn
-# CHECK-ASM: encoding: [0xd3,0x7e,0xff,0x09]
-fsub.s f29, f30, f31, dyn
-# CHECK-ASM-AND-OBJ: fmul.s ft0, ft1, ft2, dyn
-# CHECK-ASM: encoding: [0x53,0xf0,0x20,0x10]
-fmul.s ft0, ft1, ft2, dyn
-# CHECK-ASM-AND-OBJ: fdiv.s ft3, ft4, ft5, dyn
-# CHECK-ASM: encoding: [0xd3,0x71,0x52,0x18]
-fdiv.s ft3, ft4, ft5, dyn
-# CHECK-ASM-AND-OBJ: fsqrt.s ft6, ft7, dyn
-# CHECK-ASM: encoding: [0x53,0xf3,0x03,0x58]
-fsqrt.s ft6, ft7, dyn
-# CHECK-ASM-AND-OBJ: fsgnj.s fs1, fa0, fa1
-# CHECK-ASM: encoding: [0xd3,0x04,0xb5,0x20]
-fsgnj.s fs1, fa0, fa1
-# CHECK-ASM-AND-OBJ: fsgnjn.s fa1, fa3, fa4
-# CHECK-ASM: encoding: [0xd3,0x95,0xe6,0x20]
-fsgnjn.s fa1, fa3, fa4
-# CHECK-ASM-AND-OBJ: fsgnjx.s fa4, fa3, fa2
-# CHECK-ASM: encoding: [0x53,0xa7,0xc6,0x20]
-fsgnjx.s fa4, fa3, fa2
-# CHECK-ASM-AND-OBJ: fmin.s fa5, fa6, fa7
-# CHECK-ASM: encoding: [0xd3,0x07,0x18,0x29]
-fmin.s fa5, fa6, fa7
-# CHECK-ASM-AND-OBJ: fmax.s fs2, fs3, fs4
-# CHECK-ASM: encoding: [0x53,0x99,0x49,0x29]
-fmax.s fs2, fs3, fs4
-# CHECK-ASM-AND-OBJ: fcvt.w.s a0, fs5, dyn
-# CHECK-ASM: encoding: [0x53,0xf5,0x0a,0xc0]
-fcvt.w.s a0, fs5, dyn
-# CHECK-ASM-AND-OBJ: fcvt.wu.s a1, fs6, dyn
-# CHECK-ASM: encoding: [0xd3,0x75,0x1b,0xc0]
-fcvt.wu.s a1, fs6, dyn
-# CHECK-ASM-AND-OBJ: fmv.x.w a2, fs7
-# CHECK-ASM: encoding: [0x53,0x86,0x0b,0xe0]
-fmv.x.w a2, fs7
-# CHECK-ASM-AND-OBJ: feq.s a1, fs8, fs9
-# CHECK-ASM: encoding: [0xd3,0x25,0x9c,0xa1]
-feq.s a1, fs8, fs9
-# CHECK-ASM-AND-OBJ: flt.s a2, fs10, fs11
-# CHECK-ASM: encoding: [0x53,0x16,0xbd,0xa1]
-flt.s a2, fs10, fs11
-# CHECK-ASM-AND-OBJ: fle.s a3, ft8, ft9
-# CHECK-ASM: encoding: [0xd3,0x06,0xde,0xa1]
-fle.s a3, ft8, ft9
-# CHECK-ASM-AND-OBJ: fclass.s a3, ft10
-# CHECK-ASM: encoding: [0xd3,0x16,0x0f,0xe0]
-fclass.s a3, ft10
-# CHECK-ASM-AND-OBJ: fcvt.s.w ft11, a4, dyn
-# CHECK-ASM: encoding: [0xd3,0x7f,0x07,0xd0]
-fcvt.s.w ft11, a4, dyn
-# CHECK-ASM-AND-OBJ: fcvt.s.wu ft0, a5, dyn
-# CHECK-ASM: encoding: [0x53,0xf0,0x17,0xd0]
-fcvt.s.wu ft0, a5, dyn
-# CHECK-ASM-AND-OBJ: fmv.w.x ft1, a6
-# CHECK-ASM: encoding: [0xd3,0x00,0x08,0xf0]
-fmv.w.x ft1, a6
-
-# Rounding modes
-
-# CHECK-ASM-AND-OBJ: fmadd.s fa0, fa1, fa2, fa3, rne
-# CHECK-ASM: encoding: [0x43,0x85,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, rne
-# CHECK-ASM-AND-OBJ: fmsub.s fa4, fa5, fa6, fa7, rtz
-# CHECK-ASM: encoding: [0x47,0x97,0x07,0x89]
-fmsub.s f14, f15, f16, f17, rtz
-# CHECK-ASM-AND-OBJ: fnmsub.s fs2, fs3, fs4, fs5, rdn
-# CHECK-ASM: encoding: [0x4b,0xa9,0x49,0xa9]
-fnmsub.s f18, f19, f20, f21, rdn
-# CHECK-ASM-AND-OBJ: fnmadd.s fs6, fs7, fs8, fs9, rup
-# CHECK-ASM: encoding: [0x4f,0xbb,0x8b,0xc9]
-fnmadd.s f22, f23, f24, f25, rup
-# CHECK-ASM-AND-OBJ: fmadd.s fa0, fa1, fa2, fa3, rmm
-# CHECK-ASM: encoding: [0x43,0xc5,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, rmm
-# CHECK-ASM-AND-OBJ: fmsub.s fa4, fa5, fa6, fa7
-# CHECK-ASM: encoding: [0x47,0xf7,0x07,0x89]
-fmsub.s f14, f15, f16, f17, dyn
-
-# CHECK-ASM-AND-OBJ: fadd.s fs10, fs11, ft8, rne
-# CHECK-ASM: encoding: [0x53,0x8d,0xcd,0x01]
-fadd.s f26, f27, f28, rne
-# CHECK-ASM-AND-OBJ: fsub.s ft9, ft10, ft11, rtz
-# CHECK-ASM: encoding: [0xd3,0x1e,0xff,0x09]
-fsub.s f29, f30, f31, rtz
-# CHECK-ASM-AND-OBJ: fmul.s ft0, ft1, ft2, rdn
-# CHECK-ASM: encoding: [0x53,0xa0,0x20,0x10]
-fmul.s ft0, ft1, ft2, rdn
-# CHECK-ASM-AND-OBJ: fdiv.s ft3, ft4, ft5, rup
-# CHECK-ASM: encoding: [0xd3,0x31,0x52,0x18]
-fdiv.s ft3, ft4, ft5, rup
-
-# CHECK-ASM-AND-OBJ: fsqrt.s ft6, ft7, rmm
-# CHECK-ASM: encoding: [0x53,0xc3,0x03,0x58]
-fsqrt.s ft6, ft7, rmm
-# CHECK-ASM-AND-OBJ: fcvt.w.s a0, fs5, rup
-# CHECK-ASM: encoding: [0x53,0xb5,0x0a,0xc0]
-fcvt.w.s a0, fs5, rup
-# CHECK-ASM-AND-OBJ: fcvt.wu.s a1, fs6, rdn
-# CHECK-ASM: encoding: [0xd3,0x25,0x1b,0xc0]
-fcvt.wu.s a1, fs6, rdn
-# CHECK-ASM-AND-OBJ: fcvt.s.w ft11, a4, rtz
-# CHECK-ASM: encoding: [0xd3,0x1f,0x07,0xd0]
-fcvt.s.w ft11, a4, rtz
-# CHECK-ASM-AND-OBJ: fcvt.s.wu ft0, a5, rne
-# CHECK-ASM: encoding: [0x53,0x80,0x17,0xd0]
-fcvt.s.wu ft0, a5, rne
diff --git a/test/MC/RISCV/rv32fc-invalid.s b/test/MC/RISCV/rv32fc-invalid.s
deleted file mode 100644
index 5af3df17671..00000000000
--- a/test/MC/RISCV/rv32fc-invalid.s
+++ /dev/null
@@ -1,12 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c,+f < %s 2>&1 | FileCheck %s
-
-## FPRC
-c.flw  ft3, 8(a5) # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## uimm8_lsb00
-c.flwsp  fs1, 256(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-c.fswsp  fs2, -4(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-
-## uimm7_lsb00
-c.flw  fs0, -4(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-c.fsw  fs1, 128(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 124]
diff --git a/test/MC/RISCV/rv32fc-valid.s b/test/MC/RISCV/rv32fc-valid.s
deleted file mode 100644
index 3e29a5c9485..00000000000
--- a/test/MC/RISCV/rv32fc-valid.s
+++ /dev/null
@@ -1,35 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c,+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c,+f < %s \
-# RUN:     | llvm-objdump -mattr=+c,+f -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv32 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv64 -mattr=+c,+f \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# FIXME: error messages for rv64fc are misleading
-
-# CHECK-ASM-AND-OBJ: c.flwsp  fs0, 252(sp)
-# CHECK-ASM: encoding: [0x7e,0x74]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.flwsp  fs0, 252(sp)
-# CHECK-ASM-AND-OBJ: c.fswsp  fa7, 252(sp)
-# CHECK-ASM: encoding: [0xc6,0xff]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fswsp  fa7, 252(sp)
-
-# CHECK-ASM-AND-OBJ: c.flw  fa3, 124(a5)
-# CHECK-ASM: encoding: [0xf4,0x7f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.flw  fa3, 124(a5)
-# CHECK-ASM-AND-OBJ: c.fsw  fa2, 124(a1)
-# CHECK-ASM: encoding: [0xf0,0xfd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsw  fa2, 124(a1)
diff --git a/test/MC/RISCV/rv32i-aliases-invalid.s b/test/MC/RISCV/rv32i-aliases-invalid.s
deleted file mode 100644
index b50a8e4033e..00000000000
--- a/test/MC/RISCV/rv32i-aliases-invalid.s
+++ /dev/null
@@ -1,23 +0,0 @@
-# RUN: not llvm-mc %s -triple=riscv32 -riscv-no-aliases 2>&1 | FileCheck %s
-# RUN: not llvm-mc %s -triple=riscv32 2>&1 | FileCheck %s
-
-# TODO ld
-# TODO sd
-
-li x0, 4294967296   # CHECK: :[[@LINE]]:8: error: immediate must be an integer in the range [-2147483648, 4294967295]
-li x0, -2147483649  # CHECK: :[[@LINE]]:8: error: immediate must be an integer in the range [-2147483648, 4294967295]
-li t4, foo          # CHECK: :[[@LINE]]:8: error: immediate must be an integer in the range [-2147483648, 4294967295]
-
-negw x1, x2   # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-sext.w x3, x4 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-sll x2, x3, 32  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-srl x2, x3, 32  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-sra x2, x3, 32  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-
-sll x2, x3, -1  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-srl x2, x3, -2  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-sra x2, x3, -3  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 31]
-
-foo:
-  .space 4
diff --git a/test/MC/RISCV/rv32i-aliases-valid.s b/test/MC/RISCV/rv32i-aliases-valid.s
deleted file mode 100644
index 04baa9e488b..00000000000
--- a/test/MC/RISCV/rv32i-aliases-valid.s
+++ /dev/null
@@ -1,80 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-ALIAS %s
-
-# The following check prefixes are used in this test:
-# CHECK-INST.....Match the canonical instr (tests alias to instr. mapping)
-# CHECK-ALIAS....Match the alias (tests instr. to alias mapping)
-# CHECK-EXPAND...Match canonical instr. unconditionally (tests alias expansion)
-
-
-# CHECK-INST: addi a0, zero, 0
-# CHECK-ALIAS: mv a0, zero
-li x10, 0
-# CHECK-EXPAND: addi a0, zero, 1
-li x10, 1
-# CHECK-EXPAND: addi a0, zero, -1
-li x10, -1
-# CHECK-EXPAND: addi a0, zero, 2047
-li x10, 2047
-# CHECK-EXPAND: addi a0, zero, -2047
-li x10, -2047
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addi a1, a1, -2048
-li x11, 2048
-# CHECK-EXPAND: addi a1, zero, -2048
-li x11, -2048
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addi a1, a1, -2047
-li x11, 2049
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: addi a1, a1, 2047
-li x11, -2049
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addi a1, a1, -1
-li x11, 4095
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: addi a1, a1, 1
-li x11, -4095
-# CHECK-EXPAND: lui a2, 1
-li x12, 4096
-# CHECK-EXPAND: lui a2, 1048575
-li x12, -4096
-# CHECK-EXPAND: lui a2, 1
-# CHECK-EXPAND: addi a2, a2, 1
-li x12, 4097
-# CHECK-EXPAND: lui a2, 1048575
-# CHECK-EXPAND: addi a2, a2, -1
-li x12, -4097
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: addi a2, a2, -1
-li x12, 2147483647
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: addi a2, a2, 1
-li x12, -2147483647
-# CHECK-EXPAND: lui a2, 524288
-li x12, -2147483648
-# CHECK-EXPAND: lui a2, 524288
-li x12, -0x80000000
-
-# CHECK-EXPAND: lui a2, 524288
-li x12, 0x80000000
-# CHECK-EXPAND: addi a2, zero, -1
-li x12, 0xFFFFFFFF
-
-# CHECK-INST: csrrs t4, instreth, zero
-# CHECK-ALIAS: rdinstreth t4
-rdinstreth x29
-# CHECK-INST: csrrs s11, cycleh, zero
-# CHECK-ALIAS: rdcycleh s11
-rdcycleh x27
-# CHECK-INST: csrrs t3, timeh, zero
-# CHECK-ALIAS: rdtimeh t3
-rdtimeh x28
diff --git a/test/MC/RISCV/rv32i-invalid.s b/test/MC/RISCV/rv32i-invalid.s
deleted file mode 100644
index f856bf1f934..00000000000
--- a/test/MC/RISCV/rv32i-invalid.s
+++ /dev/null
@@ -1,176 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## fencearg
-fence iorw, iore # CHECK: :[[@LINE]]:13: error: operand must be formed of letters selected in-order from 'iorw'
-fence wr, wr # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence rw, rr # CHECK: :[[@LINE]]:11: error: operand must be formed of letters selected in-order from 'iorw'
-fence 1, rw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence unknown, unknown # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-
-## uimm5
-slli a0, a0, 32 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srli a0, a0, -1 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srai a0, a0, -19 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-csrrwi a1, 0x1, -1 # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, 32 # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, -90 # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-ori a0, a1, -2049 # CHECK: :[[@LINE]]:13: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-andi ra, sp, 2048 # CHECK: :[[@LINE]]:14: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-## uimm12
-csrrw a0, -1, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, 4096, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, -0xf, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrc a0, 0x1000, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, -50, 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, 4097, a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrci a0, 0xffff, a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-
-## simm13_lsb0
-beq t0, t1, -4098 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bne t0, t1, -4097 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-blt t0, t1, 4095 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bge t0, t1, 4096 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, 13 # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, -13 # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-
-## uimm20
-lui a0, -1 # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-lui s0, 1048576 # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-auipc zero, -0xf # CHECK: :[[@LINE]]:13: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-
-## simm21_lsb0
-jal gp, -1048578 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, -1048577 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1048575 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1048576 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-
-# Illegal operand modifier
-## fencearg
-fence %hi(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %lo(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %pcrel_hi(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %pcrel_lo(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-
-## uimm5
-slli a0, a0, %lo(1) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srli a0, a0, %lo(a) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srai a0, a0, %hi(2) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-csrrwi a1, 0x1, %hi(b) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, %pcrel_hi(3) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, %pcrel_hi(c) # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, %pcrel_lo(4) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, %pcrel_lo(d) # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-ori a0, a1, %hi(foo) # CHECK: :[[@LINE]]:13: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-andi ra, sp, %pcrel_hi(123) # CHECK: :[[@LINE]]:14: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-xori a2, a3, %hi(345) # CHECK: :[[@LINE]]:14: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-add a1, a2, (a3) # CHECK: :[[@LINE]]:13: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-add a1, a2, foo # CHECK: :[[@LINE]]:13: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-## uimm12
-csrrw a0, %lo(1), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, %lo(a), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, %hi(2), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrc a0, %hi(b), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, %pcrel_hi(3), 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, %pcrel_hi(c), a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, %pcrel_lo(4), 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, %pcrel_lo(d), a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-
-## named csr in place of uimm12
-csrrw a0, foos, a0 # CHECK: :[[@LINE]]:11: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrs a0, mstatusx, a0 # CHECK: :[[@LINE]]:11: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrs a0, xmstatus, a0 # CHECK: :[[@LINE]]:11: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrc a0, m12status, a0 # CHECK: :[[@LINE]]:11: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrwi a0, mstatus12, 0 # CHECK: :[[@LINE]]:12: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrsi a0, mhpm12counter, a0 # CHECK: :[[@LINE]]:12: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrwi a0, mhpmcounter32, 0 # CHECK: :[[@LINE]]:12: error: operand must be a valid system register name or an integer in the range [0, 4095]
-csrrsi a0, A, a0 # CHECK: :[[@LINE]]:12: error: operand must be a valid system register name or an integer in the range [0, 4095]
-
-## simm13_lsb0
-beq t0, t1, %lo(1) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bne t0, t1, %lo(a) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-blt t0, t1, %hi(2) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bge t0, t1, %hi(b) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, %pcrel_hi(3) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, %pcrel_hi(c) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, %pcrel_lo(4) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, %pcrel_lo(d) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-
-## uimm20
-lui a0, %lo(1) # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-auipc a1, %lo(foo) # CHECK: :[[@LINE]]:11: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-
-## simm21_lsb0
-jal gp, %lo(1) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %lo(a) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %hi(2) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %hi(b) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_hi(3) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_hi(c) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_lo(4) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_lo(d) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-
-# Bare symbol names when an operand modifier is required and unsupported 
-# operand modifiers.
-
-lui a0, foo # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-lui a0, %lo(foo) # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-lui a0, %pcrel_lo(foo) # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-lui a0, %pcrel_hi(foo) # CHECK: :[[@LINE]]:9: error: operand must be a symbol with %hi() modifier or an integer in the range [0, 1048575]
-
-auipc a0, foo # CHECK: :[[@LINE]]:11: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-auipc a0, %lo(foo) # CHECK: :[[@LINE]]:11: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-auipc a0, %hi(foo) # CHECK: :[[@LINE]]:11: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-auipc a0, %pcrel_lo(foo) # CHECK: :[[@LINE]]:11: error: operand must be a symbol with %pcrel_hi() modifier or an integer in the range [0, 1048575]
-
-# Unrecognized operand modifier
-addi t0, sp, %modifer(255) # CHECK: :[[@LINE]]:15: error: unrecognized operand modifier
-
-# Use of operand modifier on register name
-addi t1, %lo(t2), 1 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Invalid mnemonics
-subs t0, t2, t1 # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-nandi t0, zero, 0 # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# Invalid register names
-addi foo, sp, 10 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-slti a10, a2, 0x20 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-slt x32, s0, s0 # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-
-# RV64I mnemonics
-addiw a0, sp, 100 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-sraw t0, s2, zero # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Invalid operand types
-xori sp, 22, 220 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-sub t0, t2, 1 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-
-# Too many operands
-add ra, zero, zero, zero # CHECK: :[[@LINE]]:21: error: invalid operand for instruction
-sltiu s2, s3, 0x50, 0x60 # CHECK: :[[@LINE]]:21: error: invalid operand for instruction
-
-# Memory operand not formatted correctly
-lw a4, a5, 111 # CHECK: :[[@LINE]]:8: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Too few operands
-ori a0, a1 # CHECK: :[[@LINE]]:1: error: too few operands for instruction
-xor s2, s2 # CHECK: :[[@LINE]]:1: error: too few operands for instruction
-
-# Instruction not in the base ISA
-mul a4, ra, s0 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-amomaxu.w s5, s4, (s3) # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-fadd.s ft0, ft1, ft2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Using floating point registers when integer registers are expected
-addi a2, ft0, 24 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# fence.tso accepts no operands
-fence.tso rw, rw # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv32i-valid.s b/test/MC/RISCV/rv32i-valid.s
deleted file mode 100644
index 0df53e661b9..00000000000
--- a/test/MC/RISCV/rv32i-valid.s
+++ /dev/null
@@ -1,275 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: lui a0, 2
-# CHECK-ASM: encoding: [0x37,0x25,0x00,0x00]
-lui a0, 2
-# CHECK-ASM-AND-OBJ: lui s11, 552960
-# CHECK-ASM: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, (0x87000000>>12)
-# CHECK-ASM-AND-OBJ: lui a0, 0
-# CHECK-ASM: encoding: [0x37,0x05,0x00,0x00]
-lui a0, %hi(2)
-# CHECK-ASM-AND-OBJ: lui s11, 552960
-# CHECK-ASM: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, (0x87000000>>12)
-# CHECK-ASM-AND-OBJ: lui s11, 552960
-# CHECK-ASM: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, %hi(0x87000000)
-# CHECK-ASM-AND-OBJ: lui t0, 1048575
-# CHECK-ASM: encoding: [0xb7,0xf2,0xff,0xff]
-lui t0, 1048575
-# CHECK-ASM-AND-OBJ: lui gp, 0
-# CHECK-ASM: encoding: [0xb7,0x01,0x00,0x00]
-lui gp, 0
-# CHECK-ASM: lui a0, %hi(foo)
-# CHECK-ASM: encoding: [0x37,0bAAAA0101,A,A]
-# CHECK-OBJ: lui a0, 0
-# CHECK-OBJ: R_RISCV_HI20 foo
-lui a0, %hi(foo)
-
-# CHECK-ASM-AND-OBJ: auipc a0, 2
-# CHECK-ASM: encoding: [0x17,0x25,0x00,0x00]
-auipc a0, 2
-# CHECK-ASM-AND-OBJ: auipc s11, 552960
-# CHECK-ASM: encoding: [0x97,0x0d,0x00,0x87]
-auipc s11, (0x87000000>>12)
-# CHECK-ASM-AND-OBJ: auipc t0, 1048575
-# CHECK-ASM: encoding: [0x97,0xf2,0xff,0xff]
-auipc t0, 1048575
-# CHECK-ASM-AND-OBJ: auipc gp, 0
-# CHECK-ASM: encoding: [0x97,0x01,0x00,0x00]
-auipc gp, 0
-# CHECK-ASM: auipc a0, %pcrel_hi(foo)
-# CHECK-ASM: encoding: [0x17,0bAAAA0101,A,A]
-# CHECK-OBJ: auipc a0, 0
-# CHECK-OBJ: R_RISCV_PCREL_HI20 foo
-auipc a0, %pcrel_hi(foo)
-
-# CHECK-ASM-AND-OBJ: jal a2, 1048574
-# CHECK-ASM: encoding: [0x6f,0xf6,0xff,0x7f]
-jal a2, 1048574
-# CHECK-ASM-AND-OBJ: jal a3, 256
-# CHECK-ASM: encoding: [0xef,0x06,0x00,0x10]
-jal a3, 256
-# CHECK-ASM: jal a0, foo
-# CHECK-ASM: encoding: [0x6f,0bAAAA0101,A,A]
-# CHECK-OBJ: jal a0, 0
-# CHECK-OBJ: R_RISCV_JAL foo
-jal a0, foo
-# CHECK-ASM: jal a0, a0
-# CHECK-ASM: encoding: [0x6f,0bAAAA0101,A,A]
-# CHECK-OBJ: jal a0, 0
-# CHECK-OBJ: R_RISCV_JAL a0
-jal a0, a0
-
-# CHECK-ASM-AND-OBJ: jalr a0, a1, -2048
-# CHECK-ASM: encoding: [0x67,0x85,0x05,0x80]
-jalr a0, a1, -2048
-# CHECK-ASM-AND-OBJ: jalr a0, a1, -2048
-# CHECK-ASM: encoding: [0x67,0x85,0x05,0x80]
-jalr a0, a1, %lo(2048)
-# CHECK-ASM-AND-OBJ: jalr t2, t1, 2047
-# CHECK-ASM: encoding: [0xe7,0x03,0xf3,0x7f]
-jalr t2, t1, 2047
-# CHECK-ASM-AND-OBJ: jalr sp, zero, 256
-# CHECK-ASM: encoding: [0x67,0x01,0x00,0x10]
-jalr sp, zero, 256
-
-# CHECK-ASM-AND-OBJ: beq s1, s1, 102
-# CHECK-ASM: encoding: [0x63,0x83,0x94,0x06]
-beq s1, s1, 102
-# CHECK-ASM-AND-OBJ: bne a4, a5, -4096
-# CHECK-ASM: encoding: [0x63,0x10,0xf7,0x80]
-bne a4, a5, -4096
-# CHECK-ASM-AND-OBJ: blt sp, gp, 4094
-# CHECK-ASM: encoding: [0xe3,0x4f,0x31,0x7e]
-blt sp, gp, 4094
-# CHECK-ASM-AND-OBJ: bge s2, ra, -224
-# CHECK-ASM: encoding: [0xe3,0x50,0x19,0xf2]
-bge s2, ra, -224
-# CHECK-ASM-AND-OBJ: bltu zero, zero, 0
-# CHECK-ASM: encoding: [0x63,0x60,0x00,0x00]
-bltu zero, zero, 0
-# CHECK-ASM-AND-OBJ: bgeu s8, sp, 512
-# CHECK-ASM: encoding: [0x63,0x70,0x2c,0x20]
-bgeu s8, sp, 512
-
-# CHECK-ASM-AND-OBJ: lb s3, 4(ra)
-# CHECK-ASM: encoding: [0x83,0x89,0x40,0x00]
-lb s3, 4(ra)
-# CHECK-ASM-AND-OBJ: lb s3, 4(ra)
-# CHECK-ASM: encoding: [0x83,0x89,0x40,0x00]
-lb s3, +4(ra)
-# CHECK-ASM-AND-OBJ: lh t1, -2048(zero)
-# CHECK-ASM: encoding: [0x03,0x13,0x00,0x80]
-lh t1, -2048(zero)
-# CHECK-ASM-AND-OBJ: lh t1, -2048(zero)
-# CHECK-ASM: encoding: [0x03,0x13,0x00,0x80]
-lh t1, %lo(2048)(zero)
-# CHECK-ASM-AND-OBJ: lh sp, 2047(a0)
-# CHECK-ASM: encoding: [0x03,0x11,0xf5,0x7f]
-lh sp, 2047(a0)
-# CHECK-ASM-AND-OBJ: lw a0, 97(a2)
-# CHECK-ASM: encoding: [0x03,0x25,0x16,0x06]
-lw a0, 97(a2)
-# CHECK-ASM: lbu s5, %lo(foo)(s6)
-# CHECK-ASM: encoding: [0x83,0x4a,0bAAAA1011,A]
-# CHECK-OBJ: lbu s5, 0(s6)
-# CHECK-OBJ: R_RISCV_LO12
-lbu s5, %lo(foo)(s6)
-# CHECK-ASM: lhu t3, %pcrel_lo(foo)(t3)
-# CHECK-ASM: encoding: [0x03,0x5e,0bAAAA1110,A]
-# CHECK-OBJ: lhu t3, 0(t3)
-# CHECK-OBJ: R_RISCV_PCREL_LO12
-lhu t3, %pcrel_lo(foo)(t3)
-
-# CHECK-ASM-AND-OBJ: sb a0, 2047(a2)
-# CHECK-ASM: encoding: [0xa3,0x0f,0xa6,0x7e]
-sb a0, 2047(a2)
-# CHECK-ASM-AND-OBJ: sh t3, -2048(t5)
-# CHECK-ASM: encoding: [0x23,0x10,0xcf,0x81]
-sh t3, -2048(t5)
-# CHECK-ASM-AND-OBJ: sh t3, -2048(t5)
-# CHECK-ASM: encoding: [0x23,0x10,0xcf,0x81]
-sh t3, %lo(2048)(t5)
-# CHECK-ASM-AND-OBJ: sw ra, 999(zero)
-# CHECK-ASM: encoding: [0xa3,0x23,0x10,0x3e]
-sw ra, 999(zero)
-
-# CHECK-ASM-AND-OBJ: addi ra, sp, 2
-# CHECK-ASM: encoding: [0x93,0x00,0x21,0x00]
-addi ra, sp, 2
-# CHECK-ASM: addi ra, sp, %lo(foo)
-# CHECK-ASM: encoding: [0x93,0x00,0bAAAA0001,A]
-# CHECK-OBJ: addi ra, sp, 0
-# CHECK-OBJ: R_RISCV_LO12
-addi ra, sp, %lo(foo)
-# CHECK-ASM-AND-OBJ: slti a0, a2, -20
-# CHECK-ASM: encoding: [0x13,0x25,0xc6,0xfe]
-slti a0, a2, -20
-# CHECK-ASM-AND-OBJ: sltiu s2, s3, 80
-# CHECK-ASM: encoding: [0x13,0xb9,0x09,0x05]
-sltiu s2, s3, 0x50
-# CHECK-ASM-AND-OBJ: xori tp, t1, -99
-# CHECK-ASM: encoding: [0x13,0x42,0xd3,0xf9]
-xori tp, t1, -99
-# CHECK-ASM-AND-OBJ: ori a0, a1, -2048
-# CHECK-ASM: encoding: [0x13,0xe5,0x05,0x80]
-ori a0, a1, -2048
-# CHECK-ASM-AND-OBJ: ori a0, a1, -2048
-# CHECK-ASM: encoding: [0x13,0xe5,0x05,0x80]
-ori a0, a1, %lo(2048)
-# CHECK-ASM-AND-OBJ: andi ra, sp, 2047
-# CHECK-ASM: encoding: [0x93,0x70,0xf1,0x7f]
-andi ra, sp, 2047
-# CHECK-ASM-AND-OBJ: andi ra, sp, 2047
-# CHECK-ASM: encoding: [0x93,0x70,0xf1,0x7f]
-andi x1, x2, 2047
-
-# CHECK-ASM-AND-OBJ: slli t3, t3, 31
-# CHECK-ASM: encoding: [0x13,0x1e,0xfe,0x01]
-slli t3, t3, 31
-# CHECK-ASM-AND-OBJ: srli a0, a4, 0
-# CHECK-ASM: encoding: [0x13,0x55,0x07,0x00]
-srli a0, a4, 0
-# CHECK-ASM-AND-OBJ: srai a2, sp, 15
-# CHECK-ASM: encoding: [0x13,0x56,0xf1,0x40]
-srai a2, sp, 15
-
-# CHECK-ASM-AND-OBJ: add ra, zero, zero
-# CHECK-ASM: encoding: [0xb3,0x00,0x00,0x00]
-add ra, zero, zero
-# CHECK-ASM-AND-OBJ: add ra, zero, zero
-# CHECK-ASM: encoding: [0xb3,0x00,0x00,0x00]
-add x1, x0, x0
-# CHECK-ASM-AND-OBJ: sub t0, t2, t1
-# CHECK-ASM: encoding: [0xb3,0x82,0x63,0x40]
-sub t0, t2, t1
-# CHECK-ASM-AND-OBJ: sll a5, a4, a3
-# CHECK-ASM: encoding: [0xb3,0x17,0xd7,0x00]
-sll a5, a4, a3
-# CHECK-ASM-AND-OBJ: slt s0, s0, s0
-# CHECK-ASM: encoding: [0x33,0x24,0x84,0x00]
-slt s0, s0, s0
-# CHECK-ASM-AND-OBJ: sltu gp, a0, a1
-# CHECK-ASM: encoding: [0xb3,0x31,0xb5,0x00]
-sltu gp, a0, a1
-# CHECK-ASM-AND-OBJ: xor s2, s2, s8
-# CHECK-ASM: encoding: [0x33,0x49,0x89,0x01]
-xor s2, s2, s8
-# CHECK-ASM-AND-OBJ: xor s2, s2, s8
-# CHECK-ASM: encoding: [0x33,0x49,0x89,0x01]
-xor x18, x18, x24
-# CHECK-ASM-AND-OBJ: srl a0, s0, t0
-# CHECK-ASM: encoding: [0x33,0x55,0x54,0x00]
-srl a0, s0, t0
-# CHECK-ASM-AND-OBJ: sra t0, s2, zero
-# CHECK-ASM: encoding: [0xb3,0x52,0x09,0x40]
-sra t0, s2, zero
-# CHECK-ASM-AND-OBJ: or s10, t1, ra
-# CHECK-ASM: encoding: [0x33,0x6d,0x13,0x00]
-or s10, t1, ra
-# CHECK-ASM-AND-OBJ: and a0, s2, s3
-# CHECK-ASM: encoding: [0x33,0x75,0x39,0x01]
-and a0, s2, s3
-
-# CHECK-ASM-AND-OBJ: fence iorw, iorw
-# CHECK-ASM: encoding: [0x0f,0x00,0xf0,0x0f]
-fence iorw, iorw
-# CHECK-ASM-AND-OBJ: fence io, rw
-# CHECK-ASM: encoding: [0x0f,0x00,0x30,0x0c]
-fence io, rw
-# CHECK-ASM-AND-OBJ: fence r, w
-# CHECK-ASM: encoding: [0x0f,0x00,0x10,0x02]
-fence r,w
-# CHECK-ASM-AND-OBJ: fence w, ir
-# CHECK-ASM: encoding: [0x0f,0x00,0xa0,0x01]
-fence w,ir
-# CHECK-ASM-AND-OBJ: fence.tso
-# CHECK-ASM: encoding: [0x0f,0x00,0x30,0x83]
-fence.tso
-
-# CHECK-ASM-AND-OBJ: fence.i
-# CHECK-ASM: encoding: [0x0f,0x10,0x00,0x00]
-fence.i
-
-# CHECK-ASM-AND-OBJ: ecall
-# CHECK-ASM: encoding: [0x73,0x00,0x00,0x00]
-ecall
-# CHECK-ASM-AND-OBJ: ebreak
-# CHECK-ASM: encoding: [0x73,0x00,0x10,0x00]
-ebreak
-# CHECK-ASM-AND-OBJ: unimp
-# CHECK-ASM: encoding: [0x73,0x10,0x00,0xc0]
-unimp
-
-# CHECK-ASM-AND-OBJ: csrrw t0, 4095, t1
-# CHECK-ASM: encoding: [0xf3,0x12,0xf3,0xff]
-csrrw t0, 0xfff, t1
-# CHECK-ASM-AND-OBJ: csrrs s0, cycle, zero
-# CHECK-ASM: encoding: [0x73,0x24,0x00,0xc0]
-csrrs s0, 0xc00, x0
-# CHECK-ASM-AND-OBJ: csrrs s3, 1, s5
-# CHECK-ASM: encoding: [0xf3,0xa9,0x1a,0x00]
-csrrs s3, 0x001, s5
-# CHECK-ASM-AND-OBJ: csrrc sp, ustatus, ra
-# CHECK-ASM: encoding: [0x73,0xb1,0x00,0x00]
-csrrc sp, 0x000, ra
-# CHECK-ASM-AND-OBJ: csrrwi a5, ustatus, 0
-# CHECK-ASM: encoding: [0xf3,0x57,0x00,0x00]
-csrrwi a5, 0x000, 0
-# CHECK-ASM-AND-OBJ: csrrsi t2, 4095, 31
-# CHECK-ASM: encoding: [0xf3,0xe3,0xff,0xff]
-csrrsi t2, 0xfff, 31
-# CHECK-ASM-AND-OBJ: csrrci t1, sscratch, 5
-# CHECK-ASM: encoding: [0x73,0xf3,0x02,0x14]
-csrrci t1, 0x140, 5
diff --git a/test/MC/RISCV/rv32m-invalid.s b/test/MC/RISCV/rv32m-invalid.s
deleted file mode 100644
index 5e268e8b916..00000000000
--- a/test/MC/RISCV/rv32m-invalid.s
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+m < %s 2>&1 | FileCheck %s
-
-# RV64M instructions can't be used for RV32
-mulw ra, sp, gp # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-divw tp, t0, t1 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-divuw t2, s0, s2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-remw a0, a1, a2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-remuw a3, a4, a5 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
diff --git a/test/MC/RISCV/rv32m-valid.s b/test/MC/RISCV/rv32m-valid.s
deleted file mode 100644
index 2b410f2c80c..00000000000
--- a/test/MC/RISCV/rv32m-valid.s
+++ /dev/null
@@ -1,35 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: mul a4, ra, s0
-# CHECK-ASM: encoding: [0x33,0x87,0x80,0x02]
-mul a4, ra, s0
-# CHECK-ASM-AND-OBJ: mulh ra, zero, zero
-# CHECK-ASM: encoding: [0xb3,0x10,0x00,0x02]
-mulh x1, x0, x0
-# CHECK-ASM-AND-OBJ: mulhsu t0, t2, t1
-# CHECK-ASM: encoding: [0xb3,0xa2,0x63,0x02]
-mulhsu t0, t2, t1
-# CHECK-ASM-AND-OBJ: mulhu a5, a4, a3
-# CHECK-ASM: encoding: [0xb3,0x37,0xd7,0x02]
-mulhu a5, a4, a3
-# CHECK-ASM-AND-OBJ: div s0, s0, s0
-# CHECK-ASM: encoding: [0x33,0x44,0x84,0x02]
-div s0, s0, s0
-# CHECK-ASM-AND-OBJ: divu gp, a0, a1
-# CHECK-ASM: encoding: [0xb3,0x51,0xb5,0x02]
-divu gp, a0, a1
-# CHECK-ASM-AND-OBJ: rem s2, s2, s8
-# CHECK-ASM: encoding: [0x33,0x69,0x89,0x03]
-rem s2, s2, s8
-# CHECK-ASM-AND-OBJ: remu s2, s2, s8
-# CHECK-ASM: encoding: [0x33,0x79,0x89,0x03]
-remu x18, x18, x24
diff --git a/test/MC/RISCV/rv64-machine-csr-names.s b/test/MC/RISCV/rv64-machine-csr-names.s
deleted file mode 100644
index bf0d1b68898..00000000000
--- a/test/MC/RISCV/rv64-machine-csr-names.s
+++ /dev/null
@@ -1,246 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-# These machine mode CSR register names are RV32 only, but RV64
-# can encode and disassemble these registers if given their value.
-
-######################################
-# Machine Protection and Translation
-######################################
-
-# pmpcfg1
-# uimm12
-# CHECK-INST: csrrs t2, 929, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x3a]
-# CHECK-INST-ALIAS: csrr t2, 929
-csrrs t2, 0x3A1, zero
-
-# pmpcfg3
-# uimm12
-# CHECK-INST: csrrs t2, 931, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x3a]
-# CHECK-INST-ALIAS: csrr t2, 931
-csrrs t2, 0x3A3, zero
-
-######################################
-# Machine Counter and Timers
-######################################
-# mcycleh
-# uimm12
-# CHECK-INST: csrrs t2, 2944, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2944
-csrrs t2, 0xB80, zero
-
-# minstreth
-# uimm12
-# CHECK-INST: csrrs t2, 2946, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2946
-csrrs t2, 0xB82, zero
-
-# mhpmcounter3h
-# uimm12
-# CHECK-INST: csrrs t2, 2947, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2947
-csrrs t2, 0xB83, zero
-
-# mhpmcounter4h
-# uimm12
-# CHECK-INST: csrrs t2, 2948, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2948
-csrrs t2, 0xB84, zero
-
-# mhpmcounter5h
-# uimm12
-# CHECK-INST: csrrs t2, 2949, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2949
-csrrs t2, 0xB85, zero
-
-# mhpmcounter6h
-# uimm12
-# CHECK-INST: csrrs t2, 2950, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2950
-csrrs t2, 0xB86, zero
-
-# mhpmcounter7h
-# uimm12
-# CHECK-INST: csrrs t2, 2951, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2951
-csrrs t2, 0xB87, zero
-
-# mhpmcounter8h
-# uimm12
-# CHECK-INST: csrrs t2, 2952, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2952
-csrrs t2, 0xB88, zero
-
-# mhpmcounter9h
-# uimm12
-# CHECK-INST: csrrs t2, 2953, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2953
-csrrs t2, 0xB89, zero
-
-# mhpmcounter10h
-# uimm12
-# CHECK-INST: csrrs t2, 2954, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2954
-csrrs t2, 0xB8A, zero
-
-# mhpmcounter11h
-# uimm12
-# CHECK-INST: csrrs t2, 2955, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2955
-csrrs t2, 0xB8B, zero
-
-# mhpmcounter12h
-# uimm12
-# CHECK-INST: csrrs t2, 2956, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2956
-csrrs t2, 0xB8C, zero
-
-# mhpmcounter13h
-# uimm12
-# CHECK-INST: csrrs t2, 2957, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2957
-csrrs t2, 0xB8D, zero
-
-# mhpmcounter14h
-# uimm12
-# CHECK-INST: csrrs t2, 2958, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2958
-csrrs t2, 0xB8E, zero
-
-# mhpmcounter15h
-# uimm12
-# CHECK-INST: csrrs t2, 2959, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb8]
-# CHECK-INST-ALIAS: csrr t2, 2959
-csrrs t2, 0xB8F, zero
-
-# mhpmcounter16h
-# uimm12
-# CHECK-INST: csrrs t2, 2960, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2960
-csrrs t2, 0xB90, zero
-
-# mhpmcounter17h
-# uimm12
-# CHECK-INST: csrrs t2, 2961, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2961
-csrrs t2, 0xB91, zero
-
-# mhpmcounter18h
-# uimm12
-# CHECK-INST: csrrs t2, 2962, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2962
-csrrs t2, 0xB92, zero
-
-# mhpmcounter19h
-# uimm12
-# CHECK-INST: csrrs t2, 2963, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2963
-csrrs t2, 0xB93, zero
-
-# mhpmcounter20h
-# uimm12
-# CHECK-INST: csrrs t2, 2964, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2964
-csrrs t2, 0xB94, zero
-
-# mhpmcounter21h
-# uimm12
-# CHECK-INST: csrrs t2, 2965, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2965
-csrrs t2, 0xB95, zero
-
-# mhpmcounter22h
-# uimm12
-# CHECK-INST: csrrs t2, 2966, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2966
-csrrs t2, 0xB96, zero
-
-# mhpmcounter23h
-# uimm12
-# CHECK-INST: csrrs t2, 2967, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2967
-csrrs t2, 0xB97, zero
-
-# mhpmcounter24h
-# uimm12
-# CHECK-INST: csrrs t2, 2968, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2968
-csrrs t2, 0xB98, zero
-
-# mhpmcounter25h
-# uimm12
-# CHECK-INST: csrrs t2, 2969, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2969
-csrrs t2, 0xB99, zero
-
-# mhpmcounter26h
-# uimm12
-# CHECK-INST: csrrs t2, 2970, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2970
-csrrs t2, 0xB9A, zero
-
-# mhpmcounter27h
-# uimm12
-# CHECK-INST: csrrs t2, 2971, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2971
-csrrs t2, 0xB9B, zero
-
-# mhpmcounter28h
-# uimm12
-# CHECK-INST: csrrs t2, 2972, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2972
-csrrs t2, 0xB9C, zero
-
-# mhpmcounter29h
-# uimm12
-# CHECK-INST: csrrs t2, 2973, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2973
-csrrs t2, 0xB9D, zero
-
-# mhpmcounter30h
-# uimm12
-# CHECK-INST: csrrs t2, 2974, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2974
-csrrs t2, 0xB9E, zero
-
-# mhpmcounter31h
-# uimm12
-# CHECK-INST: csrrs t2, 2975, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xb9]
-# CHECK-INST-ALIAS: csrr t2, 2975
-csrrs t2, 0xB9F, zero
diff --git a/test/MC/RISCV/rv64-relaxation.s b/test/MC/RISCV/rv64-relaxation.s
deleted file mode 100644
index 202cbafa785..00000000000
--- a/test/MC/RISCV/rv64-relaxation.s
+++ /dev/null
@@ -1,104 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - | FileCheck -check-prefix=INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c,+relax < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - | FileCheck -check-prefix=RELAX-INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c,+relax < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELAX-RELOC %s
-
-FAR_JUMP_NEGATIVE:
-  c.nop
-.space 2000
-
-FAR_BRANCH_NEGATIVE:
-  c.nop
-.space 256
-
-NEAR_NEGATIVE:
-  c.nop
-
-start:
-  c.bnez a0, NEAR
-#INSTR: c.bnez a0, 56
-#RELAX-INSTR: c.bnez a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.bnez a0, NEAR_NEGATIVE
-#INSTR: c.bnez a0, -4
-#RELAX-INSTR: c.bnez a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.bnez a0, FAR_BRANCH
-#INSTR-NEXT: bne a0, zero, 310
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: bne a0, zero, -268
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_JUMP
-#INSTR-NEXT: bne a0, zero, 2304
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.bnez a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: bne a0, zero, -2278
-#RELAX-INSTR-NEXT: bne a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-
-  c.beqz a0, NEAR
-#INSTR-NEXT: c.beqz a0, 36
-#RELAX-INSTR-NEXT: c.beqz a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.beqz a0, NEAR_NEGATIVE
-#INSTR-NEXT: c.beqz a0, -24
-#RELAX-INSTR-NEXT: c.beqz a0, 0
-#RELAX-RELOC: R_RISCV_RVC_BRANCH
-  c.beqz a0, FAR_BRANCH
-#INSTR-NEXT: beq a0, zero, 290
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: beq a0, zero, -288
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_JUMP
-#INSTR-NEXT: beq a0, zero, 2284
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-  c.beqz a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: beq a0, zero, -2298
-#RELAX-INSTR-NEXT: beq a0, zero, 0
-#RELAX-RELOC: R_RISCV_BRANCH
-
-  c.j NEAR
-#INSTR-NEXT: c.j 16
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j NEAR_NEGATIVE
-#INSTR-NEXT: c.j -44
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_BRANCH
-#INSTR-NEXT: c.j 270
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.j -306
-#RELAX-INSTR-NEXT: c.j 0
-#RELAX-RELOC: R_RISCV_RVC_JUMP
-  c.j FAR_JUMP
-#INSTR-NEXT: jal zero, 2268
-#RELAX-INSTR-NEXT: jal zero, 0
-#RELAX-RELOC: R_RISCV_JAL
-  c.j FAR_JUMP_NEGATIVE
-#INSTR-NEXT: jal zero, -2314
-#RELAX-INSTR-NEXT: jal zero, 0
-#RELAX-RELOC: R_RISCV_JAL
-
-NEAR:
-  c.nop
-
-.space 256
-FAR_BRANCH:
-  c.nop
-
-.space 2000
-FAR_JUMP:
-  c.nop
diff --git a/test/MC/RISCV/rv64-user-csr-names.s b/test/MC/RISCV/rv64-user-csr-names.s
deleted file mode 100644
index 6f54c7f2eed..00000000000
--- a/test/MC/RISCV/rv64-user-csr-names.s
+++ /dev/null
@@ -1,236 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-# These user mode CSR register names are RV32 only, but RV64
-# can encode and disassemble these registers if given their value.
-
-##################################
-# User Counter and Timers
-##################################
-
-# cycleh
-# uimm12
-# CHECK-INST: csrrs t2, 3200, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3200
-csrrs t2, 0xC80, zero
-
-# timeh
-# uimm12
-# CHECK-INST: csrrs t2, 3201, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3201
-csrrs t2, 0xC81, zero
-
-# instreth
-# uimm12
-# CHECK-INST: csrrs t2, 3202, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3202
-csrrs t2, 0xC82, zero
-
-# hpmcounter3h
-# uimm12
-# CHECK-INST: csrrs t2, 3203, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3203
-csrrs t2, 0xC83, zero
-
-# hpmcounter4h
-# uimm12
-# CHECK-INST: csrrs t2, 3204, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3204
-csrrs t2, 0xC84, zero
-
-# hpmcounter5h
-# uimm12
-# CHECK-INST: csrrs t2, 3205, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3205
-csrrs t2, 0xC85, zero
-
-# hpmcounter6h
-# uimm12
-# CHECK-INST: csrrs t2, 3206, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3206
-csrrs t2, 0xC86, zero
-
-# hpmcounter7h
-# uimm12
-# CHECK-INST: csrrs t2, 3207, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3207
-csrrs t2, 0xC87, zero
-
-# hpmcounter8h
-# uimm12
-# CHECK-INST: csrrs t2, 3208, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3208
-csrrs t2, 0xC88, zero
-
-# hpmcounter9h
-# uimm12
-# CHECK-INST: csrrs t2, 3209, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3209
-csrrs t2, 0xC89, zero
-
-# hpmcounter10h
-# uimm12
-# CHECK-INST: csrrs t2, 3210, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3210
-csrrs t2, 0xC8A, zero
-
-# hpmcounter11h
-# uimm12
-# CHECK-INST: csrrs t2, 3211, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3211
-csrrs t2, 0xC8B, zero
-
-# hpmcounter12h
-# uimm12
-# CHECK-INST: csrrs t2, 3212, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3212
-csrrs t2, 0xC8C, zero
-
-# hpmcounter13h
-# uimm12
-# CHECK-INST: csrrs t2, 3213, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3213
-csrrs t2, 0xC8D, zero
-
-# hpmcounter14h
-# uimm12
-# CHECK-INST: csrrs t2, 3214, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3214
-csrrs t2, 0xC8E, zero
-
-# hpmcounter15h
-# uimm12
-# CHECK-INST: csrrs t2, 3215, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc8]
-# CHECK-INST-ALIAS: csrr t2, 3215
-csrrs t2, 0xC8F, zero
-
-# hpmcounter16h
-# uimm12
-# CHECK-INST: csrrs t2, 3216, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3216
-csrrs t2, 0xC90, zero
-
-# hpmcounter17h
-# uimm12
-# CHECK-INST: csrrs t2, 3217, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3217
-csrrs t2, 0xC91, zero
-
-# hpmcounter18h
-# uimm12
-# CHECK-INST: csrrs t2, 3218, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3218
-csrrs t2, 0xC92, zero
-
-# hpmcounter19h
-# uimm12
-# CHECK-INST: csrrs t2, 3219, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3219
-csrrs t2, 0xC93, zero
-
-# hpmcounter20h
-# uimm12
-# CHECK-INST: csrrs t2, 3220, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3220
-csrrs t2, 0xC94, zero
-
-# hpmcounter21h
-# uimm12
-# CHECK-INST: csrrs t2, 3221, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3221
-csrrs t2, 0xC95, zero
-
-# hpmcounter22h
-# uimm12
-# CHECK-INST: csrrs t2, 3222, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3222
-csrrs t2, 0xC96, zero
-
-# hpmcounter23h
-# uimm12
-# CHECK-INST: csrrs t2, 3223, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3223
-csrrs t2, 0xC97, zero
-
-# hpmcounter24h
-# uimm12
-# CHECK-INST: csrrs t2, 3224, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3224
-csrrs t2, 0xC98, zero
-
-# hpmcounter25h
-# uimm12
-# CHECK-INST: csrrs t2, 3225, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3225
-csrrs t2, 0xC99, zero
-
-# hpmcounter26h
-# uimm12
-# CHECK-INST: csrrs t2, 3226, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3226
-csrrs t2, 0xC9A, zero
-
-# hpmcounter27h
-# uimm12
-# CHECK-INST: csrrs t2, 3227, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3227
-csrrs t2, 0xC9B, zero
-
-# hpmcounter28h
-# uimm12
-# CHECK-INST: csrrs t2, 3228, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3228
-csrrs t2, 0xC9C, zero
-
-# hpmcounter29h
-# uimm12
-# CHECK-INST: csrrs t2, 3229, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3229
-csrrs t2, 0xC9D, zero
-
-# hpmcounter30h
-# uimm12
-# CHECK-INST: csrrs t2, 3230, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3230
-csrrs t2, 0xC9E, zero
-
-# hpmcounter31h
-# uimm12
-# CHECK-INST: csrrs t2, 3231, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc9]
-# CHECK-INST-ALIAS: csrr t2, 3231
-csrrs t2, 0xC9F, zero
diff --git a/test/MC/RISCV/rv64a-invalid.s b/test/MC/RISCV/rv64a-invalid.s
deleted file mode 100644
index 7ab89ff9994..00000000000
--- a/test/MC/RISCV/rv64a-invalid.s
+++ /dev/null
@@ -1,14 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+a < %s 2>&1 | FileCheck %s
-
-# Final operand must have parentheses
-amoswap.d a1, a2, a3 # CHECK: :[[@LINE]]:19: error: invalid operand for instruction
-amomin.d a1, a2, 1 # CHECK: :[[@LINE]]:18: error: invalid operand for instruction
-lr.d a4, a5 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Only .aq, .rl, and .aqrl suffixes are valid
-amoxor.d.rlqa a2, a3, (a4) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.d.aq.rl a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.d. a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# lr only takes two operands
-lr.d s0, (s1), s2 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64a-valid.s b/test/MC/RISCV/rv64a-valid.s
deleted file mode 100644
index 2112727a8f2..00000000000
--- a/test/MC/RISCV/rv64a-valid.s
+++ /dev/null
@@ -1,193 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 -mattr=+a < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# FIXME: error messages for rv32a are misleading
-
-# CHECK-ASM-AND-OBJ: lr.d t0, (t1)
-# CHECK-ASM: encoding: [0xaf,0x32,0x03,0x10]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d t0, (t1)
-# CHECK-ASM-AND-OBJ: lr.d.aq t1, (t2)
-# CHECK-ASM: encoding: [0x2f,0xb3,0x03,0x14]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.aq t1, (t2)
-# CHECK-ASM-AND-OBJ: lr.d.rl t2, (t3)
-# CHECK-ASM: encoding: [0xaf,0x33,0x0e,0x12]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.rl t2, (t3)
-# CHECK-ASM-AND-OBJ: lr.d.aqrl t3, (t4)
-# CHECK-ASM: encoding: [0x2f,0xbe,0x0e,0x16]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.aqrl t3, (t4)
-
-# CHECK-ASM-AND-OBJ: sc.d t6, t5, (t4)
-# CHECK-ASM: encoding: [0xaf,0xbf,0xee,0x19]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d t6, t5, (t4)
-# CHECK-ASM-AND-OBJ: sc.d.aq t5, t4, (t3)
-# CHECK-ASM: encoding: [0x2f,0x3f,0xde,0x1d]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.aq t5, t4, (t3)
-# CHECK-ASM-AND-OBJ: sc.d.rl t4, t3, (t2)
-# CHECK-ASM: encoding: [0xaf,0xbe,0xc3,0x1b]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.rl t4, t3, (t2)
-# CHECK-ASM-AND-OBJ: sc.d.aqrl t3, t2, (t1)
-# CHECK-ASM: encoding: [0x2f,0x3e,0x73,0x1e]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.aqrl t3, t2, (t1)
-
-# CHECK-ASM-AND-OBJ: amoswap.d a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x37,0x14,0x08]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.d a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xb5,0xc6,0x00]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.d a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x36,0xd7,0x20]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.d a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xb6,0xe7,0x60]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.d a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x37,0xf8,0x40]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.d a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xb7,0x08,0x81]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.d s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xbb,0x6a,0xa1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.d s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x3b,0x5a,0xc1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.d s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xba,0x49,0xe1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d s5, s4, (s3)
-
-
-# CHECK-ASM-AND-OBJ: amoswap.d.aq a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x37,0x14,0x0c]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.aq a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.d.aq a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xb5,0xc6,0x04]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.aq a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.d.aq a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x36,0xd7,0x24]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.aq a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.d.aq a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xb6,0xe7,0x64]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.aq a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.d.aq a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x37,0xf8,0x44]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.aq a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.d.aq a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xb7,0x08,0x85]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.aq a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.d.aq s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xbb,0x6a,0xa5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.aq s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.d.aq s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x3b,0x5a,0xc5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.aq s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.d.aq s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xba,0x49,0xe5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.aq s5, s4, (s3)
-
-# CHECK-ASM-AND-OBJ: amoswap.d.rl a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x37,0x14,0x0a]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.rl a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.d.rl a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xb5,0xc6,0x02]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.rl a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.d.rl a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x36,0xd7,0x22]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.rl a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.d.rl a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xb6,0xe7,0x62]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.rl a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.d.rl a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x37,0xf8,0x42]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.rl a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.d.rl a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xb7,0x08,0x83]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.rl a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.d.rl s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xbb,0x6a,0xa3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.rl s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.d.rl s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x3b,0x5a,0xc3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.rl s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.d.rl s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xba,0x49,0xe3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.rl s5, s4, (s3)
-
-# CHECK-ASM-AND-OBJ: amoswap.d.aqrl a4, ra, (s0)
-# CHECK-ASM: encoding: [0x2f,0x37,0x14,0x0e]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.aqrl a4, ra, (s0)
-# CHECK-ASM-AND-OBJ: amoadd.d.aqrl a1, a2, (a3)
-# CHECK-ASM: encoding: [0xaf,0xb5,0xc6,0x06]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.aqrl a1, a2, (a3)
-# CHECK-ASM-AND-OBJ: amoxor.d.aqrl a2, a3, (a4)
-# CHECK-ASM: encoding: [0x2f,0x36,0xd7,0x26]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.aqrl a2, a3, (a4)
-# CHECK-ASM-AND-OBJ: amoand.d.aqrl a3, a4, (a5)
-# CHECK-ASM: encoding: [0xaf,0xb6,0xe7,0x66]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.aqrl a3, a4, (a5)
-# CHECK-ASM-AND-OBJ: amoor.d.aqrl a4, a5, (a6)
-# CHECK-ASM: encoding: [0x2f,0x37,0xf8,0x46]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.aqrl a4, a5, (a6)
-# CHECK-ASM-AND-OBJ: amomin.d.aqrl a5, a6, (a7)
-# CHECK-ASM: encoding: [0xaf,0xb7,0x08,0x87]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.aqrl a5, a6, (a7)
-# CHECK-ASM-AND-OBJ: amomax.d.aqrl s7, s6, (s5)
-# CHECK-ASM: encoding: [0xaf,0xbb,0x6a,0xa7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.aqrl s7, s6, (s5)
-# CHECK-ASM-AND-OBJ: amominu.d.aqrl s6, s5, (s4)
-# CHECK-ASM: encoding: [0x2f,0x3b,0x5a,0xc7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.aqrl s6, s5, (s4)
-# CHECK-ASM-AND-OBJ: amomaxu.d.aqrl s5, s4, (s3)
-# CHECK-ASM: encoding: [0xaf,0xba,0x49,0xe7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.aqrl s5, s4, (s3)
diff --git a/test/MC/RISCV/rv64c-aliases-valid.s b/test/MC/RISCV/rv64c-aliases-valid.s
deleted file mode 100644
index a645763c788..00000000000
--- a/test/MC/RISCV/rv64c-aliases-valid.s
+++ /dev/null
@@ -1,96 +0,0 @@
-# RUN: llvm-mc -triple=riscv64 -mattr=+c -riscv-no-aliases < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-
-# The following check prefixes are used in this test:
-# CHECK-INST.....Match the canonical instr (tests alias to instr. mapping)
-# CHECK-EXPAND...Match canonical instr. unconditionally (tests alias expansion)
-
-# CHECK-EXPAND: c.li a0, 0
-li x10, 0
-# CHECK-EXPAND: c.li a0, 1
-li x10, 1
-# CHECK-EXPAND: c.li a0, -1
-li x10, -1
-# CHECK-EXPAND: addi a0, zero, 2047
-li x10, 2047
-# CHECK-EXPAND: addi a0, zero, -2047
-li x10, -2047
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: addiw a1, a1, -2048
-li x11, 2048
-# CHECK-EXPAND: addi a1, zero, -2048
-li x11, -2048
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: addiw a1, a1, -2047
-li x11, 2049
-# CHECK-EXPAND: c.lui a1, 1048575
-# CHECK-EXPAND: addiw a1, a1, 2047
-li x11, -2049
-# CHECK-EXPAND: c.lui a1, 1
-# CHECK-EXPAND: c.addiw a1, -1
-li x11, 4095
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: c.addiw a1, 1
-li x11, -4095
-# CHECK-EXPAND: c.lui a2, 1
-li x12, 4096
-# CHECK-EXPAND: lui a2, 1048575
-li x12, -4096
-# CHECK-EXPAND: c.lui a2, 1
-# CHECK-EXPAND: c.addiw a2, 1
-li x12, 4097
-# CHECK-EXPAND: lui a2, 1048575
-# CHECK-EXPAND: c.addiw a2, -1
-li x12, -4097
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: c.addiw a2, -1
-li x12, 2147483647
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: c.addiw a2, 1
-li x12, -2147483647
-# CHECK-EXPAND: lui a2, 524288
-li x12, -2147483648
-# CHECK-EXPAND: lui a2, 524288
-li x12, -0x80000000
-
-# CHECK-EXPAND: c.li a2, 1
-# CHECK-EXPAND: c.slli a2, 31
-li x12, 0x80000000
-# CHECK-EXPAND: c.li a2, 1
-# CHECK-EXPAND: c.slli a2, 32
-# CHECK-EXPAND: c.addi a2, -1
-li x12, 0xFFFFFFFF
-
-# CHECK-EXPAND: c.li t0, 1
-# CHECK-EXPAND: c.slli t0, 32
-li t0, 0x100000000
-# CHECK-EXPAND: c.li t1, -1
-# CHECK-EXPAND: c.slli t1, 63
-li t1, 0x8000000000000000
-# CHECK-EXPAND: c.li t1, -1
-# CHECK-EXPAND: c.slli t1, 63
-li t1, -0x8000000000000000
-# CHECK-EXPAND: lui t2, 9321
-# CHECK-EXPAND: addiw t2, t2, -1329
-# CHECK-EXPAND: c.slli t2, 35
-li t2, 0x1234567800000000
-# CHECK-EXPAND: c.li t3, 7
-# CHECK-EXPAND: c.slli t3, 36
-# CHECK-EXPAND: c.addi t3, 11
-# CHECK-EXPAND: c.slli t3, 24
-# CHECK-EXPAND: c.addi t3, 15
-li t3, 0x700000000B00000F
-# CHECK-EXPAND: lui t4, 583
-# CHECK-EXPAND: addiw t4, t4, -1875
-# CHECK-EXPAND: c.slli t4, 14
-# CHECK-EXPAND: addi t4, t4, -947
-# CHECK-EXPAND: c.slli t4, 12
-# CHECK-EXPAND: addi t4, t4, 1511
-# CHECK-EXPAND: c.slli t4, 13
-# CHECK-EXPAND: addi t4, t4, -272
-li t4, 0x123456789abcdef0
-# CHECK-EXPAND: c.li t5, -1
-li t5, 0xFFFFFFFFFFFFFFFF
diff --git a/test/MC/RISCV/rv64c-invalid.s b/test/MC/RISCV/rv64c-invalid.s
deleted file mode 100644
index e50f48b4213..00000000000
--- a/test/MC/RISCV/rv64c-invalid.s
+++ /dev/null
@@ -1,32 +0,0 @@
-# RUN: not llvm-mc -triple=riscv64 -mattr=+c < %s 2>&1 | FileCheck %s
-
-## GPRC
-c.ld ra, 4(sp) # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-c.sd sp, 4(sp) # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-c.addw   a0, a7 # CHECK: :[[@LINE]]:14: error: invalid operand for instruction
-c.subw   a0, a6 # CHECK: :[[@LINE]]:14: error: invalid operand for instruction
-
-## GPRNoX0
-c.ldsp  x0, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.ldsp  zero, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# Out of range immediates
-
-## uimmlog2xlennonzero
-c.slli t0, 64 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-c.srli a0, -1 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-c.srai a0, 0  # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-
-## simm6
-c.addiw t0, -33 # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-c.addiw t0, 32 # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-c.addiw t0, foo # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-c.addiw t0, %lo(foo) # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-c.addiw t0, %hi(foo) # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-
-## uimm9_lsb000
-c.ldsp  ra, 512(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-c.sdsp  ra, -8(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-## uimm8_lsb000
-c.ld  s0, -8(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 8 bytes in the range [0, 248]
-c.sd  s0, 256(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 8 bytes in the range [0, 248]
diff --git a/test/MC/RISCV/rv64c-valid.s b/test/MC/RISCV/rv64c-valid.s
deleted file mode 100644
index 959aaf34fa5..00000000000
--- a/test/MC/RISCV/rv64c-valid.s
+++ /dev/null
@@ -1,62 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+c -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -mattr=+c -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-#
-# RUN: not llvm-mc -triple riscv64 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# FIXME: error messages for rv32c are misleading
-
-# TODO: more exhaustive testing of immediate encoding.
-
-# CHECK-ASM-AND-OBJ: c.ldsp ra, 0(sp)
-# CHECK-ASM: encoding: [0x82,0x60]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.ldsp ra, 0(sp)
-# CHECK-ASM-AND-OBJ: c.sdsp ra, 504(sp)
-# CHECK-ASM: encoding: [0x86,0xff]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.sdsp ra, 504(sp)
-# CHECK-ASM-AND-OBJ: c.ld a4, 0(a3)
-# CHECK-ASM: encoding: [0x98,0x62]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.ld a4, 0(a3)
-# CHECK-ASM-AND-OBJ: c.sd a5, 248(a3)
-# CHECK-ASM: encoding: [0xfc,0xfe]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.sd a5, 248(a3)
-
-# CHECK-ASM-AND-OBJ: c.subw a3, a4
-# CHECK-ASM: encoding: [0x99,0x9e]
-c.subw a3, a4
-# CHECK-ASM-AND-OBJ: c.addw a0, a2
-# CHECK-ASM: encoding: [0x31,0x9d]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addw a0, a2
-
-# CHECK-ASM-AND-OBJ: c.addiw a3, -32
-# CHECK-ASM: encoding: [0x81,0x36]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addiw a3, -32
-# CHECK-ASM-AND-OBJ: c.addiw a3, 31
-# CHECK-ASM: encoding: [0xfd,0x26]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addiw a3, 31
-
-# CHECK-ASM-AND-OBJ: c.slli s0, 1
-# CHECK-ASM: encoding: [0x06,0x04]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.slli s0, 1
-# CHECK-ASM-AND-OBJ: c.srli a3, 63
-# CHECK-ASM: encoding: [0xfd,0x92]
-c.srli a3, 63
-# CHECK-ASM-AND-OBJ: c.srai a2, 63
-# CHECK-ASM: encoding: [0x7d,0x96]
-c.srai a2, 63
diff --git a/test/MC/RISCV/rv64d-aliases-valid.s b/test/MC/RISCV/rv64d-aliases-valid.s
deleted file mode 100644
index f6c5663eac7..00000000000
--- a/test/MC/RISCV/rv64d-aliases-valid.s
+++ /dev/null
@@ -1,27 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fcvt.l.d a0, ft0, dyn
-# CHECK-ALIAS: fcvt.l.d a0, ft0{{[[:space:]]}}
-fcvt.l.d a0, ft0
-# CHECK-INST: fcvt.lu.d a1, ft1, dyn
-# CHECK-ALIAS: fcvt.lu.d a1, ft1{{[[:space:]]}}
-fcvt.lu.d a1, ft1
-# CHECK-INST: fcvt.d.l ft3, a3, dyn
-# CHECK-ALIAS: fcvt.d.l ft3, a3{{[[:space:]]}}
-fcvt.d.l ft3, a3
-# CHECK-INST: fcvt.d.lu ft4, a4, dyn
-# CHECK-ALIAS: fcvt.d.lu ft4, a4{{[[:space:]]}}
-fcvt.d.lu ft4, a4
diff --git a/test/MC/RISCV/rv64d-invalid.s b/test/MC/RISCV/rv64d-invalid.s
deleted file mode 100644
index 0f508aafd9b..00000000000
--- a/test/MC/RISCV/rv64d-invalid.s
+++ /dev/null
@@ -1,11 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+d < %s 2>&1 | FileCheck %s
-
-# Integer registers where FP regs are expected
-fcvt.l.d ft0, a0 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.lu.d ft1, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-fmv.x.d ft2, a2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.d.l a3, ft3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.d.lu a4, ft4 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-fmv.d.x a5, ft5 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64d-valid.s b/test/MC/RISCV/rv64d-valid.s
deleted file mode 100644
index 06ce1d36460..00000000000
--- a/test/MC/RISCV/rv64d-valid.s
+++ /dev/null
@@ -1,53 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 -mattr=+d < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# FIXME: error messages for rv32d are misleading
-
-# CHECK-ASM-AND-OBJ: fcvt.l.d a0, ft0, dyn
-# CHECK-ASM: encoding: [0x53,0x75,0x20,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.d a0, ft0, dyn
-# CHECK-ASM-AND-OBJ: fcvt.lu.d a1, ft1, dyn
-# CHECK-ASM: encoding: [0xd3,0xf5,0x30,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.d a1, ft1, dyn
-# CHECK-ASM-AND-OBJ: fmv.x.d a2, ft2
-# CHECK-ASM: encoding: [0x53,0x06,0x01,0xe2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fmv.x.d a2, ft2
-# CHECK-ASM-AND-OBJ: fcvt.d.l ft3, a3, dyn
-# CHECK-ASM: encoding: [0xd3,0xf1,0x26,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.l ft3, a3, dyn
-# CHECK-ASM-AND-OBJ: fcvt.d.lu ft4, a4, dyn
-# CHECK-ASM: encoding: [0x53,0x72,0x37,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.lu ft4, a4, dyn
-# CHECK-ASM-AND-OBJ: fmv.d.x ft5, a5
-# CHECK-ASM: encoding: [0xd3,0x82,0x07,0xf2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fmv.d.x ft5, a5
-
-# Rounding modes
-# CHECK-ASM-AND-OBJ: fcvt.d.l ft3, a3, rne
-# CHECK-ASM: encoding: [0xd3,0x81,0x26,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.l ft3, a3, rne
-# CHECK-ASM-AND-OBJ: fcvt.d.lu ft4, a4, rtz
-# CHECK-ASM: encoding: [0x53,0x12,0x37,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.lu ft4, a4, rtz
-# CHECK-ASM-AND-OBJ: fcvt.l.d a0, ft0, rdn
-# CHECK-ASM: encoding: [0x53,0x25,0x20,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.d a0, ft0, rdn
-# CHECK-ASM-AND-OBJ: fcvt.lu.d a1, ft1, rup
-# CHECK-ASM: encoding: [0xd3,0xb5,0x30,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.d a1, ft1, rup
diff --git a/test/MC/RISCV/rv64dc-valid.s b/test/MC/RISCV/rv64dc-valid.s
deleted file mode 100644
index 18f1a68df60..00000000000
--- a/test/MC/RISCV/rv64dc-valid.s
+++ /dev/null
@@ -1,29 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+c,+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+c,+d < %s \
-# RUN:     | llvm-objdump -mattr=+c,+d -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv64 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv64 -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# CHECK-ASM-AND-OBJ: c.fldsp  fs0, 504(sp)
-# CHECK-ASM: encoding: [0x7e,0x34]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fldsp  fs0, 504(sp)
-# CHECK-ASM-AND-OBJ: c.fsdsp  fa7, 504(sp)
-# CHECK-ASM: encoding: [0xc6,0xbf]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsdsp  fa7, 504(sp)
-
-# CHECK-ASM-AND-OBJ: c.fld  fa3, 248(a5)
-# CHECK-ASM: encoding: [0xf4,0x3f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fld  fa3, 248(a5)
-# CHECK-ASM-AND-OBJ: c.fsd  fa2, 248(a1)
-# CHECK-ASM: encoding: [0xf0,0xbd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsd  fa2, 248(a1)
diff --git a/test/MC/RISCV/rv64f-aliases-valid.s b/test/MC/RISCV/rv64f-aliases-valid.s
deleted file mode 100644
index c9c2a4b6d74..00000000000
--- a/test/MC/RISCV/rv64f-aliases-valid.s
+++ /dev/null
@@ -1,27 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fcvt.l.s a0, ft0, dyn
-# CHECK-ALIAS: fcvt.l.s a0, ft0{{[[:space:]]}}
-fcvt.l.s a0, ft0
-# CHECK-INST: fcvt.lu.s a1, ft1, dyn
-# CHECK-ALIAS: fcvt.lu.s a1, ft1{{[[:space:]]}}
-fcvt.lu.s a1, ft1
-# CHECK-INST: fcvt.s.l ft2, a2, dyn
-# CHECK-ALIAS: fcvt.s.l ft2, a2{{[[:space:]]}}
-fcvt.s.l ft2, a2
-# CHECK-INST: fcvt.s.lu ft3, a3, dyn
-# CHECK-ALIAS: fcvt.s.lu ft3, a3{{[[:space:]]}}
-fcvt.s.lu ft3, a3
diff --git a/test/MC/RISCV/rv64f-invalid.s b/test/MC/RISCV/rv64f-invalid.s
deleted file mode 100644
index 698da796a7e..00000000000
--- a/test/MC/RISCV/rv64f-invalid.s
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+f < %s 2>&1 | FileCheck %s
-
-# Integer registers where FP regs are expected
-fcvt.l.s ft0, a0 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.lu.s ft1, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.s.l a2, ft2 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.s.lu a3, ft3 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64f-valid.s b/test/MC/RISCV/rv64f-valid.s
deleted file mode 100644
index caf6d081151..00000000000
--- a/test/MC/RISCV/rv64f-valid.s
+++ /dev/null
@@ -1,41 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-#
-# RUN: not llvm-mc -triple riscv32 -mattr=+f < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# FIXME: error messages for rv32f are misleading
-
-# CHECK-ASM-AND-OBJ: fcvt.l.s a0, ft0, dyn
-# CHECK-ASM: encoding: [0x53,0x75,0x20,0xc0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.s a0, ft0, dyn
-# CHECK-ASM-AND-OBJ: fcvt.lu.s a1, ft1, dyn
-# CHECK-ASM: encoding: [0xd3,0xf5,0x30,0xc0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.s a1, ft1, dyn
-# CHECK-ASM-AND-OBJ: fcvt.s.l ft2, a2, dyn
-# CHECK-ASM: encoding: [0x53,0x71,0x26,0xd0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.l ft2, a2, dyn
-# CHECK-ASM-AND-OBJ: fcvt.s.lu ft3, a3, dyn
-# CHECK-ASM: encoding: [0xd3,0xf1,0x36,0xd0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.lu ft3, a3, dyn
-
-# Rounding modes
-# CHECK-ASM-AND-OBJ: fcvt.l.s a4, ft4, rne
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.s a4, ft4, rne
-# CHECK-ASM-AND-OBJ: fcvt.lu.s a5, ft5, rtz
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.s a5, ft5, rtz
-# CHECK-ASM-AND-OBJ: fcvt.s.l ft6, a6, rdn
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.l ft6, a6, rdn
-# CHECK-ASM-AND-OBJ: fcvt.s.lu ft7, a7, rup
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.lu ft7, a7, rup
diff --git a/test/MC/RISCV/rv64i-aliases-invalid.s b/test/MC/RISCV/rv64i-aliases-invalid.s
deleted file mode 100644
index f3f2acc473d..00000000000
--- a/test/MC/RISCV/rv64i-aliases-invalid.s
+++ /dev/null
@@ -1,28 +0,0 @@
-# RUN: not llvm-mc %s -triple=riscv64 -riscv-no-aliases 2>&1 | FileCheck %s
-# RUN: not llvm-mc %s -triple=riscv64 2>&1 | FileCheck %s
-
-li t5, 0x10000000000000000 # CHECK: :[[@LINE]]:8: error: unknown operand
-li t4, foo                 # CHECK: :[[@LINE]]:8: error: operand must be a constant 64-bit integer
-
-rdinstreth x29 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-rdcycleh x27   # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-rdtimeh x28    # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-sll x2, x3, 64  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-srl x2, x3, 64  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-sra x2, x3, 64  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-
-sll x2, x3, -1  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-srl x2, x3, -2  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-sra x2, x3, -3  # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 63]
-
-sllw x2, x3, 32  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srlw x2, x3, 32  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-sraw x2, x3, 32  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-
-sllw x2, x3, -1  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srlw x2, x3, -2  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-sraw x2, x3, -3  # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-
-foo:
-  .space 8
diff --git a/test/MC/RISCV/rv64i-aliases-valid.s b/test/MC/RISCV/rv64i-aliases-valid.s
deleted file mode 100644
index 64bb36eaad6..00000000000
--- a/test/MC/RISCV/rv64i-aliases-valid.s
+++ /dev/null
@@ -1,131 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-EXPAND,CHECK-ALIAS %s
-
-# The following check prefixes are used in this test:
-# CHECK-INST.....Match the canonical instr (tests alias to instr. mapping)
-# CHECK-ALIAS....Match the alias (tests instr. to alias mapping)
-# CHECK-EXPAND...Match canonical instr. unconditionally (tests alias expansion)
-
-# TODO ld
-# TODO sd
-
-# CHECK-INST: addi a0, zero, 0
-# CHECK-ALIAS: mv a0, zero
-li x10, 0
-# CHECK-EXPAND: addi a0, zero, 1
-li x10, 1
-# CHECK-EXPAND: addi a0, zero, -1
-li x10, -1
-# CHECK-EXPAND: addi a0, zero, 2047
-li x10, 2047
-# CHECK-EXPAND: addi a0, zero, -2047
-li x10, -2047
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addiw a1, a1, -2048
-li x11, 2048
-# CHECK-EXPAND: addi a1, zero, -2048
-li x11, -2048
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addiw a1, a1, -2047
-li x11, 2049
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: addiw a1, a1, 2047
-li x11, -2049
-# CHECK-EXPAND: lui a1, 1
-# CHECK-EXPAND: addiw a1, a1, -1
-li x11, 4095
-# CHECK-EXPAND: lui a1, 1048575
-# CHECK-EXPAND: addiw a1, a1, 1
-li x11, -4095
-# CHECK-EXPAND: lui a2, 1
-li x12, 4096
-# CHECK-EXPAND: lui a2, 1048575
-li x12, -4096
-# CHECK-EXPAND: lui a2, 1
-# CHECK-EXPAND: addiw a2, a2, 1
-li x12, 4097
-# CHECK-EXPAND: lui a2, 1048575
-# CHECK-EXPAND: addiw a2, a2, -1
-li x12, -4097
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: addiw a2, a2, -1
-li x12, 2147483647
-# CHECK-EXPAND: lui a2, 524288
-# CHECK-EXPAND: addiw a2, a2, 1
-li x12, -2147483647
-# CHECK-EXPAND: lui a2, 524288
-li x12, -2147483648
-# CHECK-EXPAND: lui a2, 524288
-li x12, -0x80000000
-
-# CHECK-EXPAND: addi a2, zero, 1
-# CHECK-EXPAND: slli a2, a2, 31
-li x12, 0x80000000
-# CHECK-EXPAND: addi a2, zero, 1
-# CHECK-EXPAND: slli a2, a2, 32
-# CHECK-EXPAND: addi a2, a2, -1
-li x12, 0xFFFFFFFF
-
-# CHECK-EXPAND: addi t0, zero, 1
-# CHECK-EXPAND: slli t0, t0, 32
-li t0, 0x100000000
-# CHECK-EXPAND: addi t1, zero, -1
-# CHECK-EXPAND: slli t1, t1, 63
-li t1, 0x8000000000000000
-# CHECK-EXPAND: addi t1, zero, -1
-# CHECK-EXPAND: slli t1, t1, 63
-li t1, -0x8000000000000000
-# CHECK-EXPAND: lui t2, 9321
-# CHECK-EXPAND: addiw t2, t2, -1329
-# CHECK-EXPAND: slli t2, t2, 35
-li t2, 0x1234567800000000
-# CHECK-EXPAND: addi t3, zero, 7
-# CHECK-EXPAND: slli t3, t3, 36
-# CHECK-EXPAND: addi t3, t3, 11
-# CHECK-EXPAND: slli t3, t3, 24
-# CHECK-EXPAND: addi t3, t3, 15
-li t3, 0x700000000B00000F
-# CHECK-EXPAND: lui t4, 583
-# CHECK-EXPAND: addiw t4, t4, -1875
-# CHECK-EXPAND: slli t4, t4, 14
-# CHECK-EXPAND: addi t4, t4, -947
-# CHECK-EXPAND: slli t4, t4, 12
-# CHECK-EXPAND: addi t4, t4, 1511
-# CHECK-EXPAND: slli t4, t4, 13
-# CHECK-EXPAND: addi t4, t4, -272
-li t4, 0x123456789abcdef0
-# CHECK-EXPAND: addi t5, zero, -1
-li t5, 0xFFFFFFFFFFFFFFFF
-
-# CHECK-INST: subw t6, zero, ra
-# CHECK-ALIAS: negw t6, ra
-negw x31, x1
-# CHECK-INST: addiw t6, ra, 0
-# CHECK-ALIAS: sext.w t6, ra
-sext.w x31, x1
-
-# The following aliases are accepted as input but the canonical form
-# of the instruction will always be printed.
-# CHECK-INST: addiw a2, a3, 4
-# CHECK-ALIAS: addiw a2, a3, 4
-addw a2,a3,4
-
-# CHECK-INST: slliw a2, a3, 4
-# CHECK-ALIAS: slliw a2, a3, 4
-sllw a2,a3,4
-
-# CHECK-INST: srliw a2, a3, 4
-# CHECK-ALIAS: srliw a2, a3, 4
-srlw a2,a3,4
-
-# CHECK-INST: sraiw a2, a3, 4
-# CHECK-ALIAS: sraiw a2, a3, 4
-sraw a2,a3,4
diff --git a/test/MC/RISCV/rv64i-invalid.s b/test/MC/RISCV/rv64i-invalid.s
deleted file mode 100644
index 39a7ac4b4fd..00000000000
--- a/test/MC/RISCV/rv64i-invalid.s
+++ /dev/null
@@ -1,20 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## uimm5
-slliw a0, a0, 32 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-srliw a0, a0, -1 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-sraiw a0, a0, -19 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-addiw a0, a1, -2049 # CHECK: :[[@LINE]]:15: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-ld ra, 2048(sp) # CHECK: :[[@LINE]]:8: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
-
-# Illegal operand modifier
-## uimm5
-slliw a0, a0, %lo(1) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-srliw a0, a0, %lo(a) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-sraiw a0, a0, %hi(2) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-addiw a0, a1, %hi(foo) # CHECK: :[[@LINE]]:15: error: operand must be a symbol with %lo/%pcrel_lo modifier or an integer in the range [-2048, 2047]
diff --git a/test/MC/RISCV/rv64i-valid.s b/test/MC/RISCV/rv64i-valid.s
deleted file mode 100644
index 337b996e447..00000000000
--- a/test/MC/RISCV/rv64i-valid.s
+++ /dev/null
@@ -1,99 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: lwu zero, 4(ra)
-# CHECK-ASM: encoding: [0x03,0xe0,0x40,0x00]
-lwu x0, 4(x1)
-# CHECK-ASM-AND-OBJ: lwu sp, 4(gp)
-# CHECK-ASM: encoding: [0x03,0xe1,0x41,0x00]
-lwu x2, +4(x3)
-# CHECK-ASM-AND-OBJ: lwu tp, -2048(t0)
-# CHECK-ASM: encoding: [0x03,0xe2,0x02,0x80]
-lwu x4, -2048(x5)
-# CHECK-ASM-AND-OBJ: lwu t1, -2048(t2)
-# CHECK-ASM: encoding: [0x03,0xe3,0x03,0x80]
-lwu x6, %lo(2048)(x7)
-# CHECK-ASM-AND-OBJ: lwu s0, 2047(s1)
-# CHECK-ASM: encoding: [0x03,0xe4,0xf4,0x7f]
-lwu x8, 2047(x9)
-
-# CHECK-ASM-AND-OBJ: ld a0, -2048(a1)
-# CHECK-ASM: encoding: [0x03,0xb5,0x05,0x80]
-ld x10, -2048(x11)
-# CHECK-ASM-AND-OBJ: ld a2, -2048(a3)
-# CHECK-ASM: encoding: [0x03,0xb6,0x06,0x80]
-ld x12, %lo(2048)(x13)
-# CHECK-ASM-AND-OBJ: ld a4, 2047(a5)
-# CHECK-ASM: encoding: [0x03,0xb7,0xf7,0x7f]
-ld x14, 2047(x15)
-
-# CHECK-ASM-AND-OBJ: sd a6, -2048(a7)
-# CHECK-ASM: encoding: [0x23,0xb0,0x08,0x81]
-sd x16, -2048(x17)
-# CHECK-ASM-AND-OBJ: sd s2, -2048(s3)
-# CHECK-ASM: encoding: [0x23,0xb0,0x29,0x81]
-sd x18, %lo(2048)(x19)
-# CHECK-ASM-AND-OBJ: sd s4, 2047(s5)
-# CHECK-ASM: encoding: [0xa3,0xbf,0x4a,0x7f]
-sd x20, 2047(x21)
-
-# CHECK-ASM-AND-OBJ: slli s6, s7, 45
-# CHECK-ASM: encoding: [0x13,0x9b,0xdb,0x02]
-slli x22, x23, 45
-# CHECK-ASM-AND-OBJ: srli s8, s9, 0
-# CHECK-ASM: encoding: [0x13,0xdc,0x0c,0x00]
-srli x24, x25, 0
-# CHECK-ASM-AND-OBJ: srai s10, s11, 31
-# CHECK-ASM: encoding: [0x13,0xdd,0xfd,0x41]
-srai x26, x27, 31
-
-# CHECK-ASM-AND-OBJ: addiw t3, t4, -2048
-# CHECK-ASM: encoding: [0x1b,0x8e,0x0e,0x80]
-addiw x28, x29, -2048
-# CHECK-ASM-AND-OBJ: addiw t5, t6, 2047
-# CHECK-ASM: encoding: [0x1b,0x8f,0xff,0x7f]
-addiw x30, x31, 2047
-
-# CHECK-ASM-AND-OBJ: slliw zero, ra, 0
-# CHECK-ASM: encoding: [0x1b,0x90,0x00,0x00]
-slliw zero, ra, 0
-# CHECK-ASM-AND-OBJ: slliw sp, gp, 31
-# CHECK-ASM: encoding: [0x1b,0x91,0xf1,0x01]
-slliw sp, gp, 31
-# CHECK-ASM-AND-OBJ: srliw tp, t0, 0
-# CHECK-ASM: encoding: [0x1b,0xd2,0x02,0x00]
-srliw tp, t0, 0
-# CHECK-ASM-AND-OBJ: srliw t1, t2, 31
-# CHECK-ASM: encoding: [0x1b,0xd3,0xf3,0x01]
-srliw t1, t2, 31
-# CHECK-ASM-AND-OBJ: sraiw s0, s1, 0
-# CHECK-ASM: encoding: [0x1b,0xd4,0x04,0x40]
-sraiw s0, s1, 0
-# CHECK-ASM-AND-OBJ: sraiw a0, a1, 31
-# CHECK-ASM: encoding: [0x1b,0xd5,0xf5,0x41]
-sraiw a0, a1, 31
-
-# CHECK-ASM-AND-OBJ: addw a2, a3, a4
-# CHECK-ASM: encoding: [0x3b,0x86,0xe6,0x00]
-addw a2, a3, a4
-# CHECK-ASM-AND-OBJ: addw a5, a6, a7
-# CHECK-ASM: encoding: [0xbb,0x07,0x18,0x01]
-addw a5, a6, a7
-# CHECK-ASM-AND-OBJ: subw s2, s3, s4
-# CHECK-ASM: encoding: [0x3b,0x89,0x49,0x41]
-subw s2, s3, s4
-# CHECK-ASM-AND-OBJ: subw s5, s6, s7
-# CHECK-ASM: encoding: [0xbb,0x0a,0x7b,0x41]
-subw s5, s6, s7
-# CHECK-ASM-AND-OBJ: sllw s8, s9, s10
-# CHECK-ASM: encoding: [0x3b,0x9c,0xac,0x01]
-sllw s8, s9, s10
-# CHECK-ASM-AND-OBJ: srlw s11, t3, t4
-# CHECK-ASM: encoding: [0xbb,0x5d,0xde,0x01]
-srlw s11, t3, t4
-# CHECK-ASM-AND-OBJ: sraw t5, t6, zero
-# CHECK-ASM: encoding: [0x3b,0xdf,0x0f,0x40]
-sraw t5, t6, zero
diff --git a/test/MC/RISCV/rv64m-valid.s b/test/MC/RISCV/rv64m-valid.s
deleted file mode 100644
index f1a98bf8f11..00000000000
--- a/test/MC/RISCV/rv64m-valid.s
+++ /dev/null
@@ -1,21 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-ASM,CHECK-ASM-AND-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-ASM-AND-OBJ %s
-
-# CHECK-ASM-AND-OBJ: mulw ra, sp, gp
-# CHECK-ASM: encoding: [0xbb,0x00,0x31,0x02]
-mulw ra, sp, gp
-# CHECK-ASM-AND-OBJ: divw tp, t0, t1
-# CHECK-ASM: encoding: [0x3b,0xc2,0x62,0x02]
-divw tp, t0, t1
-# CHECK-ASM-AND-OBJ: divuw t2, s0, s2
-# CHECK-ASM: encoding: [0xbb,0x53,0x24,0x03]
-divuw t2, s0, s2
-# CHECK-ASM-AND-OBJ: remw a0, a1, a2
-# CHECK-ASM: encoding: [0x3b,0xe5,0xc5,0x02]
-remw a0, a1, a2
-# CHECK-ASM-AND-OBJ: remuw a3, a4, a5
-# CHECK-ASM: encoding: [0xbb,0x76,0xf7,0x02]
-remuw a3, a4, a5
diff --git a/test/MC/RISCV/rvd-aliases-valid.s b/test/MC/RISCV/rvd-aliases-valid.s
deleted file mode 100644
index 173d998b76a..00000000000
--- a/test/MC/RISCV/rvd-aliases-valid.s
+++ /dev/null
@@ -1,85 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-##===----------------------------------------------------------------------===##
-
-# TODO fld
-# TODO fsd
-
-# CHECK-INST: fsgnj.d ft0, ft1, ft1
-# CHECK-ALIAS: fmv.d ft0, ft1
-fmv.d f0, f1
-# CHECK-INST: fsgnjx.d ft1, ft2, ft2
-# CHECK-ALIAS: fabs.d ft1, ft2
-fabs.d f1, f2
-# CHECK-INST: fsgnjn.d ft2, ft3, ft3
-# CHECK-ALIAS: fneg.d ft2, ft3
-fneg.d f2, f3
-
-# CHECK-INST: flt.d tp, ft6, ft5
-# CHECK-ALIAS: flt.d tp, ft6, ft5
-fgt.d x4, f5, f6
-# CHECK-INST: fle.d t2, fs1, fs0
-# CHECK-ALIAS: fle.d t2, fs1, fs0
-fge.d x7, f8, f9
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fmadd.d fa0, fa1, fa2, fa3, dyn
-# CHECK-ALIAS: fmadd.d fa0, fa1, fa2, fa3{{[[:space:]]}}
-fmadd.d f10, f11, f12, f13
-# CHECK-INST: fmsub.d fa4, fa5, fa6, fa7, dyn
-# CHECK-ALIAS: fmsub.d fa4, fa5, fa6, fa7{{[[:space:]]}}
-fmsub.d f14, f15, f16, f17
-# CHECK-INST: fnmsub.d fs2, fs3, fs4, fs5, dyn
-# CHECK-ALIAS: fnmsub.d fs2, fs3, fs4, fs5{{[[:space:]]}}
-fnmsub.d f18, f19, f20, f21
-# CHECK-INST: fnmadd.d fs6, fs7, fs8, fs9, dyn
-# CHECK-ALIAS: fnmadd.d fs6, fs7, fs8, fs9{{[[:space:]]}}
-fnmadd.d f22, f23, f24, f25
-# CHECK-INST: fadd.d fs10, fs11, ft8, dyn
-# CHECK-ALIAS: fadd.d fs10, fs11, ft8{{[[:space:]]}}
-fadd.d f26, f27, f28
-# CHECK-INST: fsub.d ft9, ft10, ft11, dyn
-# CHECK-ALIAS: fsub.d ft9, ft10, ft11{{[[:space:]]}}
-fsub.d f29, f30, f31
-# CHECK-INST: fmul.d ft0, ft1, ft2, dyn
-# CHECK-ALIAS: fmul.d ft0, ft1, ft2{{[[:space:]]}}
-fmul.d ft0, ft1, ft2
-# CHECK-INST: fdiv.d ft3, ft4, ft5, dyn
-# CHECK-ALIAS: fdiv.d ft3, ft4, ft5{{[[:space:]]}}
-fdiv.d ft3, ft4, ft5
-# CHECK-INST: fsqrt.d ft6, ft7, dyn
-# CHECK-ALIAS: fsqrt.d ft6, ft7{{[[:space:]]}}
-fsqrt.d ft6, ft7
-# CHECK-INST: fcvt.s.d fs5, fs6, dyn
-# CHECK-ALIAS: fcvt.s.d fs5, fs6{{[[:space:]]}}
-fcvt.s.d fs5, fs6
-# CHECK-INST: fcvt.w.d a4, ft11, dyn
-# CHECK-ALIAS: fcvt.w.d a4, ft11{{[[:space:]]}}
-fcvt.w.d a4, ft11
-# CHECK-INST: fcvt.wu.d a5, ft10, dyn
-# CHECK-ALIAS: fcvt.wu.d a5, ft10{{[[:space:]]}}
-fcvt.wu.d a5, ft10
diff --git a/test/MC/RISCV/rvf-aliases-valid.s b/test/MC/RISCV/rvf-aliases-valid.s
deleted file mode 100644
index 3307b9e03b4..00000000000
--- a/test/MC/RISCV/rvf-aliases-valid.s
+++ /dev/null
@@ -1,139 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-##===----------------------------------------------------------------------===##
-
-# TODO flw
-# TODO fsw
-
-# CHECK-INST: fsgnj.s ft0, ft1, ft1
-# CHECK-ALIAS: fmv.s ft0, ft1
-fmv.s f0, f1
-# CHECK-INST: fsgnjx.s ft1, ft2, ft2
-# CHECK-ALIAS: fabs.s ft1, ft2
-fabs.s f1, f2
-# CHECK-INST: fsgnjn.s ft2, ft3, ft3
-# CHECK-ALIAS: fneg.s ft2, ft3
-fneg.s f2, f3
-
-# CHECK-INST: flt.s tp, ft6, ft5
-# CHECK-ALIAS: flt.s tp, ft6, ft5
-fgt.s x4, f5, f6
-# CHECK-INST: fle.s t2, fs1, fs0
-# CHECK-ALIAS: fle.s t2, fs1, fs0
-fge.s x7, f8, f9
-
-# The following instructions actually alias instructions from the base ISA.
-# However, it only makes sense to support them when the F extension is enabled.
-# CHECK-INST: csrrs t0, fcsr, zero
-# CHECK-ALIAS: frcsr t0
-frcsr x5
-# CHECK-INST: csrrw t1, fcsr, t2
-# CHECK-ALIAS: fscsr t1, t2
-fscsr x6, x7
-# CHECK-INST: csrrw  zero, fcsr, t3
-# CHECK-ALIAS: fscsr t3
-fscsr x28
-
-# CHECK-INST: csrrs t4, frm, zero
-# CHECK-ALIAS: frrm t4
-frrm x29
-# CHECK-INST: csrrw  t5, frm, t4
-# CHECK-ALIAS: fsrm t5, t4
-fsrm x30, x29
-# CHECK-INST: csrrw  zero, frm, t6
-# CHECK-ALIAS: fsrm t6
-fsrm x31
-# CHECK-INST: csrrwi a0, frm, 31
-# CHECK-ALIAS: fsrmi a0, 31
-fsrmi x10, 0x1f
-# CHECK-INST: csrrwi  zero, frm, 30
-# CHECK-ALIAS: fsrmi 30
-fsrmi 0x1e
-
-# CHECK-INST: csrrs a1, fflags, zero
-# CHECK-ALIAS: frflags a1
-frflags x11
-# CHECK-INST: csrrw a2, fflags, a1
-# CHECK-ALIAS: fsflags a2, a1
-fsflags x12, x11
-# CHECK-INST: csrrw zero, fflags, a3
-# CHECK-ALIAS: fsflags a3
-fsflags x13
-# CHECK-INST: csrrwi a4, fflags, 29
-# CHECK-ALIAS: fsflagsi a4, 29
-fsflagsi x14, 0x1d
-# CHECK-INST: csrrwi zero, fflags, 28
-# CHECK-ALIAS: fsflagsi 28
-fsflagsi 0x1c
-
-# CHECK-INST: fmv.x.w a2, fs7
-# CHECK-ALIAS: fmv.x.w a2, fs7
-fmv.x.s a2, fs7
-# CHECK-INST: fmv.w.x ft1, a6
-# CHECK-ALIAS: fmv.w.x ft1, a6
-fmv.s.x ft1, a6
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fmadd.s fa0, fa1, fa2, fa3, dyn
-# CHECK-ALIAS: fmadd.s fa0, fa1, fa2, fa3{{[[:space:]]}}
-fmadd.s f10, f11, f12, f13
-# CHECK-INST: fmsub.s fa4, fa5, fa6, fa7, dyn
-# CHECK-ALIAS: fmsub.s fa4, fa5, fa6, fa7{{[[:space:]]}}
-fmsub.s f14, f15, f16, f17
-# CHECK-INST: fnmsub.s fs2, fs3, fs4, fs5, dyn
-# CHECK-ALIAS: fnmsub.s fs2, fs3, fs4, fs5{{[[:space:]]}}
-fnmsub.s f18, f19, f20, f21
-# CHECK-INST: fnmadd.s fs6, fs7, fs8, fs9, dyn
-# CHECK-ALIAS: fnmadd.s fs6, fs7, fs8, fs9{{[[:space:]]}}
-fnmadd.s f22, f23, f24, f25
-# CHECK-INST: fadd.s fs10, fs11, ft8, dyn
-# CHECK-ALIAS: fadd.s fs10, fs11, ft8{{[[:space:]]}}
-fadd.s f26, f27, f28
-# CHECK-INST: fsub.s ft9, ft10, ft11, dyn
-# CHECK-ALIAS: fsub.s ft9, ft10, ft11{{[[:space:]]}}
-fsub.s f29, f30, f31
-# CHECK-INST: fmul.s ft0, ft1, ft2, dyn
-# CHECK-ALIAS: fmul.s ft0, ft1, ft2{{[[:space:]]}}
-fmul.s ft0, ft1, ft2
-# CHECK-INST: fdiv.s ft3, ft4, ft5, dyn
-# CHECK-ALIAS: fdiv.s ft3, ft4, ft5{{[[:space:]]}}
-fdiv.s ft3, ft4, ft5
-# CHECK-INST: fsqrt.s ft6, ft7, dyn
-# CHECK-ALIAS: fsqrt.s ft6, ft7{{[[:space:]]}}
-fsqrt.s ft6, ft7
-# CHECK-INST: fcvt.w.s a0, fs5, dyn
-# CHECK-ALIAS: fcvt.w.s a0, fs5{{[[:space:]]}}
-fcvt.w.s a0, fs5
-# CHECK-INST: fcvt.wu.s a1, fs6, dyn
-# CHECK-ALIAS: fcvt.wu.s a1, fs6{{[[:space:]]}}
-fcvt.wu.s a1, fs6
-# CHECK-INST: fcvt.s.w ft11, a4, dyn
-# CHECK-ALIAS: fcvt.s.w ft11, a4{{[[:space:]]}}
-fcvt.s.w ft11, a4
-# CHECK-INST: fcvt.s.wu ft0, a5, dyn
-# CHECK-ALIAS: fcvt.s.wu ft0, a5{{[[:space:]]}}
-fcvt.s.wu ft0, a5
diff --git a/test/MC/RISCV/rvf-user-csr-names.s b/test/MC/RISCV/rvf-user-csr-names.s
deleted file mode 100644
index 89e7a161e58..00000000000
--- a/test/MC/RISCV/rvf-user-csr-names.s
+++ /dev/null
@@ -1,71 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -mattr=+f -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS-NO-F %s
-#
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -mattr=+f -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS-NO-F %s
-
-##################################
-# User Floating Pont CSRs
-##################################
-
-# fflags
-# name
-# CHECK-INST: csrrs t1, fflags, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0x00]
-# CHECK-INST-ALIAS: frflags t1
-# CHECK-INST-ALIAS-NO-F: csrr t1, 1
-# uimm12
-# CHECK-INST: csrrs t2, fflags, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0x00]
-# CHECK-INST-ALIAS: frflags t2
-# CHECK-INST-ALIAS-NO-F: csrr t2, 1
-# name
-csrrs t1, fflags, zero
-# uimm12
-csrrs t2, 0x001, zero
-
-# frm
-# name
-# CHECK-INST: csrrs t1, frm, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0x00]
-# CHECK-INST-ALIAS: frrm t1
-# CHECK-INST-ALIAS-NO-F: csrr t1, 2
-# uimm12
-# CHECK-INST: csrrs t2, frm, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0x00]
-# CHECK-INST-ALIAS: frrm t2
-# CHECK-INST-ALIAS-NO-F: csrr t2, 2
-# name
-csrrs t1, frm, zero
-# uimm12
-csrrs t2, 0x002, zero
-
-# fcsr
-# name
-# CHECK-INST: csrrs t1, fcsr, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0x00]
-# CHECK-INST-ALIAS: frcsr t1
-# CHECK-INST-ALIAS-NO-F: csrr t1, 3
-# uimm12
-# CHECK-INST: csrrs t2, fcsr, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0x00]
-# CHECK-INST-ALIAS: frcsr t2
-# CHECK-INST-ALIAS-NO-F: csrr t2, 3
-# name
-csrrs t1, fcsr, zero
-# uimm12
-csrrs t2, 0x003, zero
-
-
diff --git a/test/MC/RISCV/rvi-aliases-valid.s b/test/MC/RISCV/rvi-aliases-valid.s
deleted file mode 100644
index a4aef05f8be..00000000000
--- a/test/MC/RISCV/rvi-aliases-valid.s
+++ /dev/null
@@ -1,247 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefixes=CHECK-S-NOALIAS,CHECK-S-OBJ-NOALIAS %s
-# RUN: llvm-mc %s -triple=riscv32 \
-# RUN:     | FileCheck -check-prefixes=CHECK-S,CHECK-S-OBJ %s
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases\
-# RUN:     | FileCheck -check-prefixes=CHECK-S-NOALIAS,CHECK-S-OBJ-NOALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 \
-# RUN:     | FileCheck -check-prefixes=CHECK-S,CHECK-S-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d -r -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ-NOALIAS,CHECK-S-OBJ-NOALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-S-OBJ %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d -r -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ-NOALIAS,CHECK-S-OBJ-NOALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d -r - \
-# RUN:     | FileCheck -check-prefixes=CHECK-OBJ,CHECK-S-OBJ %s
-
-# The following check prefixes are used in this test:
-# CHECK-S                 Match the .s output with aliases enabled
-# CHECK-S-NOALIAS         Match the .s output with aliases disabled
-# CHECK-OBJ               Match the objdumped object output with aliases enabled
-# CHECK-OBJ-NOALIAS       Match the objdumped object output with aliases enabled
-# CHECK-S-OBJ             Match both the .s and objdumped object output with
-#                         aliases enabled
-# CHECK-S-OBJ-NOALIAS     Match both the .s and objdumped object output with
-#                         aliases disabled
-
-# TODO la
-# TODO lb lh lw
-# TODO sb sh sw
-
-# CHECK-S-OBJ-NOALIAS: addi zero, zero, 0
-# CHECK-S-OBJ: nop
-nop
-
-# CHECK-S-OBJ-NOALIAS: addi t6, zero, 0
-# CHECK-S-OBJ: mv t6, zero
-mv x31, zero
-# CHECK-S-OBJ-NOALIAS: addi a2, a3, 0
-# CHECK-S-OBJ: mv a2, a3
-move a2,a3
-# CHECK-S-OBJ-NOALIAS: xori t6, ra, -1
-# CHECK-S-OBJ: not t6, ra
-not x31, x1
-# CHECK-S-OBJ-NOALIAS: sub t6, zero, ra
-# CHECK-S-OBJ: neg t6, ra
-neg x31, x1
-# CHECK-S-OBJ-NOALIAS: sltiu t6, ra, 1
-# CHECK-S-OBJ: seqz t6, ra
-seqz x31, x1
-# CHECK-S-OBJ-NOALIAS: sltu t6, zero, ra
-# CHECK-S-OBJ: snez t6, ra
-snez x31, x1
-# CHECK-S-OBJ-NOALIAS: slt t6, ra, zero
-# CHECK-S-OBJ: sltz t6, ra
-sltz x31, x1
-# CHECK-S-OBJ-NOALIAS: slt t6, zero, ra
-# CHECK-S-OBJ: sgtz t6, ra
-sgtz x31, x1
-
-# CHECK-S-OBJ-NOALIAS: slt ra, gp, sp
-# CHECK-S-OBJ: slt ra, gp, sp
-sgt x1, x2, x3
-# CHECK-S-OBJ-NOALIAS: sltu tp, t1, t0
-# CHECK-S-OBJ: sltu tp, t1, t0
-sgtu x4, x5, x6
-
-# CHECK-S-OBJ-NOALIAS: beq a0, zero, 512
-# CHECK-S-OBJ: beqz a0, 512
-beqz x10, 512
-# CHECK-S-OBJ-NOALIAS: bne a1, zero, 1024
-# CHECK-S-OBJ: bnez a1, 1024
-bnez x11, 1024
-# CHECK-S-OBJ-NOALIAS: bge zero, a2, 4
-# CHECK-S-OBJ: blez a2, 4
-blez x12, 4
-# CHECK-S-OBJ-NOALIAS: bge a3, zero, 8
-# CHECK-S-OBJ: bgez a3, 8
-bgez x13, 8
-# CHECK-S-OBJ-NOALIAS: blt a4, zero, 12
-# CHECK-S-OBJ: bltz a4, 12
-bltz x14, 12
-# CHECK-S-OBJ-NOALIAS: blt zero, a5, 16
-# CHECK-S-OBJ: bgtz a5, 16
-bgtz x15, 16
-
-# Always output the canonical mnemonic for the pseudo branch instructions.
-# CHECK-S-OBJ-NOALIAS: blt a6, a5, 20
-# CHECK-S-OBJ: blt a6, a5, 20
-bgt x15, x16, 20
-# CHECK-S-OBJ-NOALIAS: bge a7, a6, 24
-# CHECK-S-OBJ: bge a7, a6, 24
-ble x16, x17, 24
-# CHECK-S-OBJ-NOALIAS: bltu s2, a7, 28
-# CHECK-S-OBJ: bltu s2, a7, 28
-bgtu x17, x18, 28
-# CHECK-S-OBJ-NOALIAS: bgeu s3, s2, 32
-# CHECK-S-OBJ: bgeu s3, s2, 32
-bleu x18, x19, 32
-
-# CHECK-S-OBJ-NOALIAS: jal zero, 2044
-# CHECK-S-OBJ: j 2044
-j 2044
-# CHECK-S-NOALIAS: jal zero, foo
-# CHECK-S: j foo
-# CHECK-OBJ-NOALIAS: jal zero, 0
-# CHECK-OBJ: j 0
-# CHECK-OBJ: R_RISCV_JAL foo
-j foo
-# CHECK-S-NOALIAS: jal zero, a0
-# CHECK-S: j a0
-# CHECK-OBJ-NOALIAS: jal zero, 0
-# CHECK-OBJ: j 0
-# CHECK-OBJ: R_RISCV_JAL a0
-j a0
-# CHECK-S-OBJ-NOALIAS: jal ra, 2040
-# CHECK-S-OBJ: jal 2040
-jal 2040
-# CHECK-S-NOALIAS: jal ra, foo
-# CHECK-S: jal foo
-# CHECK-OBJ-NOALIAS: jal ra, 0
-# CHECK-OBJ: jal 0
-# CHECK-OBJ: R_RISCV_JAL foo
-jal foo
-# CHECK-S-NOALIAS: jal ra, a0
-# CHECK-S: jal a0
-# CHECK-OBJ-NOALIAS: jal ra, 0
-# CHECK-OBJ: jal 0
-# CHECK-OBJ: R_RISCV_JAL a0
-jal a0
-# CHECK-S-OBJ-NOALIAS: jalr zero, s4, 0
-# CHECK-S-OBJ: jr s4
-jr x20
-# CHECK-S-OBJ-NOALIAS: jalr ra, s5, 0
-# CHECK-S-OBJ: jalr s5
-jalr x21
-# CHECK-S-OBJ-NOALIAS: jalr zero, ra, 0
-# CHECK-S-OBJ: ret
-ret
-# TODO call
-# TODO tail
-
-# CHECK-S-OBJ-NOALIAS: fence iorw, iorw
-# CHECK-S-OBJ: fence
-fence
-
-# CHECK-S-OBJ-NOALIAS: csrrs s10, instret, zero
-# CHECK-S-OBJ: rdinstret s10
-rdinstret x26
-# CHECK-S-OBJ-NOALIAS: csrrs s8, cycle, zero
-# CHECK-S-OBJ: rdcycle s8
-rdcycle x24
-# CHECK-S-OBJ-NOALIAS: csrrs s9, time, zero
-# CHECK-S-OBJ: rdtime s9
-rdtime x25
-
-# CHECK-S-OBJ-NOALIAS: csrrs  s0, 336, zero
-# CHECK-S-OBJ: csrr s0, 336
-csrr x8, 0x150
-# CHECK-S-OBJ-NOALIAS: csrrw zero, sscratch, s1
-# CHECK-S-OBJ: csrw sscratch, s1
-csrw 0x140, x9
-# CHECK-S-OBJ-NOALIAS: csrrs zero, 4095, s6
-# CHECK-S-OBJ: csrs 4095, s6
-csrs 0xfff, x22
-# CHECK-S-OBJ-NOALIAS: csrrc zero, 4095, s7
-# CHECK-S-OBJ: csrc 4095, s7
-csrc 0xfff, x23
-
-# CHECK-S-OBJ-NOALIAS: csrrwi zero, 336, 15
-# CHECK-S-OBJ: csrwi 336, 15
-csrwi 0x150, 0xf
-# CHECK-S-OBJ-NOALIAS: csrrsi zero, 4095, 16
-# CHECK-S-OBJ: csrsi 4095, 16
-csrsi 0xfff, 0x10
-# CHECK-S-OBJ-NOALIAS: csrrci zero, sscratch, 17
-# CHECK-S-OBJ: csrci sscratch, 17
-csrci 0x140, 0x11
-
-# CHECK-S-OBJ-NOALIAS: csrrwi zero, 336, 7
-# CHECK-S-OBJ: csrwi 336, 7
-csrw 0x150, 7
-# CHECK-S-OBJ-NOALIAS: csrrsi zero, 336, 7
-# CHECK-S-OBJ: csrsi 336, 7
-csrs 0x150, 7
-# CHECK-S-OBJ-NOALIAS: csrrci zero, 336, 7
-# CHECK-S-OBJ: csrci 336, 7
-csrc 0x150, 7
-
-# CHECK-S-OBJ-NOALIAS: csrrwi t0, 336, 15
-# CHECK-S-OBJ: csrrwi t0, 336, 15
-csrrw t0, 0x150, 0xf
-# CHECK-S-OBJ-NOALIAS: csrrsi t0, 4095, 16
-# CHECK-S-OBJ: csrrsi t0, 4095, 16
-csrrs t0, 0xfff, 0x10
-# CHECK-S-OBJ-NOALIAS: csrrci t0, sscratch, 17
-# CHECK-S-OBJ: csrrci t0, sscratch, 17
-csrrc t0, 0x140, 0x11
-
-# CHECK-S-OBJ-NOALIAS: sfence.vma zero, zero
-# CHECK-S-OBJ: sfence.vma
-sfence.vma
-# CHECK-S-OBJ-NOALIAS: sfence.vma a0, zero
-# CHECK-S-OBJ: sfence.vma a0
-sfence.vma a0
-
-# The following aliases are accepted as input but the canonical form
-# of the instruction will always be printed.
-# CHECK-S-OBJ-NOALIAS: addi a2, a3, 4
-# CHECK-S-OBJ: addi a2, a3, 4
-add a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: andi a2, a3, 4
-# CHECK-S-OBJ: andi a2, a3, 4
-and a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: xori a2, a3, 4
-# CHECK-S-OBJ: xori a2, a3, 4
-xor a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: ori a2, a3, 4
-# CHECK-S-OBJ: ori a2, a3, 4
-or a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: slli a2, a3, 4
-# CHECK-S-OBJ: slli a2, a3, 4
-sll a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: srli a2, a3, 4
-# CHECK-S-OBJ: srli a2, a3, 4
-srl a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: srai a2, a3, 4
-# CHECK-S-OBJ: srai a2, a3, 4
-sra a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: slti a2, a3, 4
-# CHECK-S-OBJ: slti a2, a3, 4
-slt a2, a3, 4
-# CHECK-S-OBJ-NOALIAS: sltiu a2, a3, 4
-# CHECK-S-OBJ: sltiu a2, a3, 4
-sltu a2, a3, 4
-
-# CHECK-S-OBJ-NOALIAS: ebreak
-# CHECK-S-OBJ: ebreak
-sbreak
-
-# CHECK-S-OBJ-NOALIAS: ecall
-# CHECK-S-OBJ: ecall
-scall
diff --git a/test/MC/RISCV/rvi-pseudos.s b/test/MC/RISCV/rvi-pseudos.s
deleted file mode 100644
index b93e6f79ef6..00000000000
--- a/test/MC/RISCV/rvi-pseudos.s
+++ /dev/null
@@ -1,28 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 | FileCheck %s
-# RUN: llvm-mc %s -triple=riscv64 | FileCheck %s
-
-# CHECK: .Lpcrel_hi0:
-# CHECK: auipc a0, %pcrel_hi(a_symbol)
-# CHECK: addi  a0, a0, %pcrel_lo(.Lpcrel_hi0)
-lla a0, a_symbol
-
-# CHECK: .Lpcrel_hi1:
-# CHECK: auipc a1, %pcrel_hi(another_symbol)
-# CHECK: addi  a1, a1, %pcrel_lo(.Lpcrel_hi1)
-lla a1, another_symbol
-
-# Check that we can load the address of symbols that are spelled like a register
-# CHECK: .Lpcrel_hi2:
-# CHECK: auipc a2, %pcrel_hi(zero)
-# CHECK: addi  a2, a2, %pcrel_lo(.Lpcrel_hi2)
-lla a2, zero
-
-# CHECK: .Lpcrel_hi3:
-# CHECK: auipc a3, %pcrel_hi(ra)
-# CHECK: addi  a3, a3, %pcrel_lo(.Lpcrel_hi3)
-lla a3, ra
-
-# CHECK: .Lpcrel_hi4:
-# CHECK: auipc a4, %pcrel_hi(f1)
-# CHECK: addi  a4, a4, %pcrel_lo(.Lpcrel_hi4)
-lla a4, f1
diff --git a/test/MC/RISCV/supervisor-csr-names.s b/test/MC/RISCV/supervisor-csr-names.s
deleted file mode 100644
index fa6dc6abff3..00000000000
--- a/test/MC/RISCV/supervisor-csr-names.s
+++ /dev/null
@@ -1,193 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-#
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-##################################
-# Supervisor Trap Setup
-##################################
-
-# sstatus
-# name
-# CHECK-INST: csrrs t1, sstatus, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x10]
-# CHECK-INST-ALIAS: csrr t1, sstatus
-# uimm12
-# CHECK-INST: csrrs t2, sstatus, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x10]
-# CHECK-INST-ALIAS: csrr t2, sstatus
-# name
-csrrs t1, sstatus, zero
-# uimm12
-csrrs t2, 0x100, zero
-
-# sedeleg
-# name
-# CHECK-INST: csrrs t1, sedeleg, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x10]
-# CHECK-INST-ALIAS: csrr t1, sedeleg
-# uimm12
-# CHECK-INST: csrrs t2, sedeleg, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x10]
-# CHECK-INST-ALIAS: csrr t2, sedeleg
-# name
-csrrs t1, sedeleg, zero
-# uimm12
-csrrs t2, 0x102, zero
-
-# sideleg
-# name
-# CHECK-INST: csrrs t1, sideleg, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x10]
-# CHECK-INST-ALIAS: csrr t1, sideleg
-# uimm12
-# CHECK-INST: csrrs t2, sideleg, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x10]
-# CHECK-INST-ALIAS: csrr t2, sideleg
-# name
-csrrs t1, sideleg, zero
-# uimm12
-csrrs t2, 0x103, zero
-
-# sie
-# name
-# CHECK-INST: csrrs t1, sie, zero
-# CHECK-ENC: [0x73,0x23,0x40,0x10]
-# CHECK-INST-ALIAS: csrr t1, sie
-# uimm12
-# CHECK-INST: csrrs t2, sie, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x10]
-# CHECK-INST-ALIAS: csrr t2, sie
-# name
-csrrs t1, sie, zero
-# uimm12
-csrrs t2, 0x104, zero
-
-# stvec
-# name
-# CHECK-INST: csrrs t1, stvec, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x50,0x10]
-# CHECK-INST-ALIAS: csrr t1, stvec
-# uimm12
-# CHECK-INST: csrrs t2, stvec, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x50,0x10]
-# CHECK-INST-ALIAS: csrr t2, stvec
-# name
-csrrs t1, stvec, zero
-# uimm12
-csrrs t2, 0x105, zero
-
-# scounteren
-# name
-# CHECK-INST: csrrs t1, scounteren, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x60,0x10]
-# CHECK-INST-ALIAS: csrr t1, scounteren
-# uimm12
-# CHECK-INST: csrrs t2, scounteren, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x60,0x10]
-# CHECK-INST-ALIAS: csrr t2, scounteren
-# name
-csrrs t1, scounteren, zero
-# uimm12
-csrrs t2, 0x106, zero
-
-##################################
-# Supervisor Trap Handling
-##################################
-
-# sscratch
-# name
-# CHECK-INST: csrrs t1, sscratch, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x14]
-# CHECK-INST-ALIAS: csrr t1, sscratch
-# uimm12
-# CHECK-INST: csrrs t2, sscratch, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x14]
-# CHECK-INST-ALIAS: csrr t2, sscratch
-# name
-csrrs t1, sscratch, zero
-# uimm12
-csrrs t2, 0x140, zero
-
-# sepc
-# name
-# CHECK-INST: csrrs t1, sepc, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x10,0x14]
-# CHECK-INST-ALIAS: csrr t1, sepc
-# uimm12
-# CHECK-INST: csrrs t2, sepc, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x14]
-# CHECK-INST-ALIAS: csrr t2, sepc
-# name
-csrrs t1, sepc, zero
-# uimm12
-csrrs t2, 0x141, zero
-
-# scause
-# name
-# CHECK-INST: csrrs t1, scause, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x20,0x14]
-# CHECK-INST-ALIAS: csrr t1, scause
-# uimm12
-# CHECK-INST: csrrs t2, scause, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x14]
-# CHECK-INST-ALIAS: csrr t2, scause
-# name
-csrrs t1, scause, zero
-# uimm12
-csrrs t2, 0x142, zero
-
-# stval
-# name
-# CHECK-INST: csrrs t1, stval, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x30,0x14]
-# CHECK-INST-ALIAS: csrr t1, stval
-# uimm12
-# CHECK-INST: csrrs t2, stval, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x14]
-# CHECK-INST-ALIAS: csrr t2, stval
-# aliases
-# aliases with uimm12
-# name
-csrrs t1, stval, zero
-# uimm12
-csrrs t2, 0x143, zero
-
-# sip
-# name
-# CHECK-INST: csrrs t1, sip, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x40,0x14]
-# CHECK-INST-ALIAS: csrr t1, sip
-# uimm12
-# CHECK-INST: csrrs t2, sip, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x14]
-# CHECK-INST-ALIAS: csrr t2, sip
-csrrs t1, sip, zero
-# uimm12
-csrrs t2, 0x144, zero
-
-
-#########################################
-# Supervisor Protection and Translation
-#########################################
-
-# satp
-# name
-# CHECK-INST: csrrs t1, satp, zero
-# CHECK-ENC: encoding: [0x73,0x23,0x00,0x18]
-# CHECK-INST-ALIAS: csrr t1, satp
-# uimm12
-# CHECK-INST: csrrs t2, satp, zero
-# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x18]
-# CHECK-INST-ALIAS: csrr t2, satp
-# name
-csrrs t1, satp, zero
-# uimm12
-csrrs t2, 0x180, zero
diff --git a/test/MC/RISCV/tail-call-invalid.s b/test/MC/RISCV/tail-call-invalid.s
deleted file mode 100644
index 270d84df58a..00000000000
--- a/test/MC/RISCV/tail-call-invalid.s
+++ /dev/null
@@ -1,12 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 | FileCheck %s
-
-tail 1234 # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %pcrel_hi(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %pcrel_lo(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %pcrel_hi(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %pcrel_lo(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %hi(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %lo(1234) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %hi(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
-tail %lo(foo) # CHECK: :[[@LINE]]:6: error: operand must be a bare symbol name
diff --git a/test/MC/RISCV/tail-call.s b/test/MC/RISCV/tail-call.s
deleted file mode 100644
index 9662e61d866..00000000000
--- a/test/MC/RISCV/tail-call.s
+++ /dev/null
@@ -1,47 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:   | llvm-objdump -d - | FileCheck -check-prefix=INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:   | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-# RUN: llvm-mc -triple riscv32 < %s -show-encoding \
-# RUN:   | FileCheck -check-prefix=FIXUP %s
-
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:   | llvm-objdump -d - | FileCheck -check-prefix=INSTR %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:   | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-# RUN: llvm-mc -triple riscv64 < %s -show-encoding \
-# RUN:   | FileCheck -check-prefix=FIXUP %s
-
-.long foo
-
-tail foo
-# RELOC: R_RISCV_CALL foo 0x0
-# INSTR: auipc t1, 0
-# INSTR: jr  t1
-# FIXUP: fixup A - offset: 0, value: foo, kind:
-tail bar
-# RELOC: R_RISCV_CALL bar 0x0
-# INSTR: auipc t1, 0
-# INSTR: jr  t1
-# FIXUP: fixup A - offset: 0, value: bar, kind:
-
-# Ensure that tail calls to functions whose names coincide with register names
-# work.
-
-tail zero
-# RELOC: R_RISCV_CALL zero 0x0
-# INSTR: auipc t1, 0
-# INSTR: jr  t1
-# FIXUP: fixup A - offset: 0, value: zero, kind:
-
-tail f1
-# RELOC: R_RISCV_CALL f1 0x0
-# INSTR: auipc t1, 0
-# INSTR: jr  t1
-# FIXUP: fixup A - offset: 0, value: f1, kind:
-
-tail ra
-# RELOC: R_RISCV_CALL ra 0x0
-# INSTR: auipc t1, 0
-# INSTR: jr  t1
-# FIXUP: fixup A - offset: 0, value: ra, kind:
diff --git a/test/MC/RISCV/user-csr-names-invalid.s b/test/MC/RISCV/user-csr-names-invalid.s
deleted file mode 100644
index d7d660b3d1f..00000000000
--- a/test/MC/RISCV/user-csr-names-invalid.s
+++ /dev/null
@@ -1,47 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 \
-# RUN:  | FileCheck -check-prefix=CHECK-NEED-F %s
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 \
-# RUN:  | FileCheck -check-prefixes=CHECK-NEED-RV32,CHECK-NEED-F %s
-
-# These user mode CSR register names are RV32 only.
-
-csrrs t1, cycleh, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, timeh, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, instreth, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-
-csrrs t1, hpmcounter3h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter4h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter5h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter6h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter7h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter8h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter9h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter10h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter11h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter12h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter13h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter14h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter15h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter16h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter17h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter18h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter19h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter20h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter21h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter22h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter23h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter24h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter25h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter26h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter27h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter28h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter29h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter30h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, hpmcounter31h, zero # CHECK-NEED-RV32: :[[@LINE]]:11: error: system register use requires an option to be enabled
-
-# These user mode CSR register names require F extension.
-
-csrrs t1, fflags, zero # CHECK-NEED-F: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, frm, zero # CHECK-NEED-F: :[[@LINE]]:11: error: system register use requires an option to be enabled
-csrrs t1, fcsr, zero # CHECK-NEED-F: :[[@LINE]]:11: error: system register use requires an option to be enabled
-
diff --git a/test/MC/RISCV/user-csr-names.s b/test/MC/RISCV/user-csr-names.s
deleted file mode 100644
index f2759d277ce..00000000000
--- a/test/MC/RISCV/user-csr-names.s
+++ /dev/null
@@ -1,587 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-#
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
-
-##################################
-# User Trap Setup
-##################################
-
-# ustatus
-# name
-# CHECK-INST: csrrs t1, ustatus, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0x00]
-# CHECK-INST-ALIAS: csrr t1, ustatus
-# uimm12
-# CHECK-INST: csrrs t2, ustatus, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0x00]
-# CHECK-INST-ALIAS: csrr t2, ustatus
-csrrs t1, ustatus, zero
-# uimm12
-csrrs t2, 0x000, zero
-
-# uie
-# name
-# CHECK-INST: csrrs t1, uie, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0x00]
-# CHECK-INST-ALIAS: csrr t1, uie
-# uimm12
-# CHECK-INST: csrrs t2, uie, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0x00]
-# CHECK-INST-ALIAS: csrr t2, uie
-# name
-csrrs t1, uie, zero
-# uimm12
-csrrs t2, 0x004, zero
-
-# utvec
-# name
-# CHECK-INST: csrrs t1, utvec, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0x00]
-# CHECK-INST-ALIAS: csrr t1, utvec
-# uimm12
-# CHECK-INST: csrrs t2, utvec, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0x00]
-# CHECK-INST-ALIAS: csrr t2, utvec
-# name
-csrrs t1, utvec, zero
-# uimm12
-csrrs t2, 0x005, zero
-
-##################################
-# User Trap Handling
-##################################
-
-# uscratch
-# name
-# CHECK-INST: csrrs t1, uscratch, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0x04]
-# CHECK-INST-ALIAS: csrr t1, uscratch
-# uimm12
-# CHECK-INST: csrrs t2, uscratch, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0x04]
-# CHECK-INST-ALIAS: csrr t2, uscratch
-# name
-csrrs t1, uscratch, zero
-# uimm12
-csrrs t2, 0x040, zero
-
-# uepc
-# name
-# CHECK-INST: csrrs t1, uepc, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0x04]
-# CHECK-INST-ALIAS: csrr t1, uepc
-# uimm12
-# CHECK-INST: csrrs t2, uepc, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0x04]
-# CHECK-INST-ALIAS: csrr t2, uepc
-# name
-csrrs t1, uepc, zero
-# uimm12
-csrrs t2, 0x041, zero
-
-# ucause
-# name
-# CHECK-INST: csrrs t1, ucause, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0x04]
-# CHECK-INST-ALIAS: csrr t1, ucause
-# uimm12
-# CHECK-INST: csrrs t2, ucause, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0x04]
-# CHECK-INST-ALIAS: csrr t2, ucause
-# name
-csrrs t1, ucause, zero
-# uimm12
-csrrs t2, 0x042, zero
-
-# utval
-# name
-# CHECK-INST: csrrs t1, utval, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0x04]
-# CHECK-INST-ALIAS: csrr t1, utval
-# uimm12
-# CHECK-INST: csrrs t2, utval, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0x04]
-# CHECK-INST-ALIAS: csrr t2, utval
-# name
-csrrs t1, utval, zero
-# uimm12
-csrrs t2, 0x043, zero
-
-# uip
-# name
-# CHECK-INST: csrrs t1, uip, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0x04]
-# CHECK-INST-ALIAS: csrr t1, uip
-# uimm12
-# CHECK-INST: csrrs t2, uip, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0x04]
-# CHECK-INST-ALIAS: csrr t2, uip
-#name
-csrrs t1, uip, zero
-# uimm12
-csrrs t2, 0x044, zero
-
-##################################
-# User Floating Pont CSRs
-##################################
-# Tests in rvf-user-mode-csr.s
-
-##################################
-# User Counter and Timers
-##################################
-
-# cycle
-# name
-# CHECK-INST: csrrs t1, cycle, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xc0]
-# CHECK-INST-ALIAS: rdcycle t1
-# uimm12
-# CHECK-INST: csrrs t2, cycle, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc0]
-# CHECK-INST-ALIAS: rdcycle t2
-# name
-csrrs t1, cycle, zero
-# uimm12
-csrrs t2, 0xC00, zero
-
-# time
-# name
-# CHECK-INST: csrrs t1, time, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xc0]
-# CHECK-INST-ALIAS: rdtime t1
-# uimm12
-# CHECK-INST: csrrs t2, time, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc0]
-# CHECK-INST-ALIAS: rdtime t2
-# name
-csrrs t1, time, zero
-# uimm12
-csrrs t2, 0xC01, zero
-
-# instret
-# name
-# CHECK-INST: csrrs t1, instret, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xc0]
-# CHECK-INST-ALIAS: rdinstret t1
-# uimm12
-# CHECK-INST: csrrs t2, instret, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc0]
-# CHECK-INST-ALIAS: rdinstret t2
-# name
-csrrs t1, instret, zero
-# uimm12
-csrrs t2, 0xC02, zero
-
-# hpmcounter3
-# name
-# CHECK-INST: csrrs t1, hpmcounter3, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter3
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter3, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter3
-# name
-csrrs t1, hpmcounter3, zero
-# uimm12
-csrrs t2, 0xC03, zero
-
-# hpmcounter4
-# name
-# CHECK-INST: csrrs t1, hpmcounter4, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter4
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter4, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter4
-# name
-csrrs t1, hpmcounter4, zero
-# uimm12
-csrrs t2, 0xC04, zero
-
-# hpmcounter5
-# name
-# CHECK-INST: csrrs t1, hpmcounter5, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter5
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter5, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter5
-# name
-csrrs t1, hpmcounter5, zero
-# uimm12
-csrrs t2, 0xC05, zero
-
-# hpmcounter6
-# name
-# CHECK-INST: csrrs t1, hpmcounter6, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter6
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter6, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter6
-# name
-csrrs t1, hpmcounter6, zero
-# uimm12
-csrrs t2, 0xC06, zero
-
-# hpmcounter7
-# name
-# CHECK-INST: csrrs t1, hpmcounter7, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter7
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter7, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter7
-# name
-csrrs t1, hpmcounter7, zero
-# uimm12
-csrrs t2, 0xC07, zero
-
-# hpmcounter8
-# name
-# CHECK-INST: csrrs t1, hpmcounter8, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter8
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter8, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter8
-# name
-csrrs t1, hpmcounter8, zero
-# uimm12
-csrrs t2, 0xC08, zero
-
-# hpmcounter9
-# name
-# CHECK-INST: csrrs t1, hpmcounter9, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter9
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter9, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter9
-# name
-csrrs t1, hpmcounter9, zero
-# uimm12
-csrrs t2, 0xC09, zero
-
-# hpmcounter10
-# name
-# CHECK-INST: csrrs t1, hpmcounter10, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter10
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter10, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter10
-# name
-csrrs t1, hpmcounter10, zero
-# uimm12
-csrrs t2, 0xC0A, zero
-
-# hpmcounter11
-# name
-# CHECK-INST: csrrs t1, hpmcounter11, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter11
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter11, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter11
-# name
-csrrs t1, hpmcounter11, zero
-# uimm12
-csrrs t2, 0xC0B, zero
-
-# hpmcounter12
-# name
-# CHECK-INST: csrrs t1, hpmcounter12, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter12
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter12, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter12
-# name
-csrrs t1, hpmcounter12, zero
-# uimm12
-csrrs t2, 0xC0C, zero
-
-# hpmcounter13
-# name
-# CHECK-INST: csrrs t1, hpmcounter13, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter13
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter13, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter13
-# name
-csrrs t1, hpmcounter13, zero
-# uimm12
-csrrs t2, 0xC0D, zero
-
-# hpmcounter14
-# name
-# CHECK-INST: csrrs t1, hpmcounter14, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter14
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter14, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter14
-# name
-csrrs t1, hpmcounter14, zero
-# uimm12
-csrrs t2, 0xC0E, zero
-
-# hpmcounter15
-# name
-# CHECK-INST: csrrs t1, hpmcounter15, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xc0]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter15
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter15, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc0]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter15
-# name
-csrrs t1, hpmcounter15, zero
-# uimm12
-csrrs t2, 0xC0F, zero
-
-# hpmcounter16
-# name
-# CHECK-INST: csrrs t1, hpmcounter16, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x00,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter16
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter16, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x00,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter16
-# name
-csrrs t1, hpmcounter16, zero
-# uimm12
-csrrs t2, 0xC10, zero
-
-# hpmcounter17
-# name
-# CHECK-INST: csrrs t1, hpmcounter17, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x10,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter17
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter17, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x10,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter17
-# name
-csrrs t1, hpmcounter17, zero
-# uimm12
-csrrs t2, 0xC11, zero
-
-# hpmcounter18
-# name
-# CHECK-INST: csrrs t1, hpmcounter18, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x20,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter18
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter18, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x20,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter18
-# name
-csrrs t1, hpmcounter18, zero
-# uimm12
-csrrs t2, 0xC12, zero
-
-# hpmcounter19
-# name
-# CHECK-INST: csrrs t1, hpmcounter19, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x30,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter19
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter19, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x30,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter19
-# name
-csrrs t1, hpmcounter19, zero
-# uimm12
-csrrs t2, 0xC13, zero
-
-# hpmcounter20
-# name
-# CHECK-INST: csrrs t1, hpmcounter20, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x40,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter20
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter20, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x40,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter20
-# name
-csrrs t1, hpmcounter20, zero
-# uimm12
-csrrs t2, 0xC14, zero
-
-# hpmcounter21
-# name
-# CHECK-INST: csrrs t1, hpmcounter21, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x50,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter21
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter21, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x50,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter21
-# name
-csrrs t1, hpmcounter21, zero
-# uimm12
-csrrs t2, 0xC15, zero
-
-# hpmcounter22
-# name
-# CHECK-INST: csrrs t1, hpmcounter22, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x60,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter22
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter22, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x60,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter22
-# name
-csrrs t1, hpmcounter22, zero
-# uimm12
-csrrs t2, 0xC16, zero
-
-# hpmcounter23
-# name
-# CHECK-INST: csrrs t1, hpmcounter23, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x70,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter23
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter23, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x70,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter23
-# name
-csrrs t1, hpmcounter23, zero
-# uimm12
-csrrs t2, 0xC17, zero
-
-# hpmcounter24
-# name
-# CHECK-INST: csrrs t1, hpmcounter24, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x80,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter24
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter24, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x80,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter24
-# name
-csrrs t1, hpmcounter24, zero
-# uimm12
-csrrs t2, 0xC18, zero
-
-# hpmcounter25
-# name
-# CHECK-INST: csrrs t1, hpmcounter25, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0x90,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter25
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter25, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0x90,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter25
-# name
-csrrs t1, hpmcounter25, zero
-# uimm12
-csrrs t2, 0xC19, zero
-
-# hpmcounter26
-# name
-# CHECK-INST: csrrs t1, hpmcounter26, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xa0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter26
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter26, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xa0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter26
-# name
-csrrs t1, hpmcounter26, zero
-# uimm12
-csrrs t2, 0xC1A, zero
-
-# hpmcounter27
-# name
-# CHECK-INST: csrrs t1, hpmcounter27, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xb0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter27
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter27, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xb0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter27
-# name
-csrrs t1, hpmcounter27, zero
-# uimm12
-csrrs t2, 0xC1B, zero
-
-# hpmcounter28
-# name
-# CHECK-INST: csrrs t1, hpmcounter28, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xc0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter28
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter28, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xc0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter28
-# name
-csrrs t1, hpmcounter28, zero
-# uimm12
-csrrs t2, 0xC1C, zero
-
-# hpmcounter29
-# name
-# CHECK-INST: csrrs t1, hpmcounter29, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xd0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter29
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter29, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xd0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter29
-# name
-csrrs t1, hpmcounter29, zero
-# uimm12
-csrrs t2, 0xC1D, zero
-
-# hpmcounter30
-# name
-# CHECK-INST: csrrs t1, hpmcounter30, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xe0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter30
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter30, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xe0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter30
-# name
-csrrs t1, hpmcounter30, zero
-# uimm12
-csrrs t2, 0xC1E, zero
-
-# hpmcounter31
-# name
-# CHECK-INST: csrrs t1, hpmcounter31, zero
-# CHECK-ENC:  encoding: [0x73,0x23,0xf0,0xc1]
-# CHECK-INST-ALIAS: csrr t1, hpmcounter31
-# uimm12
-# CHECK-INST: csrrs t2, hpmcounter31, zero
-# CHECK-ENC:  encoding: [0xf3,0x23,0xf0,0xc1]
-# CHECK-INST-ALIAS: csrr t2, hpmcounter31
-# name
-csrrs t1, hpmcounter31, zero
-# uimm12
-csrrs t2, 0xC1F, zero
diff --git a/test/Object/RISCV/elf-flags.yaml b/test/Object/RISCV/elf-flags.yaml
deleted file mode 100644
index ff8637f000a..00000000000
--- a/test/Object/RISCV/elf-flags.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
-# RUN: yaml2obj %s > %t
-# RUN: llvm-readobj -file-headers %t | FileCheck -check-prefix=OBJ %s
-# RUN: obj2yaml %t | FileCheck -check-prefix=YAML %s
-
-# OBJ: Flags [ (0xD)
-# OBJ-NEXT:   EF_RISCV_FLOAT_ABI_DOUBLE (0x4)
-# OBJ-NEXT:   EF_RISCV_RVC (0x1)
-# OBJ-NEXT:   EF_RISCV_RVE (0x8)
-# OBJ-NEXT: ]
-
-# YAML:      FileHeader:
-# YAML-NEXT:   Class:           ELFCLASS32
-# YAML-NEXT:   Data:            ELFDATA2LSB
-# YAML-NEXT:   Type:            ET_EXEC
-# YAML-NEXT:   Machine:         EM_RISCV
-# YAML-NEXT:   Flags:           [ EF_RISCV_RVC, EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_RVE ]
-
---- !ELF
-FileHeader:
-  Class:           ELFCLASS32
-  Data:            ELFDATA2LSB
-  Type:            ET_EXEC
-  Machine:         EM_RISCV
-  Flags:           [ EF_RISCV_RVC, EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_RVE ]
diff --git a/test/Object/RISCV/lit.local.cfg b/test/Object/RISCV/lit.local.cfg
deleted file mode 100644
index c63820126f8..00000000000
--- a/test/Object/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
diff --git a/test/Transforms/SimplifyCFG/RISCV/lit.local.cfg b/test/Transforms/SimplifyCFG/RISCV/lit.local.cfg
deleted file mode 100644
index 7aaeda5a5b3..00000000000
--- a/test/Transforms/SimplifyCFG/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,5 +0,0 @@
-config.suffixes = ['.ll']
-
-targets = set(config.root.targets_to_build.split())
-if not 'RISCV' in targets:
-    config.unsupported = True
diff --git a/test/Transforms/SimplifyCFG/RISCV/select-trunc-i64.ll b/test/Transforms/SimplifyCFG/RISCV/select-trunc-i64.ll
deleted file mode 100644
index e5272b2af86..00000000000
--- a/test/Transforms/SimplifyCFG/RISCV/select-trunc-i64.ll
+++ /dev/null
@@ -1,28 +0,0 @@
-;RUN: opt -S -simplifycfg -mtriple=riscv32 < %s | FileCheck %s
-
-; Test case taken from test/Transforms/SimplifyCFG/ARM/select-trunc-i64.ll.
-; A correct implementation of isTruncateFree allows this test case to be
-; reduced to a single basic block.
-
-; CHECK-LABEL: select_trunc_i64
-; CHECK-NOT: br
-; CHECK: select
-; CHECK: select
-define i32 @select_trunc_i64(i32 %a, i32 %b) {
-entry:
-  %conv = sext i32 %a to i64
-  %conv1 = sext i32 %b to i64
-  %add = add nsw i64 %conv1, %conv
-  %cmp = icmp sgt i64 %add, 2147483647
-  br i1 %cmp, label %cond.end7, label %cond.false
-
-cond.false:                                       ; preds = %entry
-  %0 = icmp sgt i64 %add, -2147483648
-  %cond = select i1 %0, i64 %add, i64 -2147483648
-  %extract.t = trunc i64 %cond to i32
-  br label %cond.end7
-
-cond.end7:                                        ; preds = %cond.false, %entry
-  %cond8.off0 = phi i32 [ 2147483647, %entry ], [ %extract.t, %cond.false ]
-  ret i32 %cond8.off0
-}
diff --git a/tools/llvm-readobj/ELFDumper.cpp b/tools/llvm-readobj/ELFDumper.cpp
index 6b69f7e844e..54e82c01ca3 100644
--- a/tools/llvm-readobj/ELFDumper.cpp
+++ b/tools/llvm-readobj/ELFDumper.cpp
@@ -1084,7 +1084,6 @@ static const EnumEntry<unsigned> ElfMachineType[] = {
   ENUM_ENT(EM_78KOR,         "EM_78KOR"),
   ENUM_ENT(EM_56800EX,       "EM_56800EX"),
   ENUM_ENT(EM_AMDGPU,        "EM_AMDGPU"),
-  ENUM_ENT(EM_RISCV,         "RISC-V"),
   ENUM_ENT(EM_LANAI,         "EM_LANAI"),
   ENUM_ENT(EM_BPF,           "EM_BPF"),
 };
@@ -1371,14 +1370,6 @@ static const EnumEntry<unsigned> ElfHeaderAMDGPUFlags[] = {
   LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_SRAM_ECC)
 };
 
-static const EnumEntry<unsigned> ElfHeaderRISCVFlags[] = {
-  ENUM_ENT(EF_RISCV_RVC, "RVC"),
-  ENUM_ENT(EF_RISCV_FLOAT_ABI_SINGLE, "single-float ABI"),
-  ENUM_ENT(EF_RISCV_FLOAT_ABI_DOUBLE, "double-float ABI"),
-  ENUM_ENT(EF_RISCV_FLOAT_ABI_QUAD, "quad-float ABI"),
-  ENUM_ENT(EF_RISCV_RVE, "RVE")
-};
-
 static const EnumEntry<unsigned> ElfSymOtherFlags[] = {
   LLVM_READOBJ_ENUM_ENT(ELF, STV_INTERNAL),
   LLVM_READOBJ_ENUM_ENT(ELF, STV_HIDDEN),
@@ -2569,8 +2560,6 @@ template <class ELFT> void GNUStyle<ELFT>::printFileHeaders(const ELFO *Obj) {
         printFlags(e->e_flags, makeArrayRef(ElfHeaderMipsFlags),
                    unsigned(ELF::EF_MIPS_ARCH), unsigned(ELF::EF_MIPS_ABI),
                    unsigned(ELF::EF_MIPS_MACH));
-  else if (e->e_machine == EM_RISCV)
-    ElfFlags = printFlags(e->e_flags, makeArrayRef(ElfHeaderRISCVFlags));
   Str = "0x" + to_hexString(e->e_flags);
   if (!ElfFlags.empty())
     Str = Str + ", " + ElfFlags;
@@ -4129,8 +4118,6 @@ template <class ELFT> void LLVMStyle<ELFT>::printFileHeaders(const ELFO *Obj) {
     else if (e->e_machine == EM_AMDGPU)
       W.printFlags("Flags", e->e_flags, makeArrayRef(ElfHeaderAMDGPUFlags),
                    unsigned(ELF::EF_AMDGPU_MACH));
-    else if (e->e_machine == EM_RISCV)
-      W.printFlags("Flags", e->e_flags, makeArrayRef(ElfHeaderRISCVFlags));
     else
       W.printFlags("Flags", e->e_flags);
     W.printNumber("HeaderSize", e->e_ehsize);
diff --git a/unittests/ADT/TripleTest.cpp b/unittests/ADT/TripleTest.cpp
index efe859f158f..978f94a5493 100644
--- a/unittests/ADT/TripleTest.cpp
+++ b/unittests/ADT/TripleTest.cpp
@@ -301,24 +301,6 @@ TEST(TripleTest, ParsedIDs) {
   EXPECT_EQ(Triple::AMDPAL, T.getOS());
   EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
 
-  T = Triple("riscv32-unknown-unknown");
-  EXPECT_EQ(Triple::riscv32, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::UnknownOS, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
-  T = Triple("riscv64-unknown-linux");
-  EXPECT_EQ(Triple::riscv64, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::Linux, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
-  T = Triple("riscv64-unknown-freebsd");
-  EXPECT_EQ(Triple::riscv64, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::FreeBSD, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
   T = Triple("armv7hl-suse-linux-gnueabi");
   EXPECT_EQ(Triple::arm, T.getArch());
   EXPECT_EQ(Triple::SUSE, T.getVendor());
@@ -849,16 +831,6 @@ TEST(TripleTest, BitWidthPredicates) {
   EXPECT_FALSE(T.isArch16Bit());
   EXPECT_TRUE(T.isArch32Bit());
   EXPECT_FALSE(T.isArch64Bit());
-
-  T.setArch(Triple::riscv32);
-  EXPECT_FALSE(T.isArch16Bit());
-  EXPECT_TRUE(T.isArch32Bit());
-  EXPECT_FALSE(T.isArch64Bit());
-
-  T.setArch(Triple::riscv64);
-  EXPECT_FALSE(T.isArch16Bit());
-  EXPECT_FALSE(T.isArch32Bit());
-  EXPECT_TRUE(T.isArch64Bit());
 }
 
 TEST(TripleTest, BitWidthArchVariants) {
@@ -950,14 +922,6 @@ TEST(TripleTest, BitWidthArchVariants) {
   EXPECT_EQ(Triple::wasm32, T.get32BitArchVariant().getArch());
   EXPECT_EQ(Triple::wasm64, T.get64BitArchVariant().getArch());
 
-  T.setArch(Triple::riscv32);
-  EXPECT_EQ(Triple::riscv32, T.get32BitArchVariant().getArch());
-  EXPECT_EQ(Triple::riscv64, T.get64BitArchVariant().getArch());
-
-  T.setArch(Triple::riscv64);
-  EXPECT_EQ(Triple::riscv32, T.get32BitArchVariant().getArch());
-  EXPECT_EQ(Triple::riscv64, T.get64BitArchVariant().getArch());
-
   T.setArch(Triple::thumbeb);
   EXPECT_EQ(Triple::thumbeb, T.get32BitArchVariant().getArch());
   EXPECT_EQ(Triple::aarch64_be, T.get64BitArchVariant().getArch());
diff --git a/utils/TableGen/CMakeLists.txt b/utils/TableGen/CMakeLists.txt
index c88365a2b8c..ac8d502ad79 100644
--- a/utils/TableGen/CMakeLists.txt
+++ b/utils/TableGen/CMakeLists.txt
@@ -32,7 +32,6 @@ add_tablegen(llvm-tblgen LLVM
   OptParserEmitter.cpp
   PredicateExpander.cpp
   PseudoLoweringEmitter.cpp
-  RISCVCompressInstEmitter.cpp
   RegisterBankEmitter.cpp
   RegisterInfoEmitter.cpp
   SDNodeProperties.cpp
diff --git a/utils/TableGen/RISCVCompressInstEmitter.cpp b/utils/TableGen/RISCVCompressInstEmitter.cpp
deleted file mode 100644
index e03663b40f8..00000000000
--- a/utils/TableGen/RISCVCompressInstEmitter.cpp
+++ /dev/null
@@ -1,810 +0,0 @@
-//===- RISCVCompressInstEmitter.cpp - Generator for RISCV Compression -===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-// RISCVCompressInstEmitter implements a tablegen-driven CompressPat based
-// RISCV Instruction Compression mechanism.
-//
-//===--------------------------------------------------------------===//
-//
-// RISCVCompressInstEmitter implements a tablegen-driven CompressPat Instruction
-// Compression mechanism for generating RISCV compressed instructions
-// (C ISA Extension) from the expanded instruction form.
-
-// This tablegen backend processes CompressPat declarations in a
-// td file and generates all the required checks to validate the pattern
-// declarations; validate the input and output operands to generate the correct
-// compressed instructions. The checks include validating  different types of
-// operands; register operands, immediate operands, fixed register and fixed
-// immediate inputs.
-//
-// Example:
-// class CompressPat<dag input, dag output> {
-//   dag Input  = input;
-//   dag Output    = output;
-//   list<Predicate> Predicates = [];
-// }
-//
-// let Predicates = [HasStdExtC] in {
-// def : CompressPat<(ADD GPRNoX0:$rs1, GPRNoX0:$rs1, GPRNoX0:$rs2),
-//                   (C_ADD GPRNoX0:$rs1, GPRNoX0:$rs2)>;
-// }
-//
-// The result is an auto-generated header file
-// 'RISCVGenCompressInstEmitter.inc' which exports two functions for
-// compressing/uncompressing MCInst instructions, plus
-// some helper functions:
-//
-// bool compressInst(MCInst& OutInst, const MCInst &MI,
-//                   const MCSubtargetInfo &STI,
-//                   MCContext &Context);
-//
-// bool uncompressInst(MCInst& OutInst, const MCInst &MI,
-//                     const MCRegisterInfo &MRI,
-//                     const MCSubtargetInfo &STI);
-//
-// The clients that include this auto-generated header file and
-// invoke these functions can compress an instruction before emitting
-// it in the target-specific ASM or ELF streamer or can uncompress
-// an instruction before printing it when the expanded instruction
-// format aliases is favored.
-
-//===----------------------------------------------------------------------===//
-
-#include "CodeGenInstruction.h"
-#include "CodeGenTarget.h"
-#include "llvm/ADT/IndexedMap.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringMap.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/TableGen/Error.h"
-#include "llvm/TableGen/Record.h"
-#include "llvm/TableGen/TableGenBackend.h"
-#include <vector>
-using namespace llvm;
-
-#define DEBUG_TYPE "compress-inst-emitter"
-
-namespace {
-class RISCVCompressInstEmitter {
-  struct OpData {
-    enum MapKind { Operand, Imm, Reg };
-    MapKind Kind;
-    union {
-      unsigned Operand; // Operand number mapped to.
-      uint64_t Imm;     // Integer immediate value.
-      Record *Reg;      // Physical register.
-    } Data;
-    int TiedOpIdx = -1; // Tied operand index within the instruction.
-  };
-  struct CompressPat {
-    CodeGenInstruction Source; // The source instruction definition.
-    CodeGenInstruction Dest;   // The destination instruction to transform to.
-    std::vector<Record *>
-        PatReqFeatures; // Required target features to enable pattern.
-    IndexedMap<OpData>
-        SourceOperandMap; // Maps operands in the Source Instruction to
-                          // the corresponding Dest instruction operand.
-    IndexedMap<OpData>
-        DestOperandMap; // Maps operands in the Dest Instruction
-                        // to the corresponding Source instruction operand.
-    CompressPat(CodeGenInstruction &S, CodeGenInstruction &D,
-                std::vector<Record *> RF, IndexedMap<OpData> &SourceMap,
-                IndexedMap<OpData> &DestMap)
-        : Source(S), Dest(D), PatReqFeatures(RF), SourceOperandMap(SourceMap),
-          DestOperandMap(DestMap) {}
-  };
-
-  RecordKeeper &Records;
-  CodeGenTarget Target;
-  SmallVector<CompressPat, 4> CompressPatterns;
-
-  void addDagOperandMapping(Record *Rec, DagInit *Dag, CodeGenInstruction &Inst,
-                            IndexedMap<OpData> &OperandMap, bool IsSourceInst);
-  void evaluateCompressPat(Record *Compress);
-  void emitCompressInstEmitter(raw_ostream &o, bool Compress);
-  bool validateTypes(Record *SubType, Record *Type, bool IsSourceInst);
-  bool validateRegister(Record *Reg, Record *RegClass);
-  void createDagOperandMapping(Record *Rec, StringMap<unsigned> &SourceOperands,
-                               StringMap<unsigned> &DestOperands,
-                               DagInit *SourceDag, DagInit *DestDag,
-                               IndexedMap<OpData> &SourceOperandMap);
-
-  void createInstOperandMapping(Record *Rec, DagInit *SourceDag,
-                                DagInit *DestDag,
-                                IndexedMap<OpData> &SourceOperandMap,
-                                IndexedMap<OpData> &DestOperandMap,
-                                StringMap<unsigned> &SourceOperands,
-                                CodeGenInstruction &DestInst);
-
-public:
-  RISCVCompressInstEmitter(RecordKeeper &R) : Records(R), Target(R) {}
-
-  void run(raw_ostream &o);
-};
-} // End anonymous namespace.
-
-bool RISCVCompressInstEmitter::validateRegister(Record *Reg, Record *RegClass) {
-  assert(Reg->isSubClassOf("Register") && "Reg record should be a Register\n");
-  assert(RegClass->isSubClassOf("RegisterClass") && "RegClass record should be"
-                                                    " a RegisterClass\n");
-  CodeGenRegisterClass RC = Target.getRegisterClass(RegClass);
-  const CodeGenRegister *R = Target.getRegisterByName(Reg->getName().lower());
-  assert((R != nullptr) &&
-         ("Register" + Reg->getName().str() + " not defined!!\n").c_str());
-  return RC.contains(R);
-}
-
-bool RISCVCompressInstEmitter::validateTypes(Record *DagOpType,
-                                             Record *InstOpType,
-                                             bool IsSourceInst) {
-  if (DagOpType == InstOpType)
-    return true;
-  // Only source instruction operands are allowed to not match Input Dag
-  // operands.
-  if (!IsSourceInst)
-    return false;
-
-  if (DagOpType->isSubClassOf("RegisterClass") &&
-      InstOpType->isSubClassOf("RegisterClass")) {
-    CodeGenRegisterClass RC = Target.getRegisterClass(InstOpType);
-    CodeGenRegisterClass SubRC = Target.getRegisterClass(DagOpType);
-    return RC.hasSubClass(&SubRC);
-  }
-
-  // At this point either or both types are not registers, reject the pattern.
-  if (DagOpType->isSubClassOf("RegisterClass") ||
-      InstOpType->isSubClassOf("RegisterClass"))
-    return false;
-
-  // Let further validation happen when compress()/uncompress() functions are
-  // invoked.
-  LLVM_DEBUG(dbgs() << (IsSourceInst ? "Input" : "Output")
-                    << " Dag Operand Type: '" << DagOpType->getName()
-                    << "' and "
-                    << "Instruction Operand Type: '" << InstOpType->getName()
-                    << "' can't be checked at pattern validation time!\n");
-  return true;
-}
-
-/// The patterns in the Dag contain different types of operands:
-/// Register operands, e.g.: GPRC:$rs1; Fixed registers, e.g: X1; Immediate
-/// operands, e.g.: simm6:$imm; Fixed immediate operands, e.g.: 0. This function
-/// maps Dag operands to its corresponding instruction operands. For register
-/// operands and fixed registers it expects the Dag operand type to be contained
-/// in the instantiated instruction operand type. For immediate operands and
-/// immediates no validation checks are enforced at pattern validation time.
-void RISCVCompressInstEmitter::addDagOperandMapping(
-    Record *Rec, DagInit *Dag, CodeGenInstruction &Inst,
-    IndexedMap<OpData> &OperandMap, bool IsSourceInst) {
-  // TiedCount keeps track of the number of operands skipped in Inst
-  // operands list to get to the corresponding Dag operand. This is
-  // necessary because the number of operands in Inst might be greater
-  // than number of operands in the Dag due to how tied operands
-  // are represented.
-  unsigned TiedCount = 0;
-  for (unsigned i = 0, e = Inst.Operands.size(); i != e; ++i) {
-    int TiedOpIdx = Inst.Operands[i].getTiedRegister();
-    if (-1 != TiedOpIdx) {
-      // Set the entry in OperandMap for the tied operand we're skipping.
-      OperandMap[i].Kind = OperandMap[TiedOpIdx].Kind;
-      OperandMap[i].Data = OperandMap[TiedOpIdx].Data;
-      TiedCount++;
-      continue;
-    }
-    if (DefInit *DI = dyn_cast<DefInit>(Dag->getArg(i - TiedCount))) {
-      if (DI->getDef()->isSubClassOf("Register")) {
-        // Check if the fixed register belongs to the Register class.
-        if (!validateRegister(DI->getDef(), Inst.Operands[i].Rec))
-          PrintFatalError(Rec->getLoc(),
-                          "Error in Dag '" + Dag->getAsString() +
-                              "'Register: '" + DI->getDef()->getName() +
-                              "' is not in register class '" +
-                              Inst.Operands[i].Rec->getName() + "'");
-        OperandMap[i].Kind = OpData::Reg;
-        OperandMap[i].Data.Reg = DI->getDef();
-        continue;
-      }
-      // Validate that Dag operand type matches the type defined in the
-      // corresponding instruction. Operands in the input Dag pattern are
-      // allowed to be a subclass of the type specified in corresponding
-      // instruction operand instead of being an exact match.
-      if (!validateTypes(DI->getDef(), Inst.Operands[i].Rec, IsSourceInst))
-        PrintFatalError(Rec->getLoc(),
-                        "Error in Dag '" + Dag->getAsString() + "'. Operand '" +
-                            Dag->getArgNameStr(i - TiedCount) + "' has type '" +
-                            DI->getDef()->getName() +
-                            "' which does not match the type '" +
-                            Inst.Operands[i].Rec->getName() +
-                            "' in the corresponding instruction operand!");
-
-      OperandMap[i].Kind = OpData::Operand;
-    } else if (IntInit *II = dyn_cast<IntInit>(Dag->getArg(i - TiedCount))) {
-      // Validate that corresponding instruction operand expects an immediate.
-      if (Inst.Operands[i].Rec->isSubClassOf("RegisterClass"))
-        PrintFatalError(
-            Rec->getLoc(),
-            ("Error in Dag '" + Dag->getAsString() + "' Found immediate: '" +
-             II->getAsString() +
-             "' but corresponding instruction operand expected a register!"));
-      // No pattern validation check possible for values of fixed immediate.
-      OperandMap[i].Kind = OpData::Imm;
-      OperandMap[i].Data.Imm = II->getValue();
-      LLVM_DEBUG(
-          dbgs() << "  Found immediate '" << II->getValue() << "' at "
-                 << (IsSourceInst ? "input " : "output ")
-                 << "Dag. No validation time check possible for values of "
-                    "fixed immediate.\n");
-    } else
-      llvm_unreachable("Unhandled CompressPat argument type!");
-  }
-}
-
-// Verify the Dag operand count is enough to build an instruction.
-static bool verifyDagOpCount(CodeGenInstruction &Inst, DagInit *Dag,
-                             bool IsSource) {
-  if (Dag->getNumArgs() == Inst.Operands.size())
-    return true;
-  // Source instructions are non compressed instructions and don't have tied
-  // operands.
-  if (IsSource)
-    PrintFatalError("Input operands for Inst '" + Inst.TheDef->getName() +
-                    "' and input Dag operand count mismatch");
-  // The Dag can't have more arguments than the Instruction.
-  if (Dag->getNumArgs() > Inst.Operands.size())
-    PrintFatalError("Inst '" + Inst.TheDef->getName() +
-                    "' and Dag operand count mismatch");
-
-  // The Instruction might have tied operands so the Dag might have
-  //  a fewer operand count.
-  unsigned RealCount = Inst.Operands.size();
-  for (unsigned i = 0; i < Inst.Operands.size(); i++)
-    if (Inst.Operands[i].getTiedRegister() != -1)
-      --RealCount;
-
-  if (Dag->getNumArgs() != RealCount)
-    PrintFatalError("Inst '" + Inst.TheDef->getName() +
-                    "' and Dag operand count mismatch");
-  return true;
-}
-
-static bool validateArgsTypes(Init *Arg1, Init *Arg2) {
-  DefInit *Type1 = dyn_cast<DefInit>(Arg1);
-  DefInit *Type2 = dyn_cast<DefInit>(Arg2);
-  assert(Type1 && ("Arg1 type not found\n"));
-  assert(Type2 && ("Arg2 type not found\n"));
-  return Type1->getDef() == Type2->getDef();
-}
-
-// Creates a mapping between the operand name in the Dag (e.g. $rs1) and
-// its index in the list of Dag operands and checks that operands with the same
-// name have the same types. For example in 'C_ADD $rs1, $rs2' we generate the
-// mapping $rs1 --> 0, $rs2 ---> 1. If the operand appears twice in the (tied)
-// same Dag we use the last occurrence for indexing.
-void RISCVCompressInstEmitter::createDagOperandMapping(
-    Record *Rec, StringMap<unsigned> &SourceOperands,
-    StringMap<unsigned> &DestOperands, DagInit *SourceDag, DagInit *DestDag,
-    IndexedMap<OpData> &SourceOperandMap) {
-  for (unsigned i = 0; i < DestDag->getNumArgs(); ++i) {
-    // Skip fixed immediates and registers, they were handled in
-    // addDagOperandMapping.
-    if ("" == DestDag->getArgNameStr(i))
-      continue;
-    DestOperands[DestDag->getArgNameStr(i)] = i;
-  }
-
-  for (unsigned i = 0; i < SourceDag->getNumArgs(); ++i) {
-    // Skip fixed immediates and registers, they were handled in
-    // addDagOperandMapping.
-    if ("" == SourceDag->getArgNameStr(i))
-      continue;
-
-    StringMap<unsigned>::iterator it =
-        SourceOperands.find(SourceDag->getArgNameStr(i));
-    if (it != SourceOperands.end()) {
-      // Operand sharing the same name in the Dag should be mapped as tied.
-      SourceOperandMap[i].TiedOpIdx = it->getValue();
-      if (!validateArgsTypes(SourceDag->getArg(it->getValue()),
-                             SourceDag->getArg(i)))
-        PrintFatalError(Rec->getLoc(),
-                        "Input Operand '" + SourceDag->getArgNameStr(i) +
-                            "' has a mismatched tied operand!\n");
-    }
-    it = DestOperands.find(SourceDag->getArgNameStr(i));
-    if (it == DestOperands.end())
-      PrintFatalError(Rec->getLoc(), "Operand " + SourceDag->getArgNameStr(i) +
-                                         " defined in Input Dag but not used in"
-                                         " Output Dag!\n");
-    // Input Dag operand types must match output Dag operand type.
-    if (!validateArgsTypes(DestDag->getArg(it->getValue()),
-                           SourceDag->getArg(i)))
-      PrintFatalError(Rec->getLoc(), "Type mismatch between Input and "
-                                     "Output Dag operand '" +
-                                         SourceDag->getArgNameStr(i) + "'!");
-    SourceOperands[SourceDag->getArgNameStr(i)] = i;
-  }
-}
-
-/// Map operand names in the Dag to their index in both corresponding input and
-/// output instructions. Validate that operands defined in the input are
-/// used in the output pattern while populating the maps.
-void RISCVCompressInstEmitter::createInstOperandMapping(
-    Record *Rec, DagInit *SourceDag, DagInit *DestDag,
-    IndexedMap<OpData> &SourceOperandMap, IndexedMap<OpData> &DestOperandMap,
-    StringMap<unsigned> &SourceOperands, CodeGenInstruction &DestInst) {
-  // TiedCount keeps track of the number of operands skipped in Inst
-  // operands list to get to the corresponding Dag operand.
-  unsigned TiedCount = 0;
-  LLVM_DEBUG(dbgs() << "  Operand mapping:\n  Source   Dest\n");
-  for (unsigned i = 0, e = DestInst.Operands.size(); i != e; ++i) {
-    int TiedInstOpIdx = DestInst.Operands[i].getTiedRegister();
-    if (TiedInstOpIdx != -1) {
-      ++TiedCount;
-      DestOperandMap[i].Data = DestOperandMap[TiedInstOpIdx].Data;
-      DestOperandMap[i].Kind = DestOperandMap[TiedInstOpIdx].Kind;
-      if (DestOperandMap[i].Kind == OpData::Operand)
-        // No need to fill the SourceOperandMap here since it was mapped to
-        // destination operand 'TiedInstOpIdx' in a previous iteration.
-        LLVM_DEBUG(dbgs() << "    " << DestOperandMap[i].Data.Operand
-                          << " ====> " << i
-                          << "  Dest operand tied with operand '"
-                          << TiedInstOpIdx << "'\n");
-      continue;
-    }
-    // Skip fixed immediates and registers, they were handled in
-    // addDagOperandMapping.
-    if (DestOperandMap[i].Kind != OpData::Operand)
-      continue;
-
-    unsigned DagArgIdx = i - TiedCount;
-    StringMap<unsigned>::iterator SourceOp =
-        SourceOperands.find(DestDag->getArgNameStr(DagArgIdx));
-    if (SourceOp == SourceOperands.end())
-      PrintFatalError(Rec->getLoc(),
-                      "Output Dag operand '" +
-                          DestDag->getArgNameStr(DagArgIdx) +
-                          "' has no matching input Dag operand.");
-
-    assert(DestDag->getArgNameStr(DagArgIdx) ==
-               SourceDag->getArgNameStr(SourceOp->getValue()) &&
-           "Incorrect operand mapping detected!\n");
-    DestOperandMap[i].Data.Operand = SourceOp->getValue();
-    SourceOperandMap[SourceOp->getValue()].Data.Operand = i;
-    LLVM_DEBUG(dbgs() << "    " << SourceOp->getValue() << " ====> " << i
-                      << "\n");
-  }
-}
-
-/// Validates the CompressPattern and create operand mapping.
-/// These are the checks to validate a CompressPat pattern declarations.
-/// Error out with message under these conditions:
-/// - Dag Input opcode is an expanded instruction and Dag Output opcode is a
-///   compressed instruction.
-/// - Operands in Dag Input must be all used in Dag Output.
-///   Register Operand type in Dag Input Type  must be contained in the
-///   corresponding Source Instruction type.
-/// - Register Operand type in Dag Input must be the  same as in  Dag Ouput.
-/// - Register Operand type in  Dag Output must be the same  as the
-///   corresponding Destination Inst type.
-/// - Immediate Operand type in Dag Input must be the same as in Dag Ouput.
-/// - Immediate Operand type in Dag Ouput must be the same as the corresponding
-///   Destination Instruction type.
-/// - Fixed register must be contained in the corresponding Source Instruction
-///   type.
-/// - Fixed register must be contained in the corresponding Destination
-///   Instruction type. Warning message printed under these conditions:
-/// - Fixed immediate in Dag Input or Dag Ouput cannot be checked at this time
-///   and generate warning.
-/// - Immediate operand type in Dag Input differs from the corresponding Source
-///   Instruction type  and generate a warning.
-void RISCVCompressInstEmitter::evaluateCompressPat(Record *Rec) {
-  // Validate input Dag operands.
-  DagInit *SourceDag = Rec->getValueAsDag("Input");
-  assert(SourceDag && "Missing 'Input' in compress pattern!");
-  LLVM_DEBUG(dbgs() << "Input: " << *SourceDag << "\n");
-
-  DefInit *OpDef = dyn_cast<DefInit>(SourceDag->getOperator());
-  if (!OpDef)
-    PrintFatalError(Rec->getLoc(),
-                    Rec->getName() + " has unexpected operator type!");
-  // Checking we are transforming from compressed to uncompressed instructions.
-  Record *Operator = OpDef->getDef();
-  if (!Operator->isSubClassOf("RVInst"))
-    PrintFatalError(Rec->getLoc(), "Input instruction '" + Operator->getName() +
-                                       "' is not a 32 bit wide instruction!");
-  CodeGenInstruction SourceInst(Operator);
-  verifyDagOpCount(SourceInst, SourceDag, true);
-
-  // Validate output Dag operands.
-  DagInit *DestDag = Rec->getValueAsDag("Output");
-  assert(DestDag && "Missing 'Output' in compress pattern!");
-  LLVM_DEBUG(dbgs() << "Output: " << *DestDag << "\n");
-
-  DefInit *DestOpDef = dyn_cast<DefInit>(DestDag->getOperator());
-  if (!DestOpDef)
-    PrintFatalError(Rec->getLoc(),
-                    Rec->getName() + " has unexpected operator type!");
-
-  Record *DestOperator = DestOpDef->getDef();
-  if (!DestOperator->isSubClassOf("RVInst16"))
-    PrintFatalError(Rec->getLoc(), "Output instruction  '" +
-                                       DestOperator->getName() +
-                                       "' is not a 16 bit wide instruction!");
-  CodeGenInstruction DestInst(DestOperator);
-  verifyDagOpCount(DestInst, DestDag, false);
-
-  // Fill the mapping from the source to destination instructions.
-
-  IndexedMap<OpData> SourceOperandMap;
-  SourceOperandMap.grow(SourceInst.Operands.size());
-  // Create a mapping between source Dag operands and source Inst operands.
-  addDagOperandMapping(Rec, SourceDag, SourceInst, SourceOperandMap,
-                       /*IsSourceInst*/ true);
-
-  IndexedMap<OpData> DestOperandMap;
-  DestOperandMap.grow(DestInst.Operands.size());
-  // Create a mapping between destination Dag operands and destination Inst
-  // operands.
-  addDagOperandMapping(Rec, DestDag, DestInst, DestOperandMap,
-                       /*IsSourceInst*/ false);
-
-  StringMap<unsigned> SourceOperands;
-  StringMap<unsigned> DestOperands;
-  createDagOperandMapping(Rec, SourceOperands, DestOperands, SourceDag, DestDag,
-                          SourceOperandMap);
-  // Create operand mapping between the source and destination instructions.
-  createInstOperandMapping(Rec, SourceDag, DestDag, SourceOperandMap,
-                           DestOperandMap, SourceOperands, DestInst);
-
-  // Get the target features for the CompressPat.
-  std::vector<Record *> PatReqFeatures;
-  std::vector<Record *> RF = Rec->getValueAsListOfDefs("Predicates");
-  copy_if(RF, std::back_inserter(PatReqFeatures), [](Record *R) {
-    return R->getValueAsBit("AssemblerMatcherPredicate");
-  });
-
-  CompressPatterns.push_back(CompressPat(SourceInst, DestInst, PatReqFeatures,
-                                         SourceOperandMap, DestOperandMap));
-}
-
-static void getReqFeatures(std::map<StringRef, int> &FeaturesMap,
-                           const std::vector<Record *> &ReqFeatures) {
-  for (auto &R : ReqFeatures) {
-    StringRef AsmCondString = R->getValueAsString("AssemblerCondString");
-
-    // AsmCondString has syntax [!]F(,[!]F)*
-    SmallVector<StringRef, 4> Ops;
-    SplitString(AsmCondString, Ops, ",");
-    assert(!Ops.empty() && "AssemblerCondString cannot be empty");
-
-    for (auto &Op : Ops) {
-      assert(!Op.empty() && "Empty operator");
-      if (FeaturesMap.find(Op) == FeaturesMap.end())
-        FeaturesMap[Op] = FeaturesMap.size();
-    }
-  }
-}
-
-unsigned getMCOpPredicate(DenseMap<const Record *, unsigned> &MCOpPredicateMap,
-                          std::vector<const Record *> &MCOpPredicates,
-                          Record *Rec) {
-  unsigned Entry = MCOpPredicateMap[Rec];
-  if (Entry)
-    return Entry;
-
-  if (!Rec->isValueUnset("MCOperandPredicate")) {
-    MCOpPredicates.push_back(Rec);
-    Entry = MCOpPredicates.size();
-    MCOpPredicateMap[Rec] = Entry;
-    return Entry;
-  }
-
-  PrintFatalError(Rec->getLoc(),
-                  "No MCOperandPredicate on this operand at all: " +
-                      Rec->getName().str() + "'");
-  return 0;
-}
-
-static std::string mergeCondAndCode(raw_string_ostream &CondStream,
-                                    raw_string_ostream &CodeStream) {
-  std::string S;
-  raw_string_ostream CombinedStream(S);
-  CombinedStream.indent(4)
-      << "if ("
-      << CondStream.str().substr(
-             6, CondStream.str().length() -
-                    10) // remove first indentation and last '&&'.
-      << ") {\n";
-  CombinedStream << CodeStream.str();
-  CombinedStream.indent(4) << "  return true;\n";
-  CombinedStream.indent(4) << "} // if\n";
-  return CombinedStream.str();
-}
-
-void RISCVCompressInstEmitter::emitCompressInstEmitter(raw_ostream &o,
-                                                       bool Compress) {
-  Record *AsmWriter = Target.getAsmWriter();
-  if (!AsmWriter->getValueAsInt("PassSubtarget"))
-    PrintFatalError("'PassSubtarget' is false. SubTargetInfo object is needed "
-                    "for target features.\n");
-
-  std::string Namespace = Target.getName();
-
-  // Sort entries in CompressPatterns to handle instructions that can have more
-  // than one candidate for compression\uncompression, e.g ADD can be
-  // transformed to a C_ADD or a C_MV. When emitting 'uncompress()' function the
-  // source and destination are flipped and the sort key needs to change
-  // accordingly.
-  std::stable_sort(CompressPatterns.begin(), CompressPatterns.end(),
-                   [Compress](const CompressPat &LHS, const CompressPat &RHS) {
-                     if (Compress)
-                       return (LHS.Source.TheDef->getName().str() <
-                               RHS.Source.TheDef->getName().str());
-                     else
-                       return (LHS.Dest.TheDef->getName().str() <
-                               RHS.Dest.TheDef->getName().str());
-                   });
-
-  // A list of MCOperandPredicates for all operands in use, and the reverse map.
-  std::vector<const Record *> MCOpPredicates;
-  DenseMap<const Record *, unsigned> MCOpPredicateMap;
-
-  std::string F;
-  std::string FH;
-  raw_string_ostream Func(F);
-  raw_string_ostream FuncH(FH);
-  bool NeedMRI = false;
-
-  if (Compress)
-    o << "\n#ifdef GEN_COMPRESS_INSTR\n"
-      << "#undef GEN_COMPRESS_INSTR\n\n";
-  else
-    o << "\n#ifdef GEN_UNCOMPRESS_INSTR\n"
-      << "#undef GEN_UNCOMPRESS_INSTR\n\n";
-
-  if (Compress) {
-    FuncH << "static bool compressInst(MCInst& OutInst,\n";
-    FuncH.indent(25) << "const MCInst &MI,\n";
-    FuncH.indent(25) << "const MCSubtargetInfo &STI,\n";
-    FuncH.indent(25) << "MCContext &Context) {\n";
-  } else {
-    FuncH << "static bool uncompressInst(MCInst& OutInst,\n";
-    FuncH.indent(27) << "const MCInst &MI,\n";
-    FuncH.indent(27) << "const MCRegisterInfo &MRI,\n";
-    FuncH.indent(27) << "const MCSubtargetInfo &STI) {\n";
-  }
-
-  if (CompressPatterns.empty()) {
-    o << FuncH.str();
-    o.indent(2) << "return false;\n}\n";
-    if (Compress)
-      o << "\n#endif //GEN_COMPRESS_INSTR\n";
-    else
-      o << "\n#endif //GEN_UNCOMPRESS_INSTR\n\n";
-    return;
-  }
-
-  std::string CaseString("");
-  raw_string_ostream CaseStream(CaseString);
-  std::string PrevOp("");
-  std::string CurOp("");
-  CaseStream << "  switch (MI.getOpcode()) {\n";
-  CaseStream << "    default: return false;\n";
-
-  for (auto &CompressPat : CompressPatterns) {
-    std::string CondString;
-    std::string CodeString;
-    raw_string_ostream CondStream(CondString);
-    raw_string_ostream CodeStream(CodeString);
-    CodeGenInstruction &Source =
-        Compress ? CompressPat.Source : CompressPat.Dest;
-    CodeGenInstruction &Dest = Compress ? CompressPat.Dest : CompressPat.Source;
-    IndexedMap<OpData> SourceOperandMap =
-        Compress ? CompressPat.SourceOperandMap : CompressPat.DestOperandMap;
-    IndexedMap<OpData> &DestOperandMap =
-        Compress ? CompressPat.DestOperandMap : CompressPat.SourceOperandMap;
-
-    CurOp = Source.TheDef->getName().str();
-    // Check current and previous opcode to decide to continue or end a case.
-    if (CurOp != PrevOp) {
-      if (PrevOp != "")
-        CaseStream.indent(6) << "break;\n    } // case " + PrevOp + "\n";
-      CaseStream.indent(4) << "case " + Namespace + "::" + CurOp + ": {\n";
-    }
-
-    std::map<StringRef, int> FeaturesMap;
-    // Add CompressPat required features.
-    getReqFeatures(FeaturesMap, CompressPat.PatReqFeatures);
-
-    // Add Dest instruction required features.
-    std::vector<Record *> ReqFeatures;
-    std::vector<Record *> RF = Dest.TheDef->getValueAsListOfDefs("Predicates");
-    copy_if(RF, std::back_inserter(ReqFeatures), [](Record *R) {
-      return R->getValueAsBit("AssemblerMatcherPredicate");
-    });
-    getReqFeatures(FeaturesMap, ReqFeatures);
-
-    // Emit checks for all required features.
-    for (auto &F : FeaturesMap) {
-      StringRef Op = F.first;
-      if (Op[0] == '!')
-        CondStream.indent(6) << ("!STI.getFeatureBits()[" + Namespace +
-                                 "::" + Op.substr(1) + "]")
-                                        .str() +
-                                    " &&\n";
-      else
-        CondStream.indent(6)
-            << ("STI.getFeatureBits()[" + Namespace + "::" + Op + "]").str() +
-                   " &&\n";
-    }
-
-    // Start Source Inst operands validation.
-    unsigned OpNo = 0;
-    for (OpNo = 0; OpNo < Source.Operands.size(); ++OpNo) {
-      if (SourceOperandMap[OpNo].TiedOpIdx != -1) {
-        if (Source.Operands[OpNo].Rec->isSubClassOf("RegisterClass"))
-          CondStream.indent(6)
-              << "(MI.getOperand("
-              << std::to_string(OpNo) + ").getReg() ==  MI.getOperand("
-              << std::to_string(SourceOperandMap[OpNo].TiedOpIdx)
-              << ").getReg()) &&\n";
-        else
-          PrintFatalError("Unexpected tied operand types!\n");
-      }
-      // Check for fixed immediates\registers in the source instruction.
-      switch (SourceOperandMap[OpNo].Kind) {
-      case OpData::Operand:
-        // We don't need to do anything for source instruction operand checks.
-        break;
-      case OpData::Imm:
-        CondStream.indent(6)
-            << "(MI.getOperand(" + std::to_string(OpNo) + ").isImm()) &&\n" +
-                   "      (MI.getOperand(" + std::to_string(OpNo) +
-                   ").getImm() == " +
-                   std::to_string(SourceOperandMap[OpNo].Data.Imm) + ") &&\n";
-        break;
-      case OpData::Reg: {
-        Record *Reg = SourceOperandMap[OpNo].Data.Reg;
-        CondStream.indent(6) << "(MI.getOperand(" + std::to_string(OpNo) +
-                                    ").getReg() == " + Namespace +
-                                    "::" + Reg->getName().str() + ") &&\n";
-        break;
-      }
-      }
-    }
-    CodeStream.indent(6) << "// " + Dest.AsmString + "\n";
-    CodeStream.indent(6) << "OutInst.setOpcode(" + Namespace +
-                                "::" + Dest.TheDef->getName().str() + ");\n";
-    OpNo = 0;
-    for (const auto &DestOperand : Dest.Operands) {
-      CodeStream.indent(6) << "// Operand: " + DestOperand.Name + "\n";
-      switch (DestOperandMap[OpNo].Kind) {
-      case OpData::Operand: {
-        unsigned OpIdx = DestOperandMap[OpNo].Data.Operand;
-        // Check that the operand in the Source instruction fits
-        // the type for the Dest instruction.
-        if (DestOperand.Rec->isSubClassOf("RegisterClass")) {
-          NeedMRI = true;
-          // This is a register operand. Check the register class.
-          // Don't check register class if this is a tied operand, it was done
-          // for the operand its tied to.
-          if (DestOperand.getTiedRegister() == -1)
-            CondStream.indent(6)
-                << "(MRI.getRegClass(" + Namespace +
-                       "::" + DestOperand.Rec->getName().str() +
-                       "RegClassID).contains(" + "MI.getOperand(" +
-                       std::to_string(OpIdx) + ").getReg())) &&\n";
-
-          CodeStream.indent(6) << "OutInst.addOperand(MI.getOperand(" +
-                                      std::to_string(OpIdx) + "));\n";
-        } else {
-          // Handling immediate operands.
-          unsigned Entry = getMCOpPredicate(MCOpPredicateMap, MCOpPredicates,
-                                            DestOperand.Rec);
-          CondStream.indent(6) << Namespace + "ValidateMCOperand(" +
-                                      "MI.getOperand(" + std::to_string(OpIdx) +
-                                      "), STI, " + std::to_string(Entry) +
-                                      ") &&\n";
-          CodeStream.indent(6) << "OutInst.addOperand(MI.getOperand(" +
-                                      std::to_string(OpIdx) + "));\n";
-        }
-        break;
-      }
-      case OpData::Imm: {
-        unsigned Entry =
-            getMCOpPredicate(MCOpPredicateMap, MCOpPredicates, DestOperand.Rec);
-        CondStream.indent(6)
-            << Namespace + "ValidateMCOperand(" + "MCOperand::createImm(" +
-                   std::to_string(DestOperandMap[OpNo].Data.Imm) + "), STI, " +
-                   std::to_string(Entry) + ") &&\n";
-        CodeStream.indent(6)
-            << "OutInst.addOperand(MCOperand::createImm(" +
-                   std::to_string(DestOperandMap[OpNo].Data.Imm) + "));\n";
-      } break;
-      case OpData::Reg: {
-        // Fixed register has been validated at pattern validation time.
-        Record *Reg = DestOperandMap[OpNo].Data.Reg;
-        CodeStream.indent(6) << "OutInst.addOperand(MCOperand::createReg(" +
-                                    Namespace + "::" + Reg->getName().str() +
-                                    "));\n";
-      } break;
-      }
-      ++OpNo;
-    }
-    CaseStream << mergeCondAndCode(CondStream, CodeStream);
-    PrevOp = CurOp;
-  }
-  Func << CaseStream.str() << "\n";
-  // Close brace for the last case.
-  Func.indent(4) << "} // case " + CurOp + "\n";
-  Func.indent(2) << "} // switch\n";
-  Func.indent(2) << "return false;\n}\n";
-
-  if (!MCOpPredicates.empty()) {
-    o << "static bool " << Namespace
-      << "ValidateMCOperand(const MCOperand &MCOp,\n"
-      << "                  const MCSubtargetInfo &STI,\n"
-      << "                  unsigned PredicateIndex) {\n"
-      << "  switch (PredicateIndex) {\n"
-      << "  default:\n"
-      << "    llvm_unreachable(\"Unknown MCOperandPredicate kind\");\n"
-      << "    break;\n";
-
-    for (unsigned i = 0; i < MCOpPredicates.size(); ++i) {
-      Init *MCOpPred = MCOpPredicates[i]->getValueInit("MCOperandPredicate");
-      if (CodeInit *SI = dyn_cast<CodeInit>(MCOpPred))
-        o << "  case " << i + 1 << ": {\n"
-          << "   // " << MCOpPredicates[i]->getName().str() << SI->getValue()
-          << "\n"
-          << "    }\n";
-      else
-        llvm_unreachable("Unexpected MCOperandPredicate field!");
-    }
-    o << "  }\n"
-      << "}\n\n";
-  }
-
-  o << FuncH.str();
-  if (NeedMRI && Compress)
-    o.indent(2) << "const MCRegisterInfo &MRI = *Context.getRegisterInfo();\n";
-  o << Func.str();
-
-  if (Compress)
-    o << "\n#endif //GEN_COMPRESS_INSTR\n";
-  else
-    o << "\n#endif //GEN_UNCOMPRESS_INSTR\n\n";
-}
-
-void RISCVCompressInstEmitter::run(raw_ostream &o) {
-  Record *CompressClass = Records.getClass("CompressPat");
-  assert(CompressClass && "Compress class definition missing!");
-  std::vector<Record *> Insts;
-  for (const auto &D : Records.getDefs()) {
-    if (D.second->isSubClassOf(CompressClass))
-      Insts.push_back(D.second.get());
-  }
-
-  // Process the CompressPat definitions, validating them as we do so.
-  for (unsigned i = 0, e = Insts.size(); i != e; ++i)
-    evaluateCompressPat(Insts[i]);
-
-  // Emit file header.
-  emitSourceFileHeader("Compress instruction Source Fragment", o);
-  // Generate compressInst() function.
-  emitCompressInstEmitter(o, true);
-  // Generate uncompressInst() function.
-  emitCompressInstEmitter(o, false);
-}
-
-namespace llvm {
-
-void EmitCompressInst(RecordKeeper &RK, raw_ostream &OS) {
-  RISCVCompressInstEmitter(RK).run(OS);
-}
-
-} // namespace llvm
diff --git a/utils/TableGen/TableGen.cpp b/utils/TableGen/TableGen.cpp
index d5b6a3c1264..67648d2c147 100644
--- a/utils/TableGen/TableGen.cpp
+++ b/utils/TableGen/TableGen.cpp
@@ -33,7 +33,6 @@ enum ActionType {
   GenAsmMatcher,
   GenDisassembler,
   GenPseudoLowering,
-  GenCompressInst,
   GenCallingConv,
   GenDAGISel,
   GenDFAPacketizer,
@@ -79,8 +78,6 @@ namespace {
                                "Generate disassembler"),
                     clEnumValN(GenPseudoLowering, "gen-pseudo-lowering",
                                "Generate pseudo instruction lowering"),
-                    clEnumValN(GenCompressInst, "gen-compress-inst-emitter",
-                               "Generate RISCV compressed instructions."),
                     clEnumValN(GenAsmMatcher, "gen-asm-matcher",
                                "Generate assembly instruction matcher"),
                     clEnumValN(GenDAGISel, "gen-dag-isel",
@@ -162,9 +159,6 @@ bool LLVMTableGenMain(raw_ostream &OS, RecordKeeper &Records) {
   case GenPseudoLowering:
     EmitPseudoLowering(Records, OS);
     break;
-  case GenCompressInst:
-    EmitCompressInst(Records, OS);
-    break;
   case GenDAGISel:
     EmitDAGISel(Records, OS);
     break;
diff --git a/utils/TableGen/TableGenBackends.h b/utils/TableGen/TableGenBackends.h
index f4f2909f8e8..188492da6f1 100644
--- a/utils/TableGen/TableGenBackends.h
+++ b/utils/TableGen/TableGenBackends.h
@@ -77,7 +77,6 @@ void EmitFastISel(RecordKeeper &RK, raw_ostream &OS);
 void EmitInstrInfo(RecordKeeper &RK, raw_ostream &OS);
 void EmitInstrDocs(RecordKeeper &RK, raw_ostream &OS);
 void EmitPseudoLowering(RecordKeeper &RK, raw_ostream &OS);
-void EmitCompressInst(RecordKeeper &RK, raw_ostream &OS);
 void EmitRegisterInfo(RecordKeeper &RK, raw_ostream &OS);
 void EmitSubtarget(RecordKeeper &RK, raw_ostream &OS);
 void EmitMapTable(RecordKeeper &RK, raw_ostream &OS);
diff --git a/utils/UpdateTestChecks/asm.py b/utils/UpdateTestChecks/asm.py
index 923efd5bbef..76ae67566da 100644
--- a/utils/UpdateTestChecks/asm.py
+++ b/utils/UpdateTestChecks/asm.py
@@ -62,12 +62,6 @@ ASM_FUNCTION_PPC_RE = re.compile(
     r'.Lfunc_end[0-9]+:\n',
     flags=(re.M | re.S))
 
-ASM_FUNCTION_RISCV_RE = re.compile(
-    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@(?P=func)\n[^:]*?'
-    r'(?P<body>^##?[ \t]+[^:]+:.*?)\s*'
-    r'.Lfunc_end[0-9]+:\n',
-    flags=(re.M | re.S))
-
 ASM_FUNCTION_SPARC_RE = re.compile(
     r'^_?(?P<func>[^:]+):[ \t]*!+[ \t]*@(?P=func)\n'
     r'(?P<body>.*?)\s*'
@@ -169,16 +163,6 @@ def scrub_asm_mips(asm, args):
   asm = common.SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
   return asm
 
-def scrub_asm_riscv(asm, args):
-  # Scrub runs of whitespace out of the assembly, but leave the leading
-  # whitespace in place.
-  asm = common.SCRUB_WHITESPACE_RE.sub(r' ', asm)
-  # Expand the tabs used for indentation.
-  asm = string.expandtabs(asm, 2)
-  # Strip trailing whitespace.
-  asm = common.SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
-  return asm
-
 def scrub_asm_sparc(asm, args):
   # Scrub runs of whitespace out of the assembly, but leave the leading
   # whitespace in place.
@@ -233,8 +217,6 @@ def build_function_body_dictionary_for_triple(args, raw_tool_output, triple, pre
       'mips': (scrub_asm_mips, ASM_FUNCTION_MIPS_RE),
       'powerpc64': (scrub_asm_powerpc64, ASM_FUNCTION_PPC_RE),
       'powerpc64le': (scrub_asm_powerpc64, ASM_FUNCTION_PPC_RE),
-      'riscv32': (scrub_asm_riscv, ASM_FUNCTION_RISCV_RE),
-      'riscv64': (scrub_asm_riscv, ASM_FUNCTION_RISCV_RE),
       'sparc': (scrub_asm_sparc, ASM_FUNCTION_SPARC_RE),
       'sparcv9': (scrub_asm_sparc, ASM_FUNCTION_SPARC_RE),
       's390x': (scrub_asm_systemz, ASM_FUNCTION_SYSTEMZ_RE),
diff --git a/utils/gn/secondary/clang/lib/Basic/BUILD.gn b/utils/gn/secondary/clang/lib/Basic/BUILD.gn
index 60323db120a..a4f561fde77 100644
--- a/utils/gn/secondary/clang/lib/Basic/BUILD.gn
+++ b/utils/gn/secondary/clang/lib/Basic/BUILD.gn
@@ -62,7 +62,6 @@ static_library("Basic") {
     "Targets/OSTargets.cpp",
     "Targets/PNaCl.cpp",
     "Targets/PPC.cpp",
-    "Targets/RISCV.cpp",
     "Targets/SPIR.cpp",
     "Targets/Sparc.cpp",
     "Targets/SystemZ.cpp",
diff --git a/utils/gn/secondary/clang/lib/Driver/BUILD.gn b/utils/gn/secondary/clang/lib/Driver/BUILD.gn
index ce80af8e179..bb11844d8a8 100644
--- a/utils/gn/secondary/clang/lib/Driver/BUILD.gn
+++ b/utils/gn/secondary/clang/lib/Driver/BUILD.gn
@@ -47,7 +47,6 @@ static_library("Driver") {
     "ToolChains/Arch/ARM.cpp",
     "ToolChains/Arch/Mips.cpp",
     "ToolChains/Arch/PPC.cpp",
-    "ToolChains/Arch/RISCV.cpp",
     "ToolChains/Arch/Sparc.cpp",
     "ToolChains/Arch/SystemZ.cpp",
     "ToolChains/Arch/X86.cpp",
@@ -77,7 +76,6 @@ static_library("Driver") {
     "ToolChains/NetBSD.cpp",
     "ToolChains/OpenBSD.cpp",
     "ToolChains/PS4CPU.cpp",
-    "ToolChains/RISCVToolchain.cpp",
     "ToolChains/Solaris.cpp",
     "ToolChains/TCE.cpp",
     "ToolChains/WebAssembly.cpp",
diff --git a/utils/gn/secondary/lld/ELF/BUILD.gn b/utils/gn/secondary/lld/ELF/BUILD.gn
index d5f8a899995..0829d82e582 100644
--- a/utils/gn/secondary/lld/ELF/BUILD.gn
+++ b/utils/gn/secondary/lld/ELF/BUILD.gn
@@ -33,7 +33,6 @@ static_library("ELF") {
     "Arch/MipsArchTree.cpp",
     "Arch/PPC.cpp",
     "Arch/PPC64.cpp",
-    "Arch/RISCV.cpp",
     "Arch/SPARCV9.cpp",
     "Arch/X86.cpp",
     "Arch/X86_64.cpp",
diff --git a/utils/gn/secondary/llvm/utils/TableGen/BUILD.gn b/utils/gn/secondary/llvm/utils/TableGen/BUILD.gn
index 01219543d2d..232e6e47a94 100644
--- a/utils/gn/secondary/llvm/utils/TableGen/BUILD.gn
+++ b/utils/gn/secondary/llvm/utils/TableGen/BUILD.gn
@@ -38,7 +38,6 @@ executable("llvm-tblgen") {
     "OptParserEmitter.cpp",
     "PredicateExpander.cpp",
     "PseudoLoweringEmitter.cpp",
-    "RISCVCompressInstEmitter.cpp",
     "RegisterBankEmitter.cpp",
     "RegisterInfoEmitter.cpp",
     "SDNodeProperties.cpp",
-- 
2.17.2

